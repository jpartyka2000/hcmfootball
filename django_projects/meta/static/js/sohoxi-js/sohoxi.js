/**
* Soho XI Controls v4.3.1
* Date: 02/08/2017 5:43:08 PM
* Revision: e252d2880f89e8aed3b77d55c708c04fa428414c
*/
(function(factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module
        define(['jquery'], factory);
      } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
      } else {
        // Browser globals
        factory(jQuery);
      }
    }(function($) {
  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.personalize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'personalize',
        defaults = {
          colors: '',
          theme: ''
        },
        settings = $.extend({}, defaults, options);

    /**
    * The personalization routines for setting custom company colors.
    *
    * @class Personalize
    * @param {String} colors  &nbsp;-&nbsp; The list of colors
    * @param {String} theme  &nbsp;-&nbsp; The theme name (light, dark or high-contrast)
    *
    */
    function Personalize(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Personalize.prototype = {
      init: function() {
        this.makeSohoObject()
        .handleEvents();

        if (this.settings.colors) {
          this.setColors(this.settings.colors);
        }

        if (this.settings.theme) {
          this.setTheme(this.settings.theme);
        }
        return this;
      },

      makeSohoObject: function () {
        var self = this;

        window.Soho = window.Soho || {};

        //Handle Personalization and theme
        window.Soho.theme = 'light';

        window.Soho.setTheme = function(theme) { // jshint ignore:line
          self.setTheme(theme);
        };

        window.Soho.setColors = function(colors) { // jshint ignore:line
          self.setColors(colors);
        };

        window.Soho.getColorStyleSheet = function(colors) { // jshint ignore:line
          return self.getColorStyleSheet(colors);
        };

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('changecolors.' + pluginName, function(e, newColor, noAnimate) {
          self.setColors(newColor, noAnimate);
        }).on('changetheme.' + pluginName, function(e, theme) {
          self.setTheme(theme);
        });

        return this;
      },

      // Validates a string containing a hexadecimal number
      // @param {String} hex: A hex color.
      // @returns {String} a validated hexadecimal string.
      validateHex: function(hex) {
        hex = String(hex).replace(/[^0-9a-f]/gi, '');

        if (hex.length < 6) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        return '#' + hex;
      },

      appendStyleSheet: function(cssRules) {
        var sheet = document.getElementById('soho-personalization');
        if (sheet) {
          sheet.parentNode.removeChild(sheet);
        }

        // Create the <style> tag
        sheet = document.createElement('style');
        sheet.setAttribute('id', 'soho-personalization');
        sheet.appendChild(document.createTextNode(cssRules));

      	// Add the <style> element to the page
      	document.head.appendChild(sheet);
      },

      getColorStyleSheet: function(colors)  {
        Soho.colors = colors;

        if (typeof colors === 'string') {
          Soho.colors = {};
          Soho.colors.header = colors;
        }

        if (!colors || colors === '') {
          return this;
        }

        // Default Colors...
        // (Color)07 for the main color (fx headers)
        // (Color)06 for the secondary color (fx sub-headers)
        // Light or Dark (fff or 000) for the contrast color

        // (Color)06 for the vertical borders between module tabs - 133C59
        // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
        // (Color)08 for the inactive module tab - 1d5f8a
        // (Color)09 for the horizontal border - 134D71
        // (Color)10 for the hover state on module tab - 133C59
        var defaultColors = {header: '2578A9',
                             subheader: '368AC0',
                             text: 'ffffff',
                             verticalBorder: '133C59',
                             horizontalBorder: '134D71',
                             inactive: '1d5f8a',
                             hover: '133C59'};

        // If an event sends a blank string through instead of a hex,
        // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.
        Soho.colors.header = this.validateHex(Soho.colors.header || defaultColors.header);
        Soho.colors.text = this.validateHex(Soho.colors.text || defaultColors.text);
        Soho.colors.subheader = this.validateHex(Soho.colors.subheader || this.getLuminousColorShade(Soho.colors.header, 0.2));
        Soho.colors.inactive = this.validateHex(Soho.colors.inactive || this.getLuminousColorShade(Soho.colors.header, -0.22));
        Soho.colors.verticalBorder = this.validateHex(Soho.colors.verticalBorder || this.getLuminousColorShade(Soho.colors.header, 0.1));
        Soho.colors.horizontalBorder = this.validateHex(Soho.colors.horizontalBorder || this.getLuminousColorShade(Soho.colors.header, -0.4));
        Soho.colors.hover = this.validateHex(Soho.colors.hover || this.getLuminousColorShade(Soho.colors.header, -0.5));

        //not that the sheet is appended in backwards
        var cssRules = '.tab-container.module-tabs.is-personalizable { border-top: 1px solid '+ Soho.colors.horizontalBorder +' !important; border-bottom: 1px solid ' + Soho.colors.horizontalBorder + ' !important}' +
        ' .module-tabs.is-personalizable .tab:not(:first-child) { border-left: 1px solid '+ Soho.colors.verticalBorder +' !important}'  +
        ' .module-tabs.is-personalizable { background-color: '+ Soho.colors.inactive +' !important}'  +
        ' .module-tabs.is-personalizable .tab.is-selected { background-color: '+ Soho.colors.header +' !important}'  +
        ' .accordion.panel .accordion-header.is-selected { background-color: '+ Soho.colors.subheader +' !important; color: '+ Soho.colors.text +' !important}'  +
        ' .builder-header.is-personalizable{ background-color: '+ Soho.colors.subheader +'}'  +
        ' .header.is-personalizable { background-color: '+ Soho.colors.header +'}' +
        ' .header.is-personalizable .title { color: '+ Soho.colors.text +'}' +
        ' .header.is-personalizable h1 { color: '+ Soho.colors.text +'}' +
        ' .module-tabs.is-personalizable .tab-more { border-left: '+ Soho.colors.verticalBorder +' !important}' +
        ' .module-tabs.is-personalizable .tab-more:hover { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab-more.is-open { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab-more.is-selected { background-color: '+ Soho.colors.header +' !important}' +
        ' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield { background-color: '+ Soho.colors.hover +' !important; border-bottom-color: ' + Soho.colors.hover  +' !important}' +
        ' .subheader.is-personalizable { background-color: '+ Soho.colors.subheader +' !important}' +
        ' .builder .sidebar .header {border-right: 1px solid '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab:hover { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar { border-left: '+ Soho.colors.verticalBorder +' !important}' +
        ' .module-tabs.is-personalizable [class^="btn"] { background-color: '+ Soho.colors.inactive +' !important}' +
        ' .hero-widget.is-personalizable { background-color: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .hero-bottom { background-color: '+ Soho.colors.header +' }' +
        ' .hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before { color: '+ Soho.colors.verticalBorder +' }' +
        ' .hero-widget.is-personalizable .chart-container .arc { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container .bar { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container.line-chart .dot { stroke: '+ Soho.colors.subheader +' }' +
        '';

        return cssRules;
      },

      /**
      * Sets the personalization color(s)
      *
      * @param {Array} colors  &nbsp;-&nbsp; The original hex color as a string or an object with all the Colors
      */
      setColors: function(colors) {
        if (!colors) {
          return;
        }

        this.appendStyleSheet(this.getColorStyleSheet(colors));
        return this;
      },

      /**
      * Takes a color and performs a change in luminosity of that color programatically.
      * @param {String} hex  &nbsp;-&nbsp; The original Hexadecimal base color.
      * @param {String} lum  &nbsp;-&nbsp; A percentage used to set luminosity change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
      * @returns {String} hexadecimal color.
      */
      getLuminousColorShade: function(hex, lum) {
        // validate hex string
        hex = this.validateHex(hex).substr(1);
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = '#', c, i;
        for (i = 0; i < 3; i++) {
          c = parseInt(hex.substr(i*2, 2), 16);
          c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
          rgb += ('00' + c).substr(c.length);
        }

        return rgb;
      },

      availableThemes: [
        'light',
        'dark',
        'high-contrast'
      ],

      /**
      * Sets the current theme, blocking the ui during the change.
      *
      * @param {String} theme  &nbsp;-&nbsp; Represents the file name of a color scheme (can be dark, light or high-contrast)
      */
      setTheme: function(theme) {
        if (Soho.theme === theme) {
          return;
        }

        Soho.theme = theme;
        // validate theme
        if (this.availableThemes.indexOf(theme) === -1) {
          return;
        }

        this.blockUi();

        var self = this,
          originalCss = $('#stylesheet, #sohoxi-stylesheet'),
          newCss = $('<link rel="stylesheet">'),
          path = originalCss.attr('href');

        newCss.on('load', function() {
          originalCss.remove();
          self.unBlockUi();
        });

        newCss.attr({
          id: originalCss.attr('id'),
          href: path.substring(0, path.lastIndexOf('/')) + '/' + theme + '-theme' + (path.indexOf('.min') > -1 ? '.min' : '') + '.css'
        });
        originalCss.removeAttr('id');
        originalCss.after(newCss);
      },

      //Block the ui from FOUC
      blockUi: function () {

        this.pageOverlay = this.pageOverlay || $('<div style="' +
        	'background: ' + (Soho.theme === 'light' ? '#f0f0f0;' : (Soho.theme === 'dark' ? '#313236;' : '#bdbdbd;')) +
        	'display: block;' +
          'height: 100%;' +
        	'left: 0;' +
        	'position: fixed;' +
          'text-align: center;' +
        	'top: 0;' +
        	'width: 100%;' +
          'z-index: 10000;' +
          '"></div>'
        );

        $('body').append(this.pageOverlay);
      },

      unBlockUi: function (){
        var self = this;

        self.pageOverlay.fadeOut(300, function() {
          self.pageOverlay.remove();
          self.pageOverlay = undefined;
        });
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      // Ideally this will do non-destructive things that make it possible to easily rebuild
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Personalize(this, settings));
      }
    });
  };


  $.fn.initialize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'initialize',
        defaults = {
          locale: Locale.currentLocale.name || 'en-US'
        },
        settings;

      if (typeof options === 'string') {
        settings = {};
        settings.locale = options;
      } else {
        settings = $.extend({}, defaults, options);
      }

    /**
     * Page Bootstrapper
     * @constructor
     * @param {Object} element
     */
    function Initialize(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Initialize.prototype = {
      init: function() {
        var self = this;

        Locale.set(this.settings.locale).done(function () {
          self.initAll();
        });

        return this;
      },

      initAll : function () {
        var self = this;

        // Iterate all objects we are initializing
        this.element.filter(':not(.no-init)').each(function() {
          var elem = $(this),
            noinitExcludes = '.no-init, [data-init]';

          function invokeWithInlineOptions(elem, plugin) {
            var options = $.fn.parseOptions(elem);
            $(elem)[plugin](options);
          }

          function matchedItems(selector) {
            var items = elem.find(selector);
            if (elem.filter(selector).length) {
              items = items.add(elem);
            }
            return items;
          }

          function simpleInit(plugin, selector) {
            //Allow only the plugin name to be specified if the default selector is a class with the same name
            //Like $.fn.header applying to elements that match .header
            if (typeof selector === 'undefined') {
              selector = '.' + plugin;
            }

            if ($.fn[plugin]) {
              matchedItems(selector).each(function () {
                var elem = $(this);

                if (elem.is(noinitExcludes) && selector !=='[data-trackdirty="true"]') {
                  return;
                }

                if (elem.parents().hasClass('no-init')) {
                  return;
                }

                // Don't invoke elements inside of "container" controls that need to invoke their internal
                // items in a specific order.
                if (!elem.is('.icon') && elem.parents('.toolbar').length && !elem.parents().hasClass('masthead')) {
                  return;
                }

                invokeWithInlineOptions(this, plugin);
              });
            }

            // Radio switch
            matchedItems('.radio-section input:radio.handle').change(function() {
              if (this.checked) {
                var option = $(this).closest('.option'),
                siblings = option.siblings(),
                fields = 'button, select, input[type="text"]';

                $(fields, option).removeAttr('disabled');
                $(fields, siblings).attr('disabled','disabled');
              }
            });
          }

          // Mobile Zoom Control
          // Needs manual invokation because the rest of initialization is scoped to the
          // calling element, which is the <body> tag.
          if ($.fn.zoom) {
            $('head').zoom();
          }

          // Application Menu
          if ($.fn.applicationmenu) {
            matchedItems('#application-menu').applicationmenu({
              triggers: elem.find('.application-menu-trigger')
            });
          }

          // Personalization
          if ($.fn.personalize) {
            matchedItems('body').personalize();
          }

          //Array of plugin names and selectors (optional) for no-configuration initializations
          var simplePluginMappings = [
            // Icons
            ['icon'],

            ['splitter'],

            //Tabs
            ['tabs', '.tab-container:not(.vertical)'],

            //Vertical Tabs
            ['verticaltabs', '.tab-container.vertical'],

            //Select / DropDowns
            ['dropdown', 'select.dropdown:not(.multiselect)'],
            ['dropdown', 'select.dropdown-xs:not(.multiselect)'],
            ['dropdown', 'select.dropdown-sm:not(.multiselect)'],
            ['dropdown', 'select.dropdown-lg:not(.multiselect)'],

            //Modals
            ['modal'],

            //Sliders
            ['slider', 'input[type="range"], .slider'],

            //Editors
            ['editor'],

            //Tooltips
            ['tooltip', '[title]'],

            //Tree
            ['tree'],

            //Rating
            ['rating'],

            //Listbuilder
            ['listbuilder'],

            //Composite Form Wrapper
            ['compositeform', '.composite-form'],

            //Progress
            ['progress', '.progress-bar'],

            //Format
            ['mask', 'input[data-mask]'],

            //Auto Complete
            ['autocomplete', '.autocomplete:not([data-init])'],

            //Multiselect
            ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'],

            //Button with Effects
            ['button', '.btn, .btn-toggle, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split, .btn-secondary-border'],

            //Hide Focus
            ['hideFocus', 'a.hide-focus, a.tick, a.hyperlink, .checkbox, .radio, .switch'],

            //Circle Pager
            ['circlepager'],

            //Track Dirty
            ['trackdirty', '[data-trackdirty="true"]'],

            //Clear x
            ['clearable', '[data-clearable="true"]'],

            //Text Area
            ['textarea', 'textarea'],

            //Spinbox
            ['spinbox'],

            //sort drag and drop
            ['arrange'],

            //Swap List
            ['swaplist'],

            //Color Picker
            ['colorpicker'],

            //Date Picker
            ['datepicker'],

            //Time Picker
            ['timepicker'],

            //Tag
            ['tag'],

            //Busy Indicator
            ['busyindicator','.busy, .busy-xs, .busy-sm'],

            ['header'],

            ['fileupload'],

            ['fileuploadadvanced', '.fileupload-advanced'],

            ['about'],

            ['contextualactionpanel', '.contextual-action-panel-trigger'],

            ['expandablearea', '.expandable-area'],

            ['signin'],

            ['homepage'],

            ['lookup', '.lookup:not([data-init])'],

            ['wizard'],

            ['popdown', '[data-popdown]']
          ];

          //Do initialization for all the simple controls
          for(var i = 0; i < simplePluginMappings.length; i++) {
            simpleInit.apply(null, simplePluginMappings[i]);
          }

          if ($.fn.popupmenu) {
            // Don't double-invoke menu buttons
            var btnExcludes = ', .btn-actions, .btn-filter, .btn-menu';

            //Context Menus
            matchedItems('[data-popupmenu]:not('+ noinitExcludes + btnExcludes + ')').each(function () {
              var triggerButton = $(this),
                options = $.extend({}, $.fn.parseOptions(this)),
                popupData = triggerButton.attr('data-popupmenu');

              if (popupData) {
                options.menuId = popupData;
              }

              triggerButton.popupmenu(options);
            });

            //Button-based Popup-Menus (Action/More Button, Menu Buttons, etc.)
            matchedItems('.btn-filter, .btn-menu, .btn-actions').filter(':not('+ noinitExcludes +')').each(function() {
              var triggerButton = $(this);

              // Don't auto-invoke Toolbar's Popupmenus.
              // Toolbar needs to completely control its contents and invoke each one manually.
              if (triggerButton.parents('.toolbar').length > 0) {
                return;
              }

              invokeWithInlineOptions(triggerButton, 'popupmenu');
            });
          }

          //Popovers
          if ($.fn.popover) {
            matchedItems('[data-popover]:not('+ noinitExcludes +')').each(function () {
              var obj = $(this),
                trigger = obj.attr('data-trigger'),
                title = obj.attr('data-title'),
                placement = obj.attr('data-placement');

              obj.popover({
                content: $('#' + obj.attr('data-popover')),
                trigger: trigger ? trigger : 'click',
                title: title ? title : undefined,
                placement: placement || 'right'
              });
            });
          }

          //Cardstack
          if ($.fn.listview) {
            matchedItems('.listview:not('+ noinitExcludes +')').each(function () {
              var cs = $(this),
                attr = cs.attr('data-dataset'),
                tmpl = cs.attr('data-tmpl'),
                options = $.fn.parseOptions(this) || {};

              options.dataset = options.dataset || attr;
              options.template = options.template || tmpl;

              if (window[options.dataset]) {
                options.dataset = window[options.dataset];
              }
              if (options.template && options.template.length) {
                options.template = $('#' + options.template).html();
              }

              cs.listview(options);
            });
          }

          // Searchfield
          // NOTE:  The Toolbar Control itself understands how to invoke internal searchfields, so they
          // are excluded from this initializer.
          if ($.fn.searchfield) {
            var searchfields = matchedItems('.searchfield:not('+ noinitExcludes +')'),
              toolbarSearchfields = searchfields.filter(function() {
                return $(this).parents('.toolbar').length;
              });
            searchfields = searchfields.not(toolbarSearchfields);

            searchfields.each(function() {
              invokeWithInlineOptions(this, 'searchfield');
            });
          }

          // Accordion
          if ($.fn.accordion) {
            matchedItems('.accordion:not('+ noinitExcludes +')').each(function() {
              var a = $(this);
              if (a.parents('.application-menu').length) {
                return;
              }

              invokeWithInlineOptions(a, 'accordion');
            });
          }

          // Toolbar
          if ($.fn.toolbar) {
            matchedItems('.toolbar:not('+ noinitExcludes +')').each(function() {
              var t = $(this);
              // Don't re-invoke toolbars that are part of the page/section headers or cap header.
              // header.js manually invokes these toolbars during its setup process.
              // However, if initialize is specifically being called on the toolbar element, then allow it to happen.
              if (t.parents('.header, .contextual-action-panel .modal-header').length && !self.element.is('.toolbar')) {
                return;
              }

              invokeWithInlineOptions(t, 'toolbar');
            });
          }

          matchedItems('[data-translate="text"]').each(function () {
            var obj = $(this);
            obj.text(Locale.translate(obj.text()));
          });

          //Toggle boxes on image list
          matchedItems('.block').on('click', function () {
            $(this).toggleClass('is-selected');
          });

          //Validation
          //Should be one of the last items to invoke
          if ($.fn.validate) {
            matchedItems('[data-validate-on="submit"]').validate();
          }

          matchedItems('.breadcrumb ol').attr('aria-label', Locale.translate('Breadcrumb'));
        });

        // NOTE: use of .triggerHandler() here causes event listeners for "initialized" to fire, but prevents the
        // "initialized" event from bubbling up the DOM.  It should be possible to initialize just the contents
        // of an element on the page without causing the entire page to re-initialize.
        this.element.triggerHandler('initialized');

        if ($.fn.validate) {
          self.element.validate();
        }

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = new Initialize(this, settings); // jshint ignore:line
    });
  };


  function Base(element) {
    this.element = $(element);
    this.url = this.getCurrentURL();

    window.Soho = window.Soho || {};

    if (!window.Soho.base) {
      $.detectBaseTag();
    }

    return this;
  }

  // Provides a global object that detects the existence of a Base Tag,
  // and provides some methods that can be used to get an accurate relative
  // URL using the base tag.
  Base.prototype = {
    getCurrentURL: function() {
      return window.location.href
        .replace(window.location.hash, '');
    },

    getBaseURL: function(hash) {
      if (hash) {
        // absolute links
        if (hash.indexOf('/') === 0) {
          return window.location.origin + hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  };

  // Setup a default function that just returns the contents of the hash,
  // if no base tag is present.
  $.getBaseURL = function(hash) {
    return hash;
  };

  // Detect the Base tag and install a global object, if necessary
  $.detectBaseTag = function detectBaseTag() {
    var base = $('base[href]');
    if (base.length) {
      window.Soho.base = new Base(base);

      // override the "getBaseURL"
      $.getBaseURL = window.Soho.base.getBaseURL.bind(window.Soho.base);
    }
  };

/**
 * Transition Support Check
 * Returns the vendor-prefixed name of the 'transition' property available by the browser.
 * If the browser doesn't support transitions, it returns null.
 * @private
 */


  window.Soho = window.Soho || {};
  window.Soho.utils = {};
  window.Soho.DOM = {};

  // Used for changing the stacking order of jQuery events.  This is needed to override certain
  // Events invoked by other plugins http://stackoverflow.com/questions/2360655
  $.fn.bindFirst = function(name, fn) {
    this.on(name, fn);
    this.each(function() {
        var handlers = $._data(this, 'events')[name.split('.')[0]];
        // take out the handler we just inserted from the end
        var handler = handlers.pop();
        // move it at the beginning
        handlers.splice(0, 0, handler);
    });
  };

  function visible(element) {
    return $.expr.filters.visible( element ) &&
      !$(element).parents().addBack().filter(function() {
        return $.css(this, 'visibility') === 'hidden';
      }).length;
  }

  //Get a unique ID
  window.Soho.uniqueIdCount = 0;
  $.fn.uniqueId = function(className, prefix, suffix) {
    var predefinedId = $(this).attr('id');

    if (predefinedId && $('#' + predefinedId).length < 2) {
      return predefinedId;
    }

    prefix = (!prefix ? '' : prefix + '-');
    suffix = (!suffix ? '' : '-' + suffix);
    className = (!className ? $(this).attr('class') : className);

    var str = prefix + className + Soho.uniqueIdCount + suffix;
    Soho.uniqueIdCount = Soho.uniqueIdCount + 1;
    return str;
  };

  // Check for CSS Property Support in a cross browser way
  $.fn.cssPropSupport = function(prop) {
    'use strict';

    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0],
      propStr = prop.toString(),
      prefixes = ['Moz', 'Webkit', 'O', 'ms'],
      prop_ = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };

  // Returns the name of the TransitionEnd event.
  $.fn.transitionEndName = function() {
    var prop = $.fn.cssPropSupport('transition'),
      eventNames = {
        'WebkitTransition' :'webkitTransitionEnd',
        'MozTransition'    :'transitionend',
        'MSTransition'     :'msTransitionEnd',
        'OTransition'      :'oTransitionEnd',
        'transition'       :'transitionend'
      };

    return eventNames[prop] || null;
  };

  // From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
  // Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
  // Adds the ':focusable' selector to Sizzle to allow for the selection of elements that can currently be focused.
  function focusable(element) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase(),
      isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }

    return (/input|select|textarea|button|object/.test(nodeName) ?
      !element.disabled :
      'a' === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible( element );
  }

  $.extend($.expr[':'], {
    focusable: function(element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });

  // Custom Touch Event Handler that simply passes Touch Event Handlers onto a Click Event Handler.
  // Used for avoiding the 300ms wait time that click events have in most mobile environments
  // if 'one' is defined, it only listens once.
  $.fn.onTouchClick = function(eventNamespace, filter, one) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      var self = $(this),
        listener = one ? 'one' : 'on',
        threshold = 10,
        thresholdReached = false,
        pos;

     self[listener]('touchstart' + eventNamespace, filter, function handleMove(e) {
        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };
      });

      self[listener]('touchmove' + eventNamespace, filter, function handleMove(e) {
        var newPos;
        newPos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };

        if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
            (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
          thresholdReached = true;
        }
      });

      self[listener]('touchend' + eventNamespace + ' touchcancel' + eventNamespace, filter, function handleTouches(e) {
        var elem = $(this);
        if (thresholdReached) {
          thresholdReached = false;
          return;
        }

        setTimeout(function(){
          thresholdReached = false;
          e.preventDefault();

          if (elem.attr('disabled')) {
            return;
          }

          elem.trigger('click');
        }, 0);

        return false;
      });

      return self;
    });
  };

  // Reverses the .onTouchClick() method and turns off a matching event listener
  $.fn.offTouchClick = function(eventNamespace, filter) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      return $(this).off('touchend' + eventNamespace + ' touchcancel' + eventNamespace + ' touchstart' + eventNamespace + ' touchmove' + eventNamespace, filter);
    });
  };

  // Returns a key/value list of currently attached event listeners
  $.fn.listEvents = function() {
    var data = {};

    this.each(function() {
      data = $._data(this, 'events');
    });

    return data;
  };

  // Implements consistent support for the placeholder attribute in browsers that do not handle it
  // ** Supports any kind of input (no issues with password) and textarea
  // ** does nothing if native support exists
  $.fn.placeholderPolyfill = function(options) {
    if (!('placeholder' in document.createElement('input'))) {
      var settings = $.extend({className: 'is-placeholder'}, options),
        setInputType = function (input, type, opt) {
          if(opt) {
            input.attr('type', type);
          }
        };
      $('[placeholder]').each(function() {
        var input = $(this),
        isPassword = input.is('input[type="password"]');
        input.removeClass(settings.className).on('focus.placeholderPolyfill, click.placeholderPolyfill', function() {
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.get(0).setSelectionRange(0, 0);
          }
        }).on('keydown.placeholderPolyfill', function() {
          setInputType(input, 'password', isPassword);
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.val('');
            input.removeClass(settings.className);
          }
        }).on('blur.placeholderPolyfill', function() {
          if (input.val() === '') {
            setInputType(input, 'text', isPassword);
            input.addClass(settings.className);
            input.val(input.attr('placeholder'));
            input.data('placeholder', true);
          } else {
            input.data('placeholder', false);
          }
        }).trigger('blur.placeholderPolyfill').parents('form').on('submit', function() {
          $('[placeholder]', this).each(function () {
            var field = $(this);
            if (field.val() === field.attr('placeholder') && field.data('placeholder')) {
              field.val('');
            }
          });
        });
      });
    }
   return this;
  };

  // Parse options from attribute and return obj
  $.fn.parseOptions = function(element, attr) {
    var options;

    attr = attr || 'data-options'; //default
    options = $(element).attr(attr);

    if (options && options.length) {
      if (options.indexOf('{') > -1) {
        try {
          options = JSON.parse(options.replace(/'/g, '"'));
        } catch(err) {
          // Attempt a manual parse
          var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; //get keys
          options = options.replace(regex, '$1\"$2\":'); //add double quotes to keys
          regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; //get strings in values
          options = options.replace(regex, ':\"$2\"'); //add double quotes to strings in values
          options = JSON.parse(options.replace(/'/g, '"')); //replace single to double quotes
        }
      }
    }

    if (!options) {
      options = {};
    }

    return options;
  };

  // Timer - can be use for play/pause or stop for given time
  // use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
  // then can be listen events as [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
  // or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
  $.fn.timer = function(callback, delay) {
    var self = $(this),
      interval,
      speed = 10,
      counter = 0,
      cancel = function() {
        self.triggerHandler('cancel');
        clearInterval(interval);
        counter = 0;
      },
      pause = function() {
        self.triggerHandler('pause');
        clearInterval(interval);
      },
      update = function() {
        interval = setInterval(function() {
          counter += speed;
          self.triggerHandler('update', [{'counter': counter}]);
          if (counter > delay) {
            self.triggerHandler('timeout');
            callback.apply(arguments);
            clearInterval(interval);
            counter = 0;
          }
        }, speed);
      },
      resume = function() {
        self.triggerHandler('resume');
        update();
      };

      update();
    return { event: this, cancel: cancel, pause: pause, resume: resume };
  };

  // Copies a string to the clipboard. Must be called from within an event handler such as click.
  // May return false if it failed, but this is not always
  // possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
  // No Safari support, as of (Nov. 2015). Returns false.
  // IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
  // shown the first time the clipboard is used (per session).
  $.copyToClipboard = function(text) {
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    }
    else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      }
      catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      }
      finally {
        document.body.removeChild(textarea);
      }
    }
  };

  //Functions For Sanitising and Escaping Html
  $.escapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&/g, '&amp;');
      newValue = newValue.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    return newValue;
  };

  $.unescapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
      newValue = newValue.replace(/&amp;/g, '&');
    }
    return newValue;
  };

  //Remove Script tags and all onXXX functions
  $.sanitizeHTML = function(html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
     santizedHtml = santizedHtml.replace(/on\w+="[^"]*"/g, '');
     santizedHtml = santizedHtml.replace(/ on\w+='[^']*'/g, '');

    return santizedHtml;
  };

  //Hide Focus - Only show on key entry
  $.fn.hideFocus = function() {
    var element = $(this),
      label = element.next(),
      isClick = false,
      isFocused = false,
      labelClicked = false;

    // Checkbox, Radio buttons or Switch
    if (element.is('.checkbox, .radio, .switch')) {
      if (label.is('[type="hidden"]')) {
        label = label.next();
      }
      element.addClass('hide-focus')
        .on('focusin.hide-focus', function() {
          if (!isClick && !isFocused && !labelClicked) {
            element.removeClass('hide-focus');
          }
          isClick = false;
          isFocused = true;
          labelClicked = false;
        })
        .on('focusout.hide-focus', function() {
          element.addClass('hide-focus');
          labelClicked = label.is(labelClicked);
          isClick = false;
          isFocused = false;
        });

      label.on('mousedown.hide-focus', function() {
        labelClicked = this;
        isClick = true;
        element.addClass('hide-focus');
      });
    }

    // All other elements (ie. Hyperlinks)
    else {
      element.addClass('hide-focus')
        .on('mousedown.hide-focus touchstart.hide-focus', function() {
          isClick = true;
          element.addClass('hide-focus');
        })
        .on('focusin.hide-focus', function() {
          if (!isClick && !isFocused) {
            element.removeClass('hide-focus');
          }
          isClick = false;
          isFocused = true;
        })
        .on('focusout.hide-focus', function() {
          element.addClass('hide-focus');
          isClick = false;
          isFocused = false;
        });
    }
  };

  //Clearable (Shows an X to clear)
  $.fn.clearable = function() {
    var self = this;
    this.element = $(this);

    //Create an X icon button styles in icons.scss
    this.xButton = $.createIconElement({ classes: 'close is-empty', icon: 'close' }).icon();

    //Create a function
    this.checkContents = function () {
      var text = self.element.val();
      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    };

    //Add the button to field parent
    self.element.parent().append(this.xButton);

    //Handle Events
    this.xButton.offTouchClick('clearable').off()
      .onTouchClick('clearable', '.clearable')
      .on('click.clearable', function handleClear() {
        self.element.val('').trigger('change').focus().trigger('cleared');
        self.checkContents();
      });

    this.element.on('change.clearable, blur.clearable, keyup.clearable', function () {
      self.checkContents();
    });

    //Set initial state
    this.checkContents();
  };

  // Replacement for String.fromCharCode() that takes meta keys into account when determining which
  // character key was pressed.
  $.actualChar = function(e) {
      var key = e.which,
        character = '',
        toAscii = {
          '188': '44',
          //'109': '45', // changes "m" to "-" when using keypress
          '190': '46',
          '191': '47',
          '192': '96',
          '220': '92',
          '222': '39',
          '221': '93',
          '219': '91',
          '173': '45',
          '187': '61', //IE Key codes
          '186': '59', //IE Key codes
          '189': '45'  //IE Key codes
        },
        shiftUps = {
          '96': '~',
          '49': '!',
          '50': '@',
          '51': '#',
          '52': '$',
          '53': '%',
          '54': '^',
          '55': '&',
          '56': '*',
          '57': '(',
          '48': ')',
          '45': '_',
          '61': '+',
          '91': '{',
          '93': '}',
          '92': '|',
          '59': ':',
          '37': '%',
          '38': '&',
          '39': '\"',
          '44': '<',
          '46': '>',
          '47': '?'
        };

      // Normalize weird keycodes
      if (toAscii.hasOwnProperty(key)) {
        key = toAscii[key];
      }

      // Convert Keycode to Character String
      if (!e.shiftKey && (key >= 65 && key <= 90)) {
        character = String.fromCharCode(key + 32);
      } else if (e.shiftKey && shiftUps.hasOwnProperty(key)) { // User was pressing Shift + any key
        character = shiftUps[key];
      } else {
        character = String.fromCharCode(key);
      }

      return character;
  };

  window.Soho.utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };

  // Returns an array containing an element's attributes.
  window.Soho.DOM.getAttributes = function getAttributes(element) {
    if (!element || (!(element instanceof HTMLElement) && !(element instanceof SVGElement))) {
      return;
    }

    return element.attributes;
  };

  //Adding, removing, and testing for classes
  window.Soho.DOM.classNameExists = function classNameExists(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };

  window.Soho.DOM.classNameHas = function has(classNameString, targetContents) {
    return classNameString.indexOf(targetContents) > -1;
  };

  window.Soho.DOM.hasClass = function hasClass (el, className) {
    return el.classList ? el.classList.contains(className) : new RegExp('\\b'+ className+'\\b').test(el.className);
	};

  window.Soho.DOM.addClass = function addClass(el, className) {
     if (el.classList) {
      el.classList.add(className);
    } else if (!window.Soho.DOM.hasClass(el, className)) {
      el.className += ' ' + className;
    }
  };

  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being checked
   * @returns {boolean} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.isElement = function isElement(el) {
    if ((el instanceof HTMLElement) || (el instanceof SVGElement) || (el instanceof $ && el.length)) {
      return true;
    }
    return false;
  };

  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated
   * @returns {object} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.getDimensions = function getDimensions(el) {
    if (!Soho.DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect(),
      rectObj = {};
    for (var prop in rect) {
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }
    return rectObj;
  };

  // Debounce method
  window.Soho.utils.debounce = function(func, threshold, execAsap) {
    var timeout;

    return function debounced () {
      var obj = this, args = arguments;
      function delayed () {
        if (!execAsap) {
          func.apply(obj, args);
        }
        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 100);
    };
  };

  // Debounced Resize method
  // https://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/
  (function($,sr){
    // smartresize
    $.fn[sr] = function(fn){  return fn ? this.bind('resize', Soho.utils.debounce(fn)) : this.trigger(sr); };
  })($, 'debouncedResize');

  // String parsing utils
  window.Soho.string = {};

  /**
   * The splice() method changes the content of a string by removing a range of
   * characters and/or adding new characters.
   *
   * @param {String} str The string that will be manipulated.
   * @param {number} start Index at which to start changing the string.
   * @param {number} delCount An integer indicating the number of old chars to remove.
   * @param {string} newSubStr The String that is spliced in.
   * @return {string} A new string with the spliced substring.
   */
  window.Soho.string.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };

  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @return {undefined}
   */
  window.Soho.utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Soho.env.browser.name !== 'ie' && Soho.env.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      rootElement = rootElement[0];
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');
      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttribute('xlink:href');
        uses[i].setAttribute('xlink:href', 'x');
        uses[i].setAttribute('xlink:href', attr);
      }
    }, 1);
  };

  /**
   * Gets the current size of the viewport
   * @returns {object}
   */
  window.Soho.utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns their scrollHeight and scrollLeft values.
   * @returns {object[]}
   */
  window.Soho.utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!Soho.DOM.isElement(element)) {
      return [];
    }

    var containers = [],
      scrollableElements = [
        '.scrollable', '.scrollable-x', '.scrollable-y', '.modal',
        '.card-content', '.widget-content', '.tab-panel',
        '.datagrid-content'
      ];

    $(element).parents(scrollableElements.join(', ')).each(function() {
      var el = this;

      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    });

    // Push the body's scroll area if it's not a "no-scroll" area
    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };

  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;") and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {object} options - incoming options.
   * @param {jQuery[]} [parentElement=undefined] - the parent element where a clone of this hidden element will be attached.
   * @returns {object}
   */
  window.Soho.utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults = {
      dims: { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
      parentElement: undefined,
      includeMargin: false
    };

    if (!Soho.DOM.isElement(el)) {
      return defaults.dims;
    }

    el = $(el);
    options = $.extend({}, defaults, options);

    // element becomes clone and appended to a parentElement, if defined
    var hasDefinedParentElement = Soho.DOM.isElement(options.parentElement);
    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims,
      hiddenParents = el.parents().add(el),
      props = {
        transition: 'none',
        webkitTransition: 'none',
        mozTransition: 'none',
        msTransition: 'none',
        visibility: 'hidden',
        display: 'block',
      },
      oldProps = [];

    hiddenParents.each(function () {
      var old = {};

      for (var name in props) {
        if (this.style[name]) {
          old[name] = this.style[name];
          this.style[name] = props[name];
        }
      }

      oldProps.push(old);
    });

    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;

    hiddenParents.each(function (i) {
      var old = oldProps[i];
      for (var name in props) {
        if (old[name]) {
          this.style[name] = old[name];
        }
      }
    });

    // element is ONLY removed when a parentElement is defined because it was cloned.
    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };

  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @param {object} options - incoming options
   * @returns {object}
   */
  $.fn.getHiddenSize = function(options) {
    return window.Soho.utils.getHiddenSize(this, options);
  };

  //==================================================================
  // Simple Behaviors
  //==================================================================
  window.Soho.behaviors = {};

  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {Number} target - target distance.
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  window.Soho.behaviors.smoothScrollTo = function(el, target, duration) {
    var dfd = $.Deferred();

    if (!Soho.DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    }

    // Strip the jQuery
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    // undefined (not zero) target should instantly resolve
    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft = el.scrollLeft + target;
      return dfd.resolve();
    }

    var startTime = Date.now(),
      endTime = startTime + duration,
      startLeft = el.scrollLeft,
      distance = target /*- startLeft*/;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    function smoothStep(start, end, point) {
      if (point <= start) { return 0; }
      if (point >= end) { return 1; }
      var x = (point - start) / (end - start); // interpolation
      return x*x*(3 - 2*x);
    }

    // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing
    var previousLeft = el.scrollLeft;

    // This is like a think function from a game loop
    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      }

      // set the scrollLeft for this frame
      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + (distance * point));
      el.scrollLeft = frameLeft;

      // check if we're done!
      if (now >= endTime) {
        dfd.resolve();
        return;
      }

      // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.
      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }
      previousLeft = el.scrollLeft;

      // schedule next frame for execution
      setTimeout(scrollFrame, 0);
    }

    // boostrap the animation process
    setTimeout(scrollFrame, 0);

    return dfd;
  };

  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {Number} target - target distance to scroll the element
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  $.fn.smoothScroll = function(target, duration) {
    return window.Soho.behaviors.smoothScrollTo(this, target, duration);
  };

  //==================================================================
  // JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  //==================================================================
  window.Soho.breakpoints = {
    'phone': 320,
    'slim': 400,
    'phablet': 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    'desktop-to-extralarge': 1600
  };

  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp;
  };

  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };


// Page Bootstrapper


  var environment = {

    // Setup a global resize event trigger for controls to listen to
    addGlobalResize: function() {
      $(window).debouncedResize(function() {
        $('body').triggerHandler('resize', [window]);
      });

      return this;
    },

    set: function () {
      this
        .makeSohoObject()
        .addBrowserClasses()
        .addGlobalResize();
    },

    // Global Classes for browser, version and device as needed.
    addBrowserClasses: function() {
      var ua = navigator.userAgent || navigator.vendor || window.opera,
        html = $('html'),
        cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari')  !== -1 &&
          ua.indexOf('Chrome')  === -1 &&
          ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        Soho.env.browser.name = 'safari';
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        Soho.env.browser.name = 'chrome';
      }

      if (ua.indexOf('Mac OS X') !== -1) {
        cssClasses += 'is-mac ';
        Soho.env.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        Soho.env.browser.name = 'firefox';
      }

      //Class-based detection for IE
      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        Soho.env.browser.name = 'edge';
      }
      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        Soho.env.browser.name = 'ie';
      }
      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 ||
        ua.indexOf('MSIE 8.0') > -1 ||
        document.documentMode === 8) {
        cssClasses += 'ie8 ';
        Soho.env.browser.version = '8';
      }
      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        Soho.env.browser.version = '9';
      }
      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        Soho.env.browser.version = '10';
      } else {
        if (ua.match(/Trident\/7\./)) {
          cssClasses += 'ie11 ';
          Soho.env.browser.version = '11';
        }
      }

      // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/
      if ((/iPhone|iPod|iPad/).test(ua)) {
        cssClasses += 'ios ';
        Soho.env.os.name = 'ios';

        var iDevices = ['iPod', 'iPad', 'iPhone'];
        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += iDevices[i].toLowerCase() + ' ';
            Soho.env.device = iDevices[i];
          }
        }
      }

      if ((/Android/.test(ua))) {
        cssClasses += 'android ';
        Soho.env.os.name = 'android';
      }

      html.addClass(cssClasses);

      return this;
    },

    makeSohoObject: function() {
      window.Soho = window.Soho || {};

      window.Soho.logTimeStart = function(label) {
        if (window.Soho.logTime) {
          console.time(label); // jshint ignore:line
        }
      };

      window.Soho.logTimeEnd = function(label) {
        if (window.Soho.logTime) {
          console.timeEnd(label); // jshint ignore:line
        }
      };

      // Environment object provides JS-friendly way to figure out our browser support
      window.Soho.env = {
        browser: {},
        os: {}
      };

      // Get the name of the paste event.  Could be "paste" or "input" based on the browser.
      window.Soho.env.pasteEvent = (function getPasteEvent() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input');
      })();

      window.Soho.theme = 'light';

      return this;
    }

  };

  environment.set();
// Height Animation Controls
// Adapted from: http://n12v.com/css-transition-to-from-auto/
// Contains a handful of animation helper methods that attempt to DRY up CSS-powered sliding animations.


  // Use CSS Transitions to animate from "0" to "auto" widths
  $.fn.animateOpen = function(options) {
    'use strict';

    // Settings and Options
    var defaults = {
        direction: 'vertical', // Can also be 'horizontal'
        distance: 'auto', // Distance in pixels that the animation covers.  'auto', or pixel value size
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)' // CSS Transition Timing Function
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        distance = !isNaN(settings.distance) ? parseInt(settings.distance, 10) + 'px' : 'auto',
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animateopen');
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateopenstart.animation', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animateopen');
      });
      $self.trigger('animateopenstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animateopen', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal;
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal;

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Use CSS Transitions to animate from "auto" to "0" widths
  $.fn.animateClosed = function(options) {

    // Settings and Options
    var defaults = {
        direction: 'vertical', // can also be 'horizontal'
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)'
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animatedclosed');
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateclosedstart', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animatedclosed');
      });
      $self.trigger('animateclosedstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animatedclosed', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim];
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px';

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Chainable jQuery plugin that checks if an element is in the process of animating
  $.fn.isAnimating = function() {
    return this.each(function() {
      return $(this).data('is-animating') === true;
    });
  };

// Localization Routines
// Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
// For Docs See: http://ibm.co/1nXyNxp


  //If there already exists a Locale object with a culturesPath use that path
  //This allows manually setting the directory for the culture files to be retrieved from
  var existingCulturePath = '';

  if (window.Locale && window.Locale.hasOwnProperty('culturesPath')) {
    existingCulturePath = window.Locale.culturesPath;
  }

  /**
  * The Locale component handles i18n
  *
  * @class Locale
  * @param {String} currentLocale  &nbsp;-&nbsp; The Currently Set Locale
  *
  */
  window.Locale = {

    currentLocale:  {name: '', data: {}}, //default
    cultures: {},
    culturesPath: existingCulturePath,

    //Sets the Lang in the Html Header
    updateLang: function () {
      var html = $('html');

      html.attr('lang', this.currentLocale.name);
      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      }
    },

    //Get the path to the directory with the cultures
    getCulturesPath: function() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script'),
          partialPathMin = 'sohoxi.min.js',
          partialPath = 'sohoxi.js';

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          //remove from ? to end
          var idx = src.indexOf('?');
          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return src.substring(0, src.lastIndexOf('/')) + '/';
          }

          if (src.indexOf(partialPathMin) > -1) {
            this.culturesPath = src.replace(partialPathMin, '') + 'cultures/';
          }
          if (src.indexOf(partialPath) > -1) {
            this.culturesPath = src.replace(partialPath, '') + 'cultures/';
          }


        }
      }
      return this.culturesPath;
    },

    cultureInHead: function() {
      var isThere = false,
        scripts = document.getElementsByTagName('script'),
        partialPath = 'cultures';


        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          if (src.indexOf(partialPath) > -1) {
            isThere = true;
          }
        }

      return isThere;
    },

    addCulture: function(locale, data) {
      this.cultures[locale] = data;
    },

    /**
    * Set the currently used colors.
    *
    * @param {String} locale  &nbsp;-&nbsp; The locale to fetch and set.
    */
    set: function (locale) {

      var self = this;
      this.dff = $.Deferred();

      //Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }
      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.setCurrentLocale(locale);

        //fetch the local and cache it
        $.ajax({
          url: this.getCulturesPath() + this.currentLocale.name + '.js',
          dataType: 'script',
          error: function () {
            self.dff.reject();
          }
        }).done(function () {
          self.setCurrentLocale(locale, self.cultures[locale]);
          self.addCulture(locale, self.currentLocale.data);
          self.dff.resolve(self.currentLocale.name);
        });
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        //fetch the english local and cache it from translation defaults
        $.ajax({
          url: this.getCulturesPath() + 'en-US.js',
          dataType: 'script',
          error: function () {
            self.dff.reject();
          }
        }).done(function () {
          self.addCulture(locale, self.currentLocale.data);
        });
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff.resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff.resolve(self.currentLocale.name);
      }
      return this.dff.promise();
    },

    setCurrentLocale: function(name, data) {
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
      }
      this.updateLang();
    },

    /**
    * Format a Date Object and return it parsed in the current locale.
    *
    * @param {Date} value  &nbsp;-&nbsp; The date to show in the current locale.
    * @param {Object} attribs  &nbsp;-&nbsp; Additional formatting settings.
    */
    formatDate: function(value, attribs) {

      //We will use http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
      if (!attribs) {
        attribs = {date: 'short'};  //can be date, time, datetime or pattern
      }

      if (!value) {
        return undefined;
      }

      //Convert if a string..
      if (!(value instanceof Date)) {
        var tDate = new Date(value);
        if (isNaN(tDate) && attribs.date === 'datetime' &&
          value.substr(4, 1) === '-' &&
          value.substr(7, 1) === '-') {
          tDate = new Date(
            value.substr(0, 4),
            value.substr(5, 2) - 1,
            value.substr(8, 2),
            value.substr(11, 2),
            value.substr(14, 2),
            value.substr(17, 2)
          );
        }
        value = tDate;
      }

      // TODO: Can we handle this if (this.dff.state()==='pending')
       var data = this.currentLocale.data,
        pattern, ret = '', cal = (data.calendars ? data.calendars[0] : null);

      if (attribs.pattern) {
        pattern = attribs.pattern;
      }

      if (attribs.date) {
        pattern = cal.dateFormat[attribs.date];
      }

      var day = value.getDate(), month = value.getMonth(), year = value.getFullYear(),
        mins = value.getMinutes(), hours = value.getHours(), seconds = value.getSeconds();

      //Special
      pattern = pattern.replace('ngày','nnnn');
      pattern = pattern.replace('tháng','t1áng');
      pattern = pattern.replace('den','nnn');

      //Day of Month
      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day);

      //years
      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year);

      //Time
      var showDayPeriods = ret.indexOf(' a') > -1;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', (hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2)));
      ret = ret.replace('h', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(value.getMilliseconds(), 0));

      //months
      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null);  //full
      ret = ret.replace('MMM',  cal ? cal.months.abbreviated[month] : null);  //abreviation
      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month+1, 2));  //number padded
        ret = ret.replace('M', month+1);                //number unpadded
      }

      //PM
      if (cal) {
        ret = ret.replace(' a', ' '+ (hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }

      //Day of Week
      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }
      ret = ret.replace('nnnn','ngày');
      ret = ret.replace('t1áng','tháng');
      ret = ret.replace('nnn','den');

      return ret.trim();
    },

    /**
    * Check if the date is valid using the current locale to do so.
    *
    * @param {Date} value  &nbsp;-&nbsp; The date to show in the current locale.
    */
    isValidDate: function (date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {  // d.valueOf() could also work
          return false;
        } else {
          return true;
        }
      } else {
        return false;
      }
    },

    /**
    * Take a date string written in the current locale and parse it into a Date Object
    *
    * @param {String} dateString  &nbsp;-&nbsp; The string to parse in the current format
    * @param {String} dateFormat  &nbsp;-&nbsp; The source format fx yyyy-MM-dd
    * @param {Boolean} isStrict  &nbsp;-&nbsp; If true missing date parts will be considered invalid. If false the current month/day.
    */
    parseDate: function(dateString, dateFormat, isStrict) {
      var thisLocaleCalendar = this.calendar(),
        orgDatestring = dateString;

      if (!dateString) {
        return undefined;
      }

      if (!dateFormat) {
        dateFormat = this.calendar().dateFormat.short;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      if (typeof dateFormat === 'object' && dateFormat.date)  {
        dateFormat = this.calendar().dateFormat[dateFormat.date];
      }

      var formatParts,
        dateStringParts,
        dateObj = {},
        isDateTime = (dateFormat.toLowerCase().indexOf('h') > -1),
		isUTC = (dateString.toLowerCase().indexOf('z') > -1),
        i, l;

      if (isDateTime) {
        //replace [space & colon & dot] with "/"
        dateFormat = dateFormat.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
        dateString = dateString.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
      }

      if (dateFormat === 'Mdyyyy' || dateFormat === 'dMyyyy') {
        dateString = dateString.substr(0, dateString.length - 4) + '/' + dateString.substr(dateString.length - 4, dateString.length);
        dateString = dateString.substr(0, dateString.indexOf('/')/2) + '/' + dateString.substr(dateString.indexOf('/')/2);
      }

      if (dateFormat === 'Mdyyyy') {
        dateFormat = 'M/d/yyyy';
      }

      if (dateFormat === 'dMyyyy') {
        dateFormat = 'd/M/yyyy';
      }

      if (dateFormat.indexOf(' ') !== -1 ) {
        dateFormat = dateFormat.replace(/[\s:.]/g,'/');
        dateString = dateString.replace(/[\s:.]/g,'/');
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1  && dateFormat.indexOf('/')  === -1 && dateFormat.indexOf('-')  === -1) {
        var lastChar = dateFormat[0],
          newFormat = '', newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newFormat +=  (dateFormat[i] !== lastChar ? '/' + dateFormat[i]  : dateFormat[i]);
          newDateString += (dateFormat[i] !== lastChar ? '/' + dateString[i]  : dateString[i]);

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      }

      // Check the incoming date string's parts to make sure the values are valid against the localized
      // Date pattern.
      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM'),
        year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy'),
        hasDays = false;

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = formatParts[i] + '',
          value = dateStringParts[i],
          numberValue = parseInt(value);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        switch(pattern) {
          case 'd':
            var lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return;
            }
            dateObj.day = value;
            break;
          case 'dd':
            if ((numberValue < 1 || numberValue > 31) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.day = value;
            break;
          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MM':
            if ((numberValue < 1 || numberValue > 12) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MMM':
              var abrMonth = this.calendar().months.abbreviated;

              for (var len = 0; len < abrMonth.length; len++) {
                if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                  dateObj.month = len;
                }
              }

              break;
          case 'MMMM':
            var textMonths = this.calendar().months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;
          case 'yy':
            dateObj.year = parseInt('20'+value, 10);
            break;
          case 'yyyy':
            dateObj.year = value;
            break;
          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return;
            }
            dateObj.h = value;
            break;
          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return;
            }
            dateObj.h = value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }
            dateObj.ss = value;
            break;

	      case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }
            dateObj.mm = value;
            break;

          case 'a':
            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[0]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[0])) {
              dateObj.a = 'AM';

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[1]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[1])) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h) + 12;
                }
              }
            }
            break;
        }
      }

      dateObj.return = undefined;
      dateObj.leapYear = ((dateObj.year % 4 === 0) && (dateObj.year % 100 !== 0)) || (dateObj.year % 400 === 0);

      if ((isDateTime && !dateObj.h && !dateObj.mm)) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }
        if (dateObj.isUndefindedYear) {
          dateObj.year = (new Date()).getFullYear();
        } else {
          delete dateObj.year;
        }
      }

      //Fix incomelete 2 and 3 digit years
      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = '20' + dateObj.year;
      }

      // TODO: Need to find solution for three digit year
      // http://jira/browse/SOHO-4691
      // if (dateObj.year && dateObj.year.length === 3) {
      //   dateObj.year = '2' + dateObj.year;
      // }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || (dateObj.year && !((dateObj.year + '').length === 2 || (dateObj.year + '').length === 4))) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }
        if (dateObj.isUndefindedMonth) {
          dateObj.month = (new Date()).getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }
        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm));
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss));
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms));
          }
        }
        else
        {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm);
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss);
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms);
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      return (this.isValidDate(dateObj.return) ? dateObj.return : undefined);

    },

    getDatePart: function (formatParts, dateStringParts, filter1, filter2, filter3) {
      var ret = 0;

      $.each(dateStringParts, function(i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });

      return ret;
    },

    /**
    * Format a decimal with thousands and padding in the current locale.
    * http://mzl.la/1MUOEWm
    *
    * @param {Number} number  &nbsp;-&nbsp; The source number.
    * @param {Boolean} options  &nbsp;-&nbsp; Additional options.style can be decimal, currency, percent and integer options.percentSign, options.minusSign, options.decimal, options.group options.minimumFractionDigits (0), options.maximumFractionDigits (3)
    */
    formatNumber: function(number, options) {
      //Lookup , decimals, decimalSep, thousandsSep
      var formattedNum, curFormat, percentFormat,
        decimal = options && options.decimal ? options.decimal : this.numbers().decimal,
        group = options && options.group !== undefined ? options.group : this.numbers().group,
        minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : (options && options.style && options.style === 'currency' ? 2 : (options && options.style && options.style === 'percent') ? 0 : 2),
        maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : (options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : (options && options.minimumFractionDigits ? options.minimumFractionDigits : 3));

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      //TODO: Doc Note: Uses Truncation
      if (options && options.style === 'currency') {
        var sign = this.currentLocale.data.currencySign;

        curFormat = this.currentLocale.data.currencyFormat;
        curFormat = curFormat.replace('¤', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = this.currentLocale.data.numbers.percentSign;

        percentFormat = this.currentLocale.data.numbers.percentFormat;
        percentFormat = percentFormat.replace('¤', percentSign);
      }

      if (typeof number === 'string') {

        if (decimal !== '.') {
          number = number.replace(decimal, '.');
        }
        number = Locale.parseNumber(number);
      }

      if (options && options.style === 'percent') {
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, group);
      formattedNum = parts.join(decimal);

      if (minimumFractionDigits === 0) { //Not default
        formattedNum = formattedNum.replace(/(\.[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits === 0 && decimal !== '.') { //Not default
        formattedNum = formattedNum.replace(/(\,[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\,$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits > 0) {
        var expr = new RegExp('(\\..{' + minimumFractionDigits+ '}[0-9]*?)0+$');
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');  // remove trailing dot
      }

      //Confirm Logic After All Locales are added.
      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('#,##0.00', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('#,##0', formattedNum);
      }

      return formattedNum;
    },

    decimalPlaces: function(number) {
      var result= /^-?[0-9]+\.([0-9]+)$/.exec(number);
      return result === null ? 0 : result[1].length;
    },

    truncateDecimals: function (number, minDigits, maxDigits, round) {
      var multiplier = Math.pow(10, maxDigits),
        adjustedNum = number * multiplier,
        truncatedNum;

      //Round Decimals
      var decimals = this.decimalPlaces(number);

      //Handle larger numbers
      if (number.toString().length - decimals - 1 >= 10 ||
        (decimals === minDigits && decimals === maxDigits) || (decimals < maxDigits)) {
        multiplier = Math.pow(100, maxDigits);
        adjustedNum = number * multiplier;
      }

      truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

      if (round && decimals >= maxDigits && adjustedNum > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (round && decimals <= maxDigits && decimals > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (decimals < maxDigits && decimals > 0) {
        truncatedNum = Math.floor(adjustedNum);
        maxDigits = Math.max(decimals, minDigits);
      }

      return (truncatedNum / multiplier).toFixed(maxDigits);
    },

    /**
    * Take a Formatted Number and return a real number
    *
    * @param {String} input  &nbsp;-&nbsp; The source number (as a string).
    *
    */
    parseNumber: function(input) {
      var numSettings = this.currentLocale.data.numbers,
        numString, group, decimal, percentSign, currencySign;

      numString = input;

      if (!numString) {
        return NaN;
      }

      group = numSettings ? numSettings.group  : ',';
      decimal = numSettings ? numSettings.decimal  : '.';
      percentSign = numSettings ? numSettings.percentSign  : '%';
      currencySign = currencySign ? this.currentLocale.data.currencySign  : '$';

      numString = numString.replace(new RegExp('\\' + group, 'g'), '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace(' ', '');

      return parseFloat(numString);
    },

    /**
    * Overridable culture messages
    *
    * @param {String} key  &nbsp;-&nbsp; The key to search for on the string.
    *
    */
    translate: function(key) {
      if (this.currentLocale.data === undefined || this.currentLocale.data.messages === undefined) {
        return key;
      }

      if (this.currentLocale.data.messages[key] === undefined) {
        // Substitue English Expression if missing
        if (!this.cultures['en-US'] || this.cultures['en-US'].messages[key] === undefined) {
          return undefined;
        }
        return this.cultures['en-US'].messages[key].value;
      }

      return this.currentLocale.data.messages[key].value;
    },

    // Translate Day Period
    translateDayPeriod: function(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        return Locale.calendar().dayPeriods[/AM|am/i.test(period) ? 0 : 1];
      }
      return period;
    },

    // Short cut function to get 'first' calendar
    calendar: function() {
      if (this.currentLocale.data.calendars) {
        return this.currentLocale.data.calendars[0];
      }

      //Defaults to ISO 8601
      return {dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm:ss'};
    },

    // Short cut function to get numbers
    numbers: function() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
          percentSign: '%',
          percentFormat: '#,##0 %',
          minusSign: '-',
          decimal: '.',
          group: ','
        };
    },

    pad: function(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },

    isRTL: function() {
      return this.currentLocale.data.direction === 'right-to-left';
    },

    /**
     * Takes a string and converts its contents to upper case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toUpperCase()`
     * @param {string} str - the incoming string
     */
    toUpperCase: function(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },

    /**
     * Takes a string and converts its contents to lower case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toLowerCase()`
     * @param {string} str - the incoming string
     * @returns {string}
     */
    toLowerCase: function(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toLocaleLowerCase();
    },

    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalize: function(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },

    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalizeWords: function(str) {
      var words = str.split(' ');

      for(var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },

    flipIconsHorizontally: function() {
      var icons = [
        'attach',
        'bottom-aligned',
        'bullet-list',
        'cancel',
        'cart',
        'collapse-app-tray',
        'cut',
        'document',
        'drilldown',
        'duplicate',
        'expand-app-tray',
        'export',
        'first-page',
        'folder',
        'import',
        'last-page',
        'launch',
        'left-align',
        'left-text-align',
        'left-arrow',
        'new-document',
        'next-page',
        'number-list',
        'paste',
        'previous-page',
        'quote',
        'redo',
        'refresh',
        'right-align',
        'right-arrow',
        'right-text-align',
        'save',
        'search-folder',
        'search-list',
        'search',
        'send',
        'tack',
        'tree-collapse',
        'tree-expand',
        'undo',
        'unlocked',
        'add-grid-record',
        'add-grid-row',
        'additional-help',
        'bubble',
        'cascade',
        'change-font',
        'clear-screen',
        'script',
        'clockwise-90',
        'close-cancel',
        'close-save',
        'contacts',
        'copy-from',
        'copy-mail',
        'copy-url',
        'counter-clockwise-90',
        'create-report',
        'delete-grid-record',
        'delete-grid-row',
        'display',
        'employee-directory',
        'export-2',
        'export-to-pdf',
        'generate-key',
        'get-more-rows',
        'group-selection',
        'headphones',
        'help',
        'helper-list-select',
        'history',
        'invoice-released',
        'language',
        'logout',
        'key',
        'lasso',
        'line-bar-chart',
        'line-chart',
        'new-expense-report',
        'new-payment-request',
        'new-time-sheet',
        'new-travel-plan',
        'no-attachment',
        'no-comment',
        'no-filter',
        'overlay-line',
        'pdf-file',
        'phone',
        'payment-request',
        'pie-chart',
        'queries',
        'quick-access',
        'refresh-current',
        'restore-user',
        'run-quick-access',
        'save-close',
        'save-new',
        'search-results-history',
        'select',
        'send-submit',
        'show-last-x-days',
        'special-item',
        'stacked',
        'timesheet',
        'unsubscribe',
        'update-preview',
        'zoom-100',
        'zoom-in',
        'zoom-out',
        'caret-left',
        'caret-right'
      ];

      $('svg').each(function() {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }

  };

  //Has to delay in order to check if no culture in head since scripts load async
  $(function() {
    setTimeout(function() {
      if (!window.Locale.cultureInHead() && !window.Locale.currentLocale.name) {
        window.Locale.set('en-US');
      }

      // ICONS: Right to Left Direction
      if (window.Locale.isRTL()) {
        window.Locale.flipIconsHorizontally();
      }
    }, 50);
  });



  var defaults = {
      caseSensitive: false,
      filterMode: 'startsWith',
      highlightMatchedText: false,
      highlightCallback: null
    },
    filterModes = ['startsWith', 'contains'];


  /**
  * Abstracted search/filter for use in other controls
  *
  * @class ListFilter
  * @param {Boolean} caseSensitive  &nbsp;-&nbsp; Set to true if searches ARE case sensitive
  * @param {String} filterMode  &nbsp;-&nbsp; Type of search can current be either 'startsWith' or 'contains'
  * @param {Boolean} highlightMatchedText  &nbsp;-&nbsp; Inserts markup that appears to highlight text
  * @param {Boolean} highlightCallback  &nbsp;-&nbsp; If defined, will execute this code for highlighting text instead of the built-in highlighting code
  *
  */
  function ListFilter(settings) {
    this.settings = $.extend({}, defaults, settings);
    Soho.logTimeStart('ListFilter');
    this.init();
    Soho.logTimeEnd('ListFilter');
  }

  ListFilter.prototype = {

    init: function() {
      // Sanitize Incoming Options
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [
        { setting: this.settings.filterMode, limits: filterModes, preset: defaults.filterMode }
      ];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      }

      return this;
    },

    /**
    * Run the filter on the list for the given sreach term.
    * @param {Array} list  &nbsp;-&nbsp; The array to search.
    * @param {String} term  &nbsp;-&nbsp; The term to look for.
    * @returns {Array}
    */
    filter: function(list, term) {
      if (!list) {
        return false;
      }

      // Check incoming list type
      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      }

      // Search term must exist and must not be nothing
      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this,
        items = [],
        isJQuery = false;

      // make search term lowercase if the search is not case-senstive
      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      }

      // If it's not an array, build an array of the incoming object(s) for iterating through
      if (!$.isArray(list)) {
        if (list instanceof jQuery || typeof list === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      }

      function searchItemIterator(item) {
        var isString = typeof item === 'string',
          text = (isString ? item : $(item).text()),
          parts = text.split(' '),
          match = false;

        if (self.settings.filterMode === 'startsWith') {
          for (var a = 0; a < parts.length; a++) {
            if (parts[a].toLowerCase().indexOf(term) === 0) {
              match = true;
              break;
            }
          }

          //Direct Match
          if (text.toLowerCase().indexOf(term) === 0) {
            match = true;
          }

          //Partial dual word match
          if (term.indexOf(' ') > 0 && text.toLowerCase().indexOf(term) > 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.toLowerCase().indexOf(term) >= 0) {
            match = true;
          }
        }

        if (match) {
          items.push(item);
        }

        return;
      }

      // Run the iterator
      list.forEach(searchItemIterator);

      // If we originally took in a jQuery selector, rebuild that jQuery selector with the relevant results.
      if (isJQuery) {
        items = $(items);
      }

      return items;
    },

    updated: function(settingsObj) {
      this.settings = $.extend({}, this.settings, settingsObj);
      return this
        .teardown()
        .init();
    },

    teardown: function() {
      return this;
    },

    destroy: function() {
      return this.teardown();
    }

  };

  // Add it to the Window for use
  window.ListFilter = ListFilter;


  $.fn.about = function(options) {

    // Settings and Options
    var pluginName = 'about',
        defaults = {
          appName: 'Infor Application Name',
          content: undefined,
          copyrightYear: new Date().getFullYear(),
          deviceSpecs: true,
          productName: undefined,
          useDefaultCopyright: true,
          version: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class About
    * @param {String} appName The Main Application Name to display in the header.
    * @param {String} content Additional Text content to display at the top.
    * @param {String} copyrightYear The year displayed in the copyright, defaults to current year.
    * @param {Boolean} deviceSpecs Determines whether or not to display device information (Browser, Platform, Locale, Cookies Enabled)
    * @param {String} productName Additional product name information to display.
    * @param {Boolean} useDefaultCopyright Add the Legal Approved Infor Copy Right Text.
    * @param {String} version Semantic Version Number for example (4.0.0).
    *
    */
    function About(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    About.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.isBody = $(this.element).is('body');
        var appName = this.element.attr('data-appname');
        this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;

        var content = this.element.attr('data-about-content');
        this.settings.content = content !== undefined ? content.toString() : this.settings.content;

        var copyrightYear = this.element.attr('data-copyright-year');
        this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;

        var deviceSpecs = this.element.attr('data-device-specs');
        if (deviceSpecs) {
          this.settings.deviceSpecs = deviceSpecs === 'true';
        }

        var productName = this.element.attr('data-product-name');
        this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;

        var useDefaultCopyright = this.element.attr('data-use-default');
        if (useDefaultCopyright !== undefined) {
          this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
        }

        var version = this.element.attr('data-version');
        this.settings.version = version !== undefined ? version.toString() : this.settings.version;

        // Get the default copyright text and cut in the current year
        this.defaultCopyright = Locale.translate('AboutText') + ' <a class="hyperlink" href="http://www.infor.com" target="_blank">www.infor.com</a>.';
        this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);

        return this;
      },

      build: function() {
        this.modal = $('<div class="modal about" id="about-modal"></div>');
        $('<div class="modal-content"></div>').appendTo(this.modal);
        var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
        $('<div class="close-container"></div>')
          .append($('<button name="close" type="button" class="btn-icon hide-focus"></button>')
            .append($.createIconElement({ icon: 'close', classes: 'icon-close' }))
            .append('<span>' + Locale.translate('Close') + '</span>'))
          .appendTo(header);
        $.createIconElement({ icon: 'logo-trademark', classes: ['icon', 'about-logo'] }).attr({ viewBox: '0 0 44 44' }).appendTo(header);
        this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));

        var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

        if (this.settings.version || this.settings.productName) {
          var productAndVersion = '' + (this.settings.productName ? this.settings.productName + ' ' : '') +
            (this.settings.version ? this.settings.version : '');
          $('<p></p>').text(productAndVersion).appendTo(body);
        }

        if (this.settings.content) {
          $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
        }

        if (this.settings.useDefaultCopyright || !this.settings.content) {
          $('<p></p>').html(this.defaultCopyright).appendTo(body);
        }

        if (this.settings.deviceSpecs) {
          var specs = this.getDeviceSpecs(),
            text = '<span class="browser">' + Locale.translate('Browser') + ' : ' + specs.browser + '</span><br>' +
              '<span class="platform">' + Locale.translate('Platform') + ' : ' + specs.os + '</span><br>' +
              '<span class="locale">' + Locale.translate('Locale') + ' : ' + specs.locale + '</span><br>' +
              '<span class="cookiesEnabled">' + Locale.translate('CookiesEnabled') + ' : ' +  specs.cookiesEnabled + '</span><br>';
          $('<p></p>').html(text).appendTo(body);
        }

        //$('<div class="modal-buttonset"><button type="button" name="done" class="btn-modal">Done</button></div>').appendTo(this.modal.find('.modal-content'));
        this.buttons = this.modal.find('button');

        this.modal.find('.hide-focus').one('blur', function () {
          $(this).removeClass('hide-focus');
        });

        this.element.attr('data-modal','about-modal');

        $('.modal-body', this.modal)[0].tabIndex = 0;

        this.modal.appendTo('body');
        this.modal.modal({trigger: this.isBody ? 'immediate' : 'click'});
        return this;
      },

      /**
      * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
      * @returns {String}
      */
      getDeviceSpecs: function() {

        var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language,
          browser = (function(){
            var ua= navigator.userAgent, tem,
            M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

            if (/trident/i.test(M[1])){
              tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
              return 'IE '+(tem[1] || '');
            }

            if (M[1]=== 'Chrome'){
              tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
              if (tem!= null) {
                return tem.slice(1).join(' ').replace('OPR', 'Opera');
              }
            }

            M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
            if ((tem= ua.match(/version\/(\d+)/i))!= null) {
              M.splice(1, 1, tem[1]);
            }
            return M.join(' ');
        })();

        return {
          browser: browser,
          os: navigator.platform,
          cookiesEnabled: navigator.cookieEnabled,
          locale: locale
        };
      },

      /**
      * Progamatically Close the About Dialog.
      */
      close: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.close();
        }

        if (this.isBody) {
          this.destroy();
        }
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.element.off('beforeopen.about');
          modalApi.destroy();
        }

        this.buttons.off();
        this.element.off('open.about');
        $.removeData(this.element[0], pluginName);
      },

      /**
      * Fires before the dialog is closing. You can return false syncronously to delay closing.
      *
      * @event beforeclose
      * @type {object} fires
      * @property {Object} event - The jquery event object.
      * @property {Object} ui - The dialog object
      */

      /**
      * Fires as the dialog is closing
      *
      * @event close
      * @type {object} fires
      * @property {Object} event - The jquery event object.
      * @property {Object} ui - The dialog object
      */

      /**
       *Fires after the dialog has closed in the DOM entirely.
       *
       * @event afterclose
       * @type {object} fires
       * @property {Object} event - The jquery event object.
       * @property {Object} ui - The dialog object
       */

      handleEvents: function() {
        var self = this;

        this.element.on('open.about', function(e) {
          e.stopPropagation();
          self.element.trigger('click');
        });

        this.buttons.filter('[name="done"], [name="close"]').on('click.about', function() {
          self.close();
        });

        this.modal.data('modal').element.on('beforeopen.about', function() {
          self.modal.find('.modal-body').scrollTop(0);
        });

        $(document).on('keydown.about', function(e) {
          // Close on Escape.
          if (e.which === 0 || e.which === 27) {
            self.close();
          }
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new About(this, settings));
      }
    });
  };

// NOTE:  There are AMD Blocks available


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.accordion = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'accordion',
        defaults = {
          allowOnePane: true,
          displayChevron: true,
          rerouteOnLinkClick: true,
          source: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Accordion is a grouped set of collapsible panels used to navigate sections of
    * related content. Each panel consists of two levels: the top level identifies the
    * category or section header, and the second level provides the associated options.
    *
    * @class Accordion
    * @param {String} allowOnePane &nbsp;-&nbsp; If set to true, allows only one pane of the Accordion to be open at a time.  If an Accordion pane is open, and that pane contains sub-headers, only one of the pane's sub-headers can be open at a time. (default true)
    * @param {String} displayChevron  &nbsp;-&nbsp; Displays a "Chevron" icon that sits off to the right-most side of a top-level accordion header.  Used in place of an Expander (+/-) if enabled.
    * @param {String} rerouteOnLinkClick  &nbsp;-&nbsp; Can be set to false if routing is externally handled
    * @param {Boolean} source  &nbsp;-&nbsp; A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
    *
    */
    function Accordion(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Accordion.prototype = {
      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        return this;
      },

      build: function() {
        var self = this;

        this.headers = this.element.find('.accordion-header');
        this.anchors = this.headers.children('a');
        this.panes = this.headers.next('.accordion-pane');

        var headersHaveIcons = false;

        // Accordion Headers that have an expandable pane need to have an expando-button added inside of them
        this.headers.each(function addExpander() {
          var header = $(this),
            hasIcons = false,
            containerPane = header.parent(),
            isTopLevel = containerPane.is('.accordion');

          function checkIfIcons() {
            if (isTopLevel) {
              return;
            }

            if (!hasIcons) {
              header.addClass('no-icon');
              return;
            }

            containerPane.addClass('has-icons');
          }

          header.attr('role', 'presentation').hideFocus();

          // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the level of the header.
          header.children('a').find('svg').detach().insertBefore(header.children('a'));

          var outerIcon = header.children('.icon, svg');
          outerIcon.addClass('icon').attr({'role': 'presentation', 'aria-hidden': 'true', 'focusable': 'false'});
          if (isTopLevel && outerIcon.length) {
            headersHaveIcons = true;
          }

          if (header.is('.list-item') || (!isTopLevel && header.find('button').length)) {
            hasIcons = true;
          }

          // Enable/Disable
          if (header.hasClass('is-disabled')) {
            header.children('a, button').attr('tabindex', '-1');
          }

          // Don't continue if there's no pane
          if (!header.next('.accordion-pane').length) {
            checkIfIcons();
            return;
          }

          hasIcons = true;

          var expander = header.children('.btn');
          if (!expander.length) {
            expander = $('<button class="btn" type="button"></button>');

            var method = 'insertBefore';
            if (self.settings.displayChevron && isTopLevel) {
              header.addClass('has-chevron');
              method = 'insertAfter';
            }
            expander[method](header.children('a'));
            header.data('addedExpander', expander);
          }

          // Hide Focus functionality
          expander.hideFocus();

          // If Chevrons are turned off and an icon is present, it becomes the expander
          if (outerIcon.length && !self.settings.displayChevron) {
            outerIcon.appendTo(expander);
          }

          var expanderIcon = expander.children('.icon, .svg, .plus-minus');
          if (!expanderIcon.length) {
            if (self.settings.displayChevron && isTopLevel) {
              expanderIcon = $.createIconElement({ icon: 'caret-down', classes: ['chevron'] });
            } else {
              var isActive = self.isExpanded(header) ? ' active' : '';
              expanderIcon = $('<span class="icon plus-minus'+ isActive +'" aria-hidden="true" role="presentation"></span>');
            }
            expanderIcon.appendTo(expander);
          }
          var expanderIconOpts = {
            'role': 'presentation',
            'aria-hidden': 'true'
          };
          if (!expanderIcon.is('span')) {
            expanderIconOpts.focusable = 'false';
          }
          expanderIcon.attr(expanderIconOpts);

          // Move around the Expander depending on whether or not it's a chevron
          if (expanderIcon.is('.chevron')) {
            header.addClass('has-chevron');
            expander.insertAfter(header.children('a'));
          } else {
            header.removeClass('has-chevron');
            expander.insertBefore(header.children('a'));
          }

          // Double check to see if we have left-aligned expanders or icons present,
          // so we can add classes that do alignment
          if (!self.settings.displayChevron && isTopLevel) {
            headersHaveIcons = true;
          }
          checkIfIcons();

          // Add an Audible Description to the button
          var description = expander.children('.audible');
          if (!description.length) {
            description = $('<span class="audible"></span>').appendTo(expander);
          }
          description.text(Locale.translate('Expand'));
        });

        if (headersHaveIcons) {
          this.element.addClass('has-icons');
        }

        // Setup correct ARIA for accordion panes, and auto-collapse them
        this.panes.each(function addPaneARIA() {
          var pane = $(this),
            header = pane.prev('.accordion-header');

          header.children('a').attr({'aria-haspopup': 'true', 'role': 'button'});

          if (!self.isExpanded(header)) {
            pane.data('ignore-animation-once', true);
            self.collapse(header);
          }
        });

        // Expand to the current accordion header if we find one that's selected
        if (!this.element.data('updating')) {
          var targetsToExpand = this.headers.filter('.is-selected, .is-expanded');

          if (this.settings.allowOnePane) {
            targetsToExpand = targetsToExpand.first();
          }

          this.expand(targetsToExpand);
          this.select(targetsToExpand.last());
        }

        return this;
      },

      handleHeaderClick: function(e, header) {
        if (!header || !header.length || this.isDisabled(header) || header.data('is-animating')) {
          e.preventDefault();
          return;
        }

        // Check that we aren't clicking the expando button.  If we click that, this listener dies
        if ($(e.target).is('[class^="btn"]')) {
          e.preventDefault();
          return;
        }

        var anchor = header.children('a');
        return this.handleAnchorClick(e, anchor);
      },

      handleAnchorClick: function(e, anchor) {
        var self = this,
          header = anchor.parent('.accordion-header'),
          pane = header.next('.accordion-pane'),
          ngLink = anchor.attr('ng-reflect-href');

        if (e && !ngLink) {
          e.preventDefault();
        }

        if (!header.length || this.isDisabled(header)) {
          return false;
        }

        var canSelect = this.element.triggerHandler('beforeselect', [anchor]);
        if (canSelect === false) {
          return;
        }

        this.element.trigger('selected', header);

        // Set the original element for DOM traversal by keyboard
        this.originalSelection = anchor;

        this.select(anchor);

        function followLink() {
          var href = anchor.attr('href');
          if (href && href !== '' && href !== '#') {
            if (!self.settings.rerouteOnLinkClick) {
              return true;
            }

            window.location.href = href;
            return true;
          }
          return false;
        }

        function toggleExpander() {
          if (pane.length) {
            self.toggle(header);
          }
          anchor.focus();
        }

        // Stop propagation here because we don't want to bubble up to the Header and potentially click the it twice
        if (e) {
          e.stopPropagation();
        }

        // If the anchor's a real link, follow the link and die here
        if (followLink()) {
          this.element.trigger('followlink', [anchor]);
          return true;
        }

        // If it's not a real link, try and toggle an expansion pane
        toggleExpander();
        return true;
      },

      handleExpanderClick: function(e, expander) {
        var header = expander.parent('.accordion-header');
        if (!header.length || this.isDisabled(header) || header.data('is-animating')) {
          return;
        }

        // Set the original element for DOM traversal by keyboard
        this.originalSelection = expander;

        // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in cases
        // where it shouldn't be clicked.
        if (e) {
          e.stopPropagation();
        }

        var pane = header.next('.accordion-pane');
        if (pane.length) {
          this.toggle(header);
          this.select(header);
          expander.focus();
          return;
        }

        // If there's no accordion pane, attempt to simply follow the link.
        return this.handleAnchorClick(null, header.children('a'));
      },

      handleKeys: function(e) {
        var self = this,
          key = e.which,
          target = $(e.target), // will be either an anchor or expando button.  Should NEVER be the header itself.
          header = target.parent(),
          expander = header.children('[class^="btn"]').first(),
          anchor = header.children('a');

        function setInitialOriginalSelection(selection) {
          if (!selection) {
            selection = target;
          }

          if (!self.originalSelection) {
            self.originalSelection = selection;
          }
        }

        if (key === 9) { // Tab (also triggered by Shift + Tab)
          this.headers.removeClass('is-selected');

          if (target.is('a') && expander.length) {
            setInitialOriginalSelection(expander);
          } else {
            setInitialOriginalSelection(anchor);
          }
        }

        if (key === 32) { // Spacebar
          e.preventDefault();

          // Don't let this propagate and run against the header element, if it's a button
          if (target.is('[class^="btn"]')) {
            e.stopPropagation();
            e.stopImmediatePropagation();

            // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
            // Just cancel the whole thing if Firefox is running this method.
            if ($('html').hasClass('is-firefox')) {
              return;
            }
          }

          if (expander.length) {
            setInitialOriginalSelection(expander);
            return this.handleExpanderClick(null, target);
          } else {
            setInitialOriginalSelection(anchor);
            return this.handleAnchorClick(null, target);
          }
        }

        if (key === 37 || key === 38) { // Left Arrow/Up Arrow
          e.preventDefault();
          setInitialOriginalSelection();
          if (e.shiftKey) {
            return this.ascend(header);
          }
          return this.prevHeader(header);
        }

        if (key === 39 || key === 40) { // Right Arrow/Down Arrow
          e.preventDefault();
          setInitialOriginalSelection();
          if (e.shiftKey) {
            return this.descend(header);
          }
          return this.nextHeader(header);
        }
      },

      // Makes a header "selected" if its expander button or anchor tag is focused.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      select: function(element) {
        if (!element || !element.length) {
          return;
        }

        // Make sure we select the anchor
        var anchor = element,
          header = anchor.parent();

        if (element.is('.accordion-header')) {
          header = element;
          anchor = header.children('a');
        }

        if (anchor.is('[class^="btn"]')) {
          anchor = element.next('a');
        }

        if (this.isDisabled(header)) {
          return;
        }

        this.headers.removeClass('child-selected').removeClass('is-selected');

        header.addClass('is-selected');

        var items = header.parentsUntil(this.element, '.accordion-pane')
          .prev('.accordion-header');

        items.addClass('child-selected');
      },

      /**
      * Checks if a particular header is disabled, or if the entire accordion is disabled..
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      * @returns {Boolean}
      */
      isDisabled: function(header) {
        if (this.element.hasClass('is-disabled')) {
          return true;
        }

        if (!header) {
          return false;
        }

        return header.hasClass('is-disabled');
      },

      /**
      * Checks if an Accordion Section is currently expanded
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      * @returns {Boolean}
      */
      isExpanded: function(header) {
        if (!header || !header.length) {
          return;
        }

        return header.children('a').attr('aria-expanded') === 'true';
      },

      /**
      * Toggle the given Panel on the Accordion between expanded and collapsed
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      toggle: function(header) {
        if (!header || !header.length || this.isDisabled(header)) {
          return;
        }

        if (this.isExpanded(header)) {
          this.collapse(header);
          return;
        }
        this.expand(header);
      },

      /**
      * Expand the given Panel on the Accordion.
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      expand: function(header) {
        if (!header || !header.length) {
          return;
        }

        var self = this,
          pane = header.next('.accordion-pane'),
          a = header.children('a');

        var canExpand = this.element.triggerHandler('beforeexpand', [a]);
        if (canExpand === false) {
          return;
        }

        function continueExpand() {
          // Change the expander button into "collapse" mode
          var expander = header.children('.btn');
          if (expander.length) {
            expander.children('.plus-minus, .chevron').addClass('active');
            expander.children('.audible').text(Locale.translate('Collapse'));
          }

          var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header);

          // If we have the correct settings defined, close other accordion headers that are not parents of this one.
          if (self.settings.allowOnePane) {
            self.headers.not(headerParents).each(function() {
              var h = $(this);
              if (self.isExpanded(h)) {
                self.collapse(h);
              }
            });
          }

          // Expand all headers that are parents of this one, if applicable
          headerParents.not(header).each(function() {
            var h = $(this);
            if (!self.isExpanded(h)) {
              self.expand(h);
            }
          });

          pane.addClass('is-expanded');
          self.element.trigger('expand', [a]);

          pane.one('animateopencomplete', function(e) {
            e.stopPropagation();
            header.children('a').attr('aria-expanded', 'true');
            self.element.trigger('afterexpand', [a]);
          }).css('display', 'block').animateOpen();
        }

        // Load from an external source, if applicable
        if (!this.callSource(a, continueExpand)) {
          continueExpand.apply(this);
        }
      },

      /**
       * Expands all accordion headers, if possible.
       */
      expandAll: function() {
        if (this.settings.allowOnePane === true) {
          return;
        }

        var self = this;
        this.headers.each(function() {
          var h = $(this);
          if (!self.isExpanded(h)) {
            self.expand(h);
          }
        });
      },

      /**
      * Collapse the given Panel on the Accordion.
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      collapse: function(header) {
        if (!header || !header.length) {
          return;
        }

        var self = this,
          pane = header.next('.accordion-pane'),
          a = header.children('a');

        var canExpand = this.element.triggerHandler('beforecollapse', [a]);
        if (canExpand === false) {
          return;
        }

        // Change the expander button into "expand" mode
        var expander = header.children('.btn');
        if (expander.length) {
          expander.children('.plus-minus, .chevron').removeClass('active');
          expander.children('.audible').text(Locale.translate('Expand'));
        }

        pane.removeClass('is-expanded').closeChildren();
        a.attr('aria-expanded', 'false');

        self.element.trigger('collapse', [a]);

        pane.one('animateclosedcomplete', function(e) {
          e.stopPropagation();
          pane[0].style.display = 'none';
          self.element.trigger('aftercollapse', [a]);
        }).animateClosed();
      },

      /**
       * Collapses all accordion headers.
       */
      collapseAll: function() {
        var self = this;
        this.headers.each(function() {
          var h = $(this);
          if (self.isExpanded(h)) {
            self.collapse(h);
          }
        });
      },

      // Uses a function (this.settings.source()) to call out to an external API to fill the
      // inside of an accordion pane.
      callSource: function(anchor, animationCallback) {
        if (!this.settings.source || typeof this.settings.source !== 'function') {
          return false;
        }

        var self = this,
          header = anchor.parent(),
          pane = header.next('.accordion-pane'),
          ui = {
            anchor: anchor,
            header: header,
            pane: pane
          };

        function response() {
          self.updated();
          setTimeout(function() {
            animationCallback.apply(self);
          }, 1);
          return;
        }

        // Trigger the external method and wait for a response.
        return this.settings.source(ui, response);
      },

      // Prepares a handful of references to a specific
      getElements: function(eventTarget) {
        var target = $(eventTarget),
          header, anchor, expander, pane;

        if (target.is('.accordion-header')) {
          header = target;
          expander = target.children('[class^="btn"]');
          anchor = target.children('a');
        }

        if (target.is('.btn')) {
          expander = target;
          header = expander.parent();
          anchor = header.children('a');
        }

        if (target.is('a')) {
          anchor = target;
          header = anchor.parent();
          expander = header.children('.btn');
        }

        pane = header.next('.accordion-pane');

        return {
          header: header,
          expander: expander,
          anchor: anchor,
          pane: pane
        };
      },

      // Selects an adjacent Accordion Header that sits directly before the currently selected Accordion Header.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      // @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
      prevHeader: function(element, noDescend) {
        var elem = this.getElements(element),
          adjacentHeaders = elem.header.parent().children(),
          currentIndex = adjacentHeaders.index(elem.header),
          target = $(adjacentHeaders.get(currentIndex - 1));

        if (!adjacentHeaders.length || currentIndex === 0) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }
          target = adjacentHeaders.last();
        }

        while (target.is('.accordion-content') || this.isDisabled(target)) {
          if (target.is(':only-child') || target.is(':first-child')) {
            return this.ascend(elem.header);
          }
          target = target.prev();
        }

        if (target.is('.accordion-pane')) {
          var prevHeader = target.prev('.accordion-header');
          if (this.isExpanded(prevHeader)) {
            var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
            if (descendantChildren.length && !noDescend) {
              return this.descend(prevHeader, -1);
            }
          }
          target = prevHeader;

          // if no target's available here, we've hit the end and need to wrap around
          if (!target.length) {
            if (elem.header.parent('.accordion-pane').length) {
              return this.ascend(elem.header);
            }

            target = adjacentHeaders.last();
            while (target.is('.accordion-content') || this.isDisabled(target)) {
              target = target.prev();
            }
          }
        }

        this.focusOriginalType(target);
      },

      // Selects an adjacent Accordion Header that sits directly after the currently selected Accordion Header.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      // @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
      nextHeader: function(element, noDescend) {
        var elem = this.getElements(element),
          adjacentHeaders = elem.header.parent().children(),
          currentIndex = adjacentHeaders.index(elem.header),
          target = $(adjacentHeaders.get(currentIndex + 1));

        if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }
          target = adjacentHeaders.first();
        }

        while (target.is('.accordion-content') || this.isDisabled(target)) {
          if (target.is(':only-child') || target.is(':last-child')) {
            return this.ascend(elem.header);
          }
          target = target.next();
        }

        if (target.is('.accordion-pane')) {
          var prevHeader = target.prev('.accordion-header');
          if (this.isExpanded(prevHeader)) {
            var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
            if (descendantChildren.length && !noDescend) {
              return this.descend(prevHeader);
            }
          }
          target = $(adjacentHeaders.get(currentIndex + 2));

          // if no target's available here, we've hit the end and need to wrap around
          if (!target.length) {
            if (elem.header.parent('.accordion-pane').length) {
              return this.ascend(elem.header, -1);
            }

            target = adjacentHeaders.first();
            while (target.is('.accordion-content') || this.isDisabled(target)) {
              target = target.next();
            }
          }
        }

        this.focusOriginalType(target);
      },

      // Selects the first Accordion Header in the parent container of the current Accordion Pane.
      // If we're at the top level, jump out of the accordion to the last focusable element.
      // @param {Object} header - a jQuery Object containing an Accordion header.
      // @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
      ascend: function(header, direction) {
        if (!direction) {
          direction = 0;
        }

        var pane = header.parent('.accordion-pane'),
          target = pane.prev();

        if (direction === -1) {
          target = pane.next('.accordion-header');
          if (!target.length) {
            if (pane.parent('.accordion').length) {
              return this.nextHeader(pane.prev().children('a'), true);
            }

            return this.ascend(pane.prev(), -1);
          }
        }

        this.focusOriginalType(target);
      },

      // Selects the first Accordion Header in the child container of the current Accordion Header.
      // @param {Object} header - a jQuery Object containing an Accordion header.
      // @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
      descend: function(header, direction) {
        if (!direction) {
          direction = 0;
        }

        var pane = header.next('.accordion-pane'),
          target = pane.children('.accordion-header').first();

        if (direction === -1) {
          target = pane.children('.accordion-header').last();
        }

        // No headers may be present.  In which case, it may be necessary to simply focus the header for the current pane.
        if (!target.length) {
          return this.focusOriginalType(header);
        }

        if (this.isExpanded(target)) {
          return this.descend(target, -1);
        }

        this.focusOriginalType(target);
      },

      // Selects an Accordion Header, then focuses either an expander button or an anchor.
      // Governed by the property "this.originalSelection".
      // @param {Object} header - a jQuery Object containing an Accordion header.
      focusOriginalType: function(header) {
        //this.select(header.children('a'));

        if (this.originalSelection.is('.btn') && header.children('.btn').length) {
          header.children('.btn').focus();
        } else {
          header.children('a').focus();
        }
      },

      /**
      * Disable an accordion from events
      */
      disable: function() {
        this.element
          .addClass('is-disabled');

        this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
      },

      /**
      * Enable a disabled accordion.
      */
      enable: function() {
        this.element
          .removeClass('is-disabled');

        this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
      },

      updated: function() {
        this.element.data('updating', true);

        var currentFocus = $(document.activeElement);
        if (!$.contains(this.element[0], currentFocus[0])) {
          currentFocus = undefined;
        }

        this
          .teardown()
          .init();

        if (currentFocus && currentFocus.length) {
          currentFocus.focus();
        }

        $.removeData(this.element[0], 'updating');
        return this;
      },

      teardown: function() {
        this.headers
          .off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion')
          .each(function() {
            var expander = $(this).data('addedExpander');
            if (expander) {
              expander.remove();
              $.removeData(this, 'addedExpander');
            }
          });

        this.anchors.off('touchend.accordion keydown.accordion click.accordion');

        this.headers.children('[class^="btn"]')
          .off('touchend.accordion click.accordion keydown.accordion');

        this.element.off('updated.accordion selected.accordion');

        return this;
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Accordion#events
       * @param {Object} selected  &nbsp;-&nbsp; Fires when a panel is opened.
       * @param {Object} followlink  &nbsp;-&nbsp; If the anchor is a real link, follow the link and die here. This indicates the link has been followed.
       * @param {Object} expand  &nbsp;-&nbsp; Fires when expanding a pane is initiated.
       * @param {Object} afterexpand  &nbsp;-&nbsp; Fires after a pane is expanded.
       * @param {Object} collapse  &nbsp;-&nbsp; Fires when collapsed a pane is initiated.
       * @param {Object} aftercollapse  &nbsp;-&nbsp; Fires after a pane is collapsed.
       *
       */
      handleEvents: function() {
        var self = this,
          headerWhereMouseDown = null;

        // Returns "Header", "Anchor", or "Expander" based on the element's tag
        function getElementType(element) {
          var elementType = 'Header';
          if (element.is('a')) {
            elementType = 'Anchor';
          }
          if (element.is('button')) {
            elementType = 'Expander';
          }
          return elementType;
        }

        // Intercepts a 'click' event in order to either prevent a link from being followed,
        // or allows it to continue.
        function clickInterceptor(e, element) {
          var type = getElementType(element);
          return self['handle' + type + 'Click'](e, element);
        }

        this.headers.on('click.accordion', function(e) {
          return clickInterceptor(e, $(this));
        }).on('focusin.accordion', function(e) {
          var target = $(e.target);

          if (!self.originalSelection) {
            self.originalSelection = target;
          }

          if (target.is(':not(.btn)')) {
            $(this).addClass('is-focused');
          }
        }).on('focusout.accordion', function() {
          if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
            $(this).removeClass('is-focused');
          }
        }).on('keydown.accordion', function(e) {
          self.handleKeys(e);
        }).on('mousedown.accordion', function(e) {
          $(this).addClass('is-focused');
          headerWhereMouseDown = e.target;
        }).on('mouseup.accordion', function() {
          headerWhereMouseDown = null;
        });

        this.anchors.on('click.accordion', function(e) {
          return clickInterceptor(e, $(this));
        });

        this.headers.children('[class^="btn"]')
          .on('click.accordion', function(e) {
            return clickInterceptor(e, $(this));
          }).on('keydown.accordion', function(e) {
            self.handleKeys(e);
          });

        this.element.on('selected.accordion', function(e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function(e) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated();
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Accordion(this, settings));
      }
    });
  };


  $.fn.applicationmenu = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'applicationmenu',
        defaults = {
          breakpoint: 'phone-to-tablet',
          openOnLarge: false,
          triggers: []
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Application Menu provides access to all the functions, pages, and forms in an application.
    *
    * @class ApplicationMenu
    * @param {String} breakpoint  &nbsp;-&nbsp; Can be 'tablet' (+720), 'phablet (+968), ' 'desktop' +(1024), or 'large' (+1280). Default is phablet (968)
    * @param {String} openOnLarge  &nbsp;-&nbsp; If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
    * @param {String} triggers  &nbsp;-&nbsp; An Array of jQuery-wrapped elements that are able to open/close this nav menu.
    */
    function ApplicationMenu(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ApplicationMenu.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        this
          .setup()
          .handleEvents();
      },

      /**
       * @private
       * @returns {this}
       */
      setup: function() {
        this.hasTrigger = false;
        this.isAnimating = false;

        if (!this.hasTriggers()) {
          this.triggers = $();
        }

        this.menu = this.element;

        var openOnLarge = this.element.attr('data-open-on-large');
        this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;

        var breakpoints = Soho.breakpoints,
        dataBreakpoint = this.element.attr('data-breakpoint');
        this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint;

        // Pull in the list of Nav Menu trigger elements and store them internally.
        this.modifyTriggers(this.settings.triggers, false, true);

        this.scrollTarget = this.menu.parents('.header');
        var masthead = this.menu.prevAll('.masthead'),
          moduleTabs = this.menu.prevAll('.module-tabs');

        if (masthead.length > 0) {
          this.scrollTarget = masthead;
          this.menu.addClass('short');
        }
        if (moduleTabs.length > 0) {
          this.scrollTarget = moduleTabs;
        }

        this.accordion = this.menu.find('.accordion');
        this.accordion.addClass('panel').addClass('inverse');

        // Check to make sure that the internal Accordion Control is invoked
        var accordion = this.accordion.data('accordion');
        if (!accordion) {
          var accOpts = $.fn.parseOptions(this.accordion[0]);
          this.accordion.accordion(accOpts);
        }

        this.adjustHeight();

        return this;
      },

      // Setup click events on this.element if it's not the menu itself
      // (this means that it's a trigger button)
      handleTriggerEvents: function() {
        var self = this;

        function triggerClickHandler(e) {
          // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
          if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
            return false;
          }

          if (self.isAnimating) {
            return false;
          }

          var isOpen = self.menu.hasClass('is-open');
          if (!isOpen) {
            self.openMenu(undefined, true);
          } else {
            self.closeMenu(true);
          }
          return true;
        }

        if (this.triggers.length) {
          this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
        }
      },

      handleKeyDown: function(e) {
        var key = e.which;

        if (key === 27) { // Escape
          e.preventDefault();
          this.closeMenu();
          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
          return false;
        }
      },

      notify: function(anchor, value) {
        if (!anchor || anchor === undefined) {
          return;
        }
        if (anchor instanceof HTMLElement) {
          anchor = $(anchor);
        }
        if (!anchor.is('a')) {
          return;
        }

        var tag = anchor.find('.tag');

        // Close the tag if an undefined or '0' value is passed
        if (!value || value === undefined || parseInt(value, 10) === 0) {
          if (tag.length) {
            tag.remove();
          }
          return;
        }

        if (!tag.length) {
          tag = $('<span class="tag"></span>').appendTo(anchor);
        }

        tag.text(value.toString());
        return tag;
      },

      /**
       * Adjusts the application menu's height to fit the page.
       * @private
       */
      adjustHeight: function() {
        var isSticky = this.scrollTarget.is('.is-sticky'),
          totalHeight = this.scrollTarget.outerHeight(true),
          offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

        if (this.scrollTarget.prev().is('.masthead')) {
          offset += this.scrollTarget.prev().outerHeight(true);
        }

        this.menu[0].style.height = offset > 0 ? ('calc(100% - ' + offset + 'px)') : '100%';
      },

      /**
       * Checks the window size against the defined breakpoint.
       * @private
       */
      isLargerThanBreakpoint: function() {
        return Soho.breakpoints.isAbove(this.settings.breakpoint);
      },

      /**
       * Detects whether or not the application menu is open
       * @returns {boolean}
       */
      isOpen: function() {
        return this.menu[0].classList.contains('is-open');
      },

      /**
       * Detects a change in breakpoint size that can cause the Application Menu's state to change.
       */
      testWidth: function() {
        if (this.isOpen()) {
          if (Soho.breakpoints.isAbove(this.settings.breakpoint)) {
            return;
          }
          if (this.element.find(document.activeElement).length || this.isAnimating) {
            return;
          }

          this.closeMenu();
          return;
        }

        if (Soho.breakpoints.isBelow(this.settings.breakpoint)) {
          return;
        }

        if (this.userClosed || !this.settings.openOnLarge || this.isAnimating) {
          return;
        }

        this.openMenu(true);

      },

      /**
       * Opens the Application Menu
       * @param {boolean} noFocus - If true, sets focus on the first item in the application menu.
       * @param {boolean} userOpened - If true, notifies the component that the menu was manually opened by the user.
       */
      openMenu: function(noFocus, userOpened) {
        if (this.isAnimating === true) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitonEndName;

        this.isAnimating = true;
        this.adjustHeight();

        function isOpen() {
          if (self.timeout !== null) {
            clearTimeout(self.timeout);
            self.timeout = null;
          }

          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');

          if (userOpened) {
            self.userOpened = true;
            self.userClosed = undefined;
          }

          self.menu.removeClass('no-transition');
          $('.page-container').removeClass('no-transition');
        }

        this.triggers.each(function() {
          var trig = $(this);
          if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
            var header = trig.parents('.header, .masthead');
            if (header.parents('.page-container').length) {
              return;
            }

            trig.find('.icon.app-header').removeClass('go-back').addClass('close');
            trig.trigger('icon-change');
          }
        });

        this.menu.off(transitionEnd + '.applicationmenu');
        this.menu[0].style.display = '';
        // next line forces a repaint
        this.menu[0].offsetHeight; //jshint ignore:line
        this.menu.addClass('is-open');

        if (!noFocus || noFocus !== true) {
          this.menu.find('.is-selected > a').focus();
        }

        this.menu.one(transitionEnd + '.applicationmenu', isOpen);
        this.timeout = setTimeout(isOpen, 300);

        // Events that will close the nav menu
        // On a timer to prevent conflicts with the Trigger button's click events
        setTimeout(function() {
          $(document).on('click.applicationmenu', function(e) {
            if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
              self.closeMenu(true);
            }
          }).on('keydown.applicationmenu', function(e) {
            self.handleKeyDown(e);
          });
        }, 0);
      },

      /**
       * Closes the Application Menu
       * @param {boolean} userClosed - if true, sets a flag notifying the component that the user was responsible for closing.
       */
      closeMenu: function(userClosed) {
        if (this.isAnimating === true) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName();

        this.isAnimating = true;

        function close() {
          if (self.timeout !== null) {
            clearTimeout(self.timeout);
            self.timeout = null;
          }

          self.menu.off(transitionEnd + '.applicationmenu');
          self.menu[0].style.display = 'none';
          self.isAnimating = false;

          if (userClosed) {
            self.userOpened = undefined;
            self.userClosed = true;
          }

          self.element.trigger('applicationmenuclose');
        }

        this.triggers.each(function() {
          var trig = $(this);
          if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
            trig.find('.icon.app-header').removeClass('close');
            trig.trigger('icon-change');
          }
        });

        this.menu.one(transitionEnd + '.applicationmenu', close);
        this.timeout = setTimeout(close, 300);

        this.menu.removeClass('is-open').find('[tabindex]');
        $(document).off('click.applicationmenu keydown.applicationmenu');
      },

      /**
       * Detects whether or not the Application Menu has external trigger buttons setup to control it.
       * @returns {boolean}
       */
      hasTriggers: function() {
        return (this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length);
      },

      /**
       * Externally Facing function that can be used to add/remove application nav menu triggers.
       * @param {Array[]} triggers - an array of HTMLElements or jQuery-wrapped elements that will be used as triggers.
       * @param {boolean} [remove] - if defined, triggers that are defined will be removed internally instead of added.
       * @param {boolean} [norebuild] - if defined, this control's events won't automatically be rebound to include the new triggers.
       */
      modifyTriggers: function(triggers, remove, norebuild) {
        if (!triggers || !triggers.length) {
          return;
        }
        var changed = $();

        $.each(triggers, function(i, obj) {
          changed = changed.add($(obj));
        });

        this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
        this.handleTriggerEvents();

        if (norebuild && norebuild === true) {
          return;
        }

        this.updated();
      },

      /**
       * Unbinds event listeners and removes extraneous markup from the Application Menu.
       * @returns {this}
       */
      teardown: function() {
        var api;
        this.accordion.off('blur.applicationmenu');
        this.menu.off('animateopencomplete animateclosedcomplete');
        $(window).off('scroll.applicationmenu');
        $('body').off('resize.applicationmenu');
        $(document).off('click.applicationmenu open-applicationmenu close-applicationmenu');

        api = this.accordion ? this.accordion.data('accordion') : null;
        if (api && api.destroy) {
          api.destroy();
        }

        if (this.hasTriggers()) {
          this.triggers.off('click.applicationmenu');
        }

        return this;
      },

      /**
      * Triggers a UI Resync.
      */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.teardown();
        this.menu
          .detach()
          .appendTo(this.originalParent)
          .removeClass('short')
          .removeAttr('style');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Applicationmenu#events
       * @param {Object} applicationmenuopen  &nbsp;-&nbsp; Fires when the menu is opened.
       * @param {Object} applicationmenuclose  &nbsp;-&nbsp; Fires as the menu is closed.
        *
       */
      handleEvents: function() {
        var self = this;

        this.handleTriggerEvents();

        // Setup notification change events
        this.menu.on('notify.applicationmenu', function(e, anchor, value) {
          self.notify(anchor, value);
        }).on('updated.applicationmenu', function() {
          self.updated();
        });

        this.accordion.on('blur.applicationmenu', function() {
          self.closeMenu();
        });

        $(document).on('open-applicationmenu', function() {
          self.openMenu();
        }).on('close-applicationmenu', function() {
          self.closeMenu();
        });

        $(window).on('scroll.applicationmenu', function() {
          self.adjustHeight();
        });

        $('body').on('resize.applicationmenu', function() {
          self.testWidth();
        });

        if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
          this.menu.addClass('no-transition');
          $('.page-container').addClass('no-transition');
        }
        this.testWidth();

        //Remove after initial transition
        setTimeout(function() {
          self.menu.removeClass('no-transition');
          $('.page-container').removeClass('no-transition');
        }, 800);

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ApplicationMenu(this, settings));
      }
    });
  };


  $.fn.autocomplete = function(options) {
    'use strict';

    /**
    * The Autocomplete control provides an easier means of searching through a large amount of data by filtering down the results based on keyboard input from the user.
    *
    * @class Autocomplete
    *
    * @param {String} source  &nbsp;-&nbsp; Defines the data to use, must be specified.
    * @param {String} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} template  &nbsp;-&nbsp; If defined, use this to draw the contents of each search result instead of the default draw routine.
    * @param {String} filterMode  &nbsp;-&nbsp; The matching algorithm, startsWith and contains are supported - false will not filter client side
    * @param {Boolean} delay  &nbsp;-&nbsp; The delay between key strokes on the keypad before it thinks you stopped typing
    * @param {String} width  &nbsp;-&nbsp; Width of the open auto complete menu
    * @param {String} offset  &nbsp;-&nbsp; For the open menu, the left or top offset
    * @param {String} autoSelectFirstItem  &nbsp;-&nbsp; Whether or not to select he first item in the list to be selected
    *
    */
    var pluginName = 'autocomplete',
      defaults = {
        source: [],
        sourceArguments: {},
        template: undefined,
        filterMode: 'startsWith',
        delay: 300,
        width: null,
        offset: null,
        autoSelectFirstItem: false
      },
      settings = $.extend({}, defaults, options);

    function Autocomplete(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Default Autocomplete Result Item Template
    var resultTemplate = '<li id="{{listItemId}}" data-index="{{index}}" {{#hasValue}}data-value="{{value}}"{{/hasValue}} role="listitem">' + '\n\n' +
      '<a href="#" tabindex="-1">' + '\n\n' +
        '<span>{{{label}}}</span>' + '\n\n' +
      '</a>' + '\n\n' +
    '</li>';

    // Plugin Object
    Autocomplete.prototype = {

      init: function() {
        // data-autocomplete can be a url, 'source' or an array
        var data = this.element.attr('data-autocomplete');
        if (data && data !== 'source') {
          this.settings.source = data;
        }

        this.addMarkup();
        this.handleEvents();
      },

      addMarkup: function () {
        this.element.addClass('autocomplete').attr({
          'role': 'combobox',
          'autocomplete': 'off'
        });
      },

      isLoading: function() {
        return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
      },

      openList: function (term, items) {
        if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
          return;
        }

        var self = this,
          matchingOptions = [];

        term = Locale.toLowerCase(term);

        //append the list
        this.list = $('#autocomplete-list');
        if (this.list.length === 0) {
          this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
        }

        this.list[0].style.height = 'auto';
        this.list[0].style.width = this.element.outerWidth() + 'px';
        this.list.addClass('autocomplete');
        this.list.empty();

        if (this.settings.width) {
          this.list[0].style.width = this.settings.width + (/(px|%)/i.test(this.settings.width + '') ? '' : 'px');
        }

        // Pre-compile template.
        // Try to get an element first, and use its contents.
        // If the string provided isn't a selector, attempt to use it as a string, or fall back to the default template.
        var templateAttr = $(this.element.attr('data-tmpl'));
        this.tmpl = $(templateAttr).length ? $(templateAttr).text() :
          typeof templateAttr === 'string' ? templateAttr :
          $(this.settings.template).length ? $(this.settings.template).text() :
          typeof this.settings.template === 'string' ? this.settings.template :
          resultTemplate;

        for (var i = 0; i < items.length; i++) {
          var isString = typeof items[i] === 'string',
            option = (isString ? items[i] : items[i].label),
            baseData = {
              label: option
            },
            dataset = isString ? baseData : $.extend(baseData, items[i]),
            parts = option.split(' '),
            containsTerm = !this.settings.filterMode ? true : false;

          if (this.settings.filterMode === 'startsWith') {
              for (var a = 0; a < parts.length; a++) {
                if (Locale.toLowerCase(parts[a]).indexOf(term) === 0) {
                  containsTerm = true;
                }
              }

              //Direct Match
              if (Locale.toLowerCase(option).indexOf(term) === 0) {
                containsTerm = true;
              }

              if (term.indexOf(' ') > 0 && Locale.toLowerCase(option).indexOf(term) > 0) {
                //Partial dual word match
                containsTerm = true;
              }

          }

          if (this.settings.filterMode === 'contains') {
            if (Locale.toLowerCase(option).indexOf(term) >= 0) {
              containsTerm = true;
            }
          }

          if (containsTerm) {
            matchingOptions.push(option);

            // Build the dataset that will be submitted to the template
            dataset.listItemId = 'ac-list-option' + i;
            dataset.index = i;

            if (this.settings.filterMode === 'contains') {
              dataset.label = dataset.label.replace(new RegExp('(' + term + ')', 'ig'), '<i>$1</i>');
            } else {
              dataset.label = Locale.toLowerCase(option).indexOf(term)===0 ? '<i>' + option.substr(0,term.length) + '</i>' + option.substr(term.length) : option;

              var pos = Locale.toLowerCase(option).indexOf(term);
              if (pos > 0) {
                dataset.label = option.substr(0, pos) + '<i>' + option.substr(pos, term.length) + '</i>' + option.substr(term.length + pos);
              }
            }

            dataset.hasValue = !isString && items[i].value !== undefined;

            if (dataset.hasValue) {
              dataset.value = items[i].value;
            }

            if (typeof Tmpl !== 'undefined') {
              var compiledTmpl = Tmpl.compile(this.tmpl),
                renderedTmpl = compiledTmpl.render(dataset);

              self.list.append($.sanitizeHTML(renderedTmpl));
            } else {
              var listItem = $('<li role="listitem"></li>');
              listItem.attr('id', dataset.listItemId);
              listItem.attr('data-index', dataset.index);
              listItem.attr('data-value', dataset.value);
              listItem.append('<a href="#" tabindex="-1"><span>' + dataset.label + '</span></a>');
              self.list.append($.sanitizeHTML(listItem));
            }
          }
        }

        function autocompletePlaceCallback(placementObj) {
          // Nudge the autocomplete to the right by 1px in Chrome
          if (Soho.env.browser.name === 'chrome') {
            placementObj.setCoordinate('x', placementObj.x + 1);
          }
          return placementObj;
        }

        var popupOpts = {
          menuId: 'autocomplete-list',
          ariaListbox: true,
          mouseFocus: false,
          trigger: 'immediate',
          attachToBody: true,
          autoFocus: false,
          placementOpts: {
            callback: autocompletePlaceCallback,
            parent: this.element
          }
        };

        this.element.addClass('is-open')
          .popupmenu(popupOpts)
          .on('close.autocomplete', function () {
            self.closeList(true);
          });

        // Optionally select the first item in the list
        if (self.settings.autoSelectFirstItem) {
          self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first()
            .addClass('is-selected');
        }

        this.noSelect = true;
        this.element.trigger('populated', [matchingOptions]).focus();

        // Overrides the 'click' listener attached by the Popupmenu plugin
        self.list.off('click touchend')
          .on('touchend.autocomplete click.autocomplete', 'a', function(e) {
            self.select(e, items);
          })
          .off('focusout.autocomplete').on('focusout.autocomplete', function() {
            self.checkActiveElement();
          });

        // Highlight anchors on focus
        var all = self.list.find('a').on('focus.autocomplete touchend.autocomplete', function () {
          self.highlight($(this), all);
        });

        if (this.settings.offset) {
          var domListParent = this.list.parent()[0];

          if (this.settings.offset.left) {
            domListParent.style.left = parseInt(domListParent.style.left, 10) + this.settings.offset.left + 'px';
          }
          if (this.settings.offset.top) {
            domListParent.style.top = parseInt(domListParent.style.top, 10) + this.settings.offset.top + 'px';
          }
        }

        // As chars are typed into the edit field, nothing was announced to indicate
        // that a value has been suggested, for the non-sighted user an offscreen span
        // added and will remove soon popup close that includes aria-live="polite"
        // which have the first suggested item automatically announced when it
        // appears without moving focus.
        self.list.parent('.popupmenu-wrapper').append(''+
          '<span id="ac-is-arialive" aria-live="polite" class="audible">'+
            $.trim(this.list.find('>li:first-child').text()) +
          '</span>');

        this.noSelect = true;
        this.element.trigger('listopen', [items]);
      },

      closeList: function(dontClosePopup) {
        var popup = this.element.data('popupmenu');
        if (!popup) {
          return;
        }

        if (!dontClosePopup) {
          popup.close();
        }

        this.element.trigger('listclose');
        $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
        $('#autocomplete-list').remove();
        this.element.removeClass('is-open');
      },

      listIsOpen: function() {
        return this.list instanceof $ && this.list.length && this.list.is(':visible');
      },

      // Handles the Autocomplete's "keydown" event
      handleAutocompleteKeydown: function(e) {
        var self = this;

        if (this.isLoading()) {
          e.preventDefault();
          return false;
        }

        if (!this.listIsOpen()) {
          return;
        }

        function getHighlighted(items) {
          return items.filter('.is-selected');
        }

        function unhighlight(item) {
          item.removeClass('is-selected is-focused');
        }

        function highlight(item) {
          item.addClass('is-selected').find('a').focus();
        }

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
          items = this.list.find(excludes),
          highlighted = getHighlighted(items);

        //Down - select next
        if (e.keyCode === 40 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) + 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Up select prev
        if (e.keyCode === 38 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) - 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Enter/Tab - apply selected item
        if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
          //Apply selection if an item is selected, otherwise close list and allow default tab/enter behavior to happen
          if (highlighted.length) {
            e.stopPropagation();
            e.preventDefault();
            self.noSelect = true;
            self.select(highlighted, this.currentDataSet);
          } else {
            self.closeList();
          }
        }

        if (e.keyCode === 8 && this.listIsOpen()) {
          self.element.trigger('input');
        }
      },

      // Handles the Autocomplete's "input" event
      handleAutocompleteInput: function(e) {
        var self = this;

        if (self.isLoading()) {
          e.preventDefault();
          return false;
        }

        // Makes a new AJAX call every time a key is pressed.
        var waitForSource = this.getDataFromSource();
        waitForSource.done(function doneHandler(term, response) {
          self.currentDataSet = response;
          self.openList(term, response);
        });
      },

      /**
       * Check to see whether or not the currently-focused element resides within the Autocomplete's field
       * or list, and if not, fires a "safe-blur" event on the element.
       *
       * @private
       * @param {Object} e - The event object passed in from the jQuery `.on()` listener.
       */
      checkActiveElement: function() {
        var self = this;
        setTimeout( function() {
          var activeElem = document.activeElement;

          if ((self.listIsOpen() && $.contains(self.list[0], activeElem)) || self.element.is(activeElem)) {
            return;
          }

          self.element.trigger('safe-blur');
        }, 0);
      },

      getDataFromSource: function() {
        var self = this;

        // Don't attempt to load if we're already loading.
        if (self.isLoading()) {
          return false;
        }

        var field = this.element,
          dfd = $.Deferred(),
          buffer;

        clearTimeout(this.loadingTimeout);

        function done(searchTerm, response, deferredStatus) {
          self.element.triggerHandler('complete'); // For Busy Indicator
          self.element.trigger('requestend', [searchTerm, response]);

          if (deferredStatus === false) {
            return dfd.reject(searchTerm);
          }
          return dfd.resolve(searchTerm, response);
        }

        this.loadingTimeout = setTimeout(function () {
          if (self.isLoading()) {
            return;
          }

          buffer = field.val();
          if (buffer === '') {
            if (self.element.data('popupmenu')) {
              self.element.data('popupmenu').close();
            }
            return;
          }
          buffer = buffer;

          var sourceType = typeof self.settings.source;
          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart', [buffer]);

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            self.settings.source(buffer, done, self.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
            done(buffer, sourceData, true);
          } else if (!self.settings.source) {
            dfd.reject(buffer);
            return;
          } else {

            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = self.settings.source.toString(),
              request = $.getJSON(sourceURL + buffer);

            request.done(function(data) {
              done(buffer, data, true);
            }).fail(function() {
              done(buffer, [], false);
            });
          }

        }, self.settings.delay);

        return dfd;
      },

      // Handles the Autocomplete's "focus" event
      handleAutocompleteFocus: function() {
        var self = this;
        if (this.noSelect) {
          this.noSelect = false;
          return;
        }

        //select all
        setTimeout(function () {
          self.element.select();
        }, 10);
      },

      highlight: function(anchor, allAnchors) {
        var text = anchor.text().trim();

        if (anchor.find('.display-value').length > 0) {
          text = anchor.find('.display-value').text().trim();
        }

        if (allAnchors && allAnchors.length) {
          allAnchors.parent('li').removeClass('is-selected');
        }
        anchor.parent('li').addClass('is-selected');

        this.noSelect = true;
        this.element.val(text).focus();
      },

      select: function(anchorOrEvent, items) {
        var a, li, ret, dataIndex, dataValue,
          isEvent = false;

        // Initial Values
        if (anchorOrEvent instanceof $.Event) {
          isEvent = true;
          a = $(anchorOrEvent.currentTarget);
        } else {
          a = anchorOrEvent;
        }

        if (a.is('li')) {
          li = a;
          a = a.children('a');
        }

        li = a.parent('li');
        ret = a.text().trim();
        dataIndex = li.attr('data-index');
        dataValue = li.attr('data-value');

        this.element.attr('aria-activedescendant', li.attr('id'));

        if (items && items.length) {
          // If the data-index attr is supplied, use it to get the item (since two items could have same value)
          if (dataIndex) {
            ret = items[parseInt(dataIndex, 10)];
          } else if (dataValue) {
            // Otherwise use data-value to get the item (a custom template may not supply data-index)
            for (var i = 0, value; i < items.length; i++) {
              value = items[i].value.toString();
              if (value === dataValue) {
                ret = items[i];
              }
            }
          }
        }

        this.closeList();
        this.highlight(a);

        this.noSelect = true;
        this.element
          .trigger('selected', [a, ret])
          .focus();

        if (isEvent) {
          anchorOrEvent.preventDefault();
        }

        return false;
      },

      updated: function() {
        this.teardown().init();
        return this;
      },

      /**
      * Enable the input from readonly or disabled state.
      */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
      * Disable the input from editing
      */
      disable: function() {
        this.element.prop('disabled', true);
      },

      teardown: function(){
        var popup = this.element.data('popupmenu');
        if (popup) {
          popup.destroy();
        }

        this.element.off('keypress.autocomplete focus.autocomplete requestend.autocomplete updated.autocomplete');
        return this;
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} listopen  &nbsp;-&nbsp; Fires when the menu is opened.
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires when the menu is closed.
       * @param {Object} populated  &nbsp;-&nbsp; Fires after the menu is populated with its contents.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the input is edited.
       * @param {Object} safe-blur  &nbsp;-&nbsp; Fires after the input (and menu) both loose focus
       * @param {Object} requestend  &nbsp;-&nbsp; Fires when the ajax request (source option) is completed
       * @param {Object} requeststart  &nbsp;-&nbsp; Fires when the ajax request (source option) is initiated
       */
      handleEvents: function () {
        //similar code as dropdown but close enough to be dry
        var self = this;

        this.element.off('updated.autocomplete').on('updated.autocomplete', function() {
          self.updated();
        }).off('keydown.autocomplete').on('keydown.autocomplete', function(e) {
          self.handleAutocompleteKeydown(e);
        }).off('input.autocomplete').on('input.autocomplete', function (e) {
          self.handleAutocompleteInput(e);
        }).off('focus.autocomplete').on('focus.autocomplete', function () {
          self.handleAutocompleteFocus();
        }).off('focusout.autocomplete').on('focusout.autocomplete', function () {
          self.checkActiveElement();
        });
      }

    };

    // Initialize Once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Autocomplete(this, settings));
      } else {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      }
    });
  };


  $.fn.busyindicator = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'busyindicator',
        defaults = {
          blockUI: true,
          text: null,
          displayDelay: 1000,
          timeToComplete: 0,
          transparentOverlay: false,
          overlayOnly: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * A Busy Indicator notifies the user that the system is processing a request, and that they must wait for that request to be processed before continuing with the current task.
    *
    * @class BusyIndicator
    * @param {String} blockUI  &nbsp;-&nbsp; makes the element that Busy Indicator is invoked on unusable while it's displayed.
    * @param {String} text  &nbsp;-&nbsp; Custom Text To Show or Will Show Localized Loading....
    * @param {String} displayDelay  &nbsp;-&nbsp; umber in miliseconds to pass before the markup is displayed.  If 0, displays immediately.
    * @param {Boolean} timeToComplete  &nbsp;-&nbsp; fires the 'complete' trigger at a certain timing interval.  If 0, goes indefinitely.
    * @param {String} transparentOverlay  &nbsp;-&nbsp; If true, allows the "blockUI" setting to display an overlay that prevents interaction, but appears transparent instead of gray.
    *
    */
    function BusyIndicator(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    BusyIndicator.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        this
          .setup()
          .handleEvents();
      },

      // Sanitize incoming option values
      setup: function() {
        var blockUI = this.element.attr('data-block-ui'),
          delay = this.element.attr('data-display-delay'),
          completionTime = this.element.attr('data-completion-time');

        this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;
        if (!this.settings.overlayOnly) {
          this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading');
        }
        this.delay = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20 ? delay : !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;
        this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;

        return this;
      },

      /**
      * Builds and starts the indicator
      */
      activate: function() {
        var self = this;

        // If the markup already exists don't do anything but clear
        if (this.container) {
          if (self.closeTimeout) {
            clearTimeout(self.closeTimeout);
          }
          this.label.remove();
          if (!this.settings.overlayOnly) {
            this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);

            if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
              this.label.addClass('audible');
            }
          }

          this.container
            .removeClass('is-hidden')
            .trigger('afterstart');
          return;
        }

        // Build all the markup
        this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
          'aria-live': 'polite',
          'role': 'status'
        });
        this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

        if (!this.settings.overlayOnly) {
          $('<div class="bar one"></div>' +
            '<div class="bar two"></div>' +
            '<div class="bar three"></div>' +
            '<div class="bar four"></div>' +
            '<div class="bar five"></div>').appendTo(this.loader);

          this.label = $('<span>'+ this.loadingText +'</span>').appendTo(this.container);
        }

        var transparency = '';

        if (this.blockUI) {
          if (this.settings.transparentOverlay) {
            transparency = ' transparent';
          }

          this.originalPositionProp = this.element[0].style.position;
          this.element[0].style.position = 'relative';
          this.overlay = $('<div class="overlay busy is-hidden'+ transparency +'"></div>').appendTo(this.element);
          this.container.addClass('blocked-ui');
        }

        if (this.label && this.element.is('.busy-xs, .busy-sm')) {
          this.label.addClass('audible');
        }

        // Append the markup to the page
        // Use special positioning logic for compatibility with certain controls
        if (this.element.is('input, .dropdown, .multiselect')) {
          this.element.addClass('is-loading');
          if (this.blockUI) {
            this.element.addClass('is-blocked');
          }
          if (this.label) {
            this.label.addClass('audible');
          }


          var target;

          if (this.element.is('input')) {
            target = this.element;
            this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
          } else {
            var dd = this.element.data('dropdown');
            target = dd.pseudoElem;
            this.container.appendTo(target.parent());
          }

          if (this.overlay) {
            this.overlay.insertAfter(this.container);
          }

          var rect = target.position(),
            h = target.outerHeight(),
            w = target.outerWidth(),
            elements = this.container.add(this.overlay),
            setCssStyle = function(el, key, value) {
              el.style[key] = value + 'px';
            };

          for (var i = 0, l = elements.length; i < l; i++) {
            setCssStyle(elements[i], 'left', rect.left);
            setCssStyle(elements[i], 'top', rect.top);
            setCssStyle(elements[i], 'bottom', rect.bottom);
            setCssStyle(elements[i], 'right', rect.right);
            setCssStyle(elements[i], 'height', h);
            setCssStyle(elements[i], 'width', w);
          }
        } else {
          // Normal Operations
          this.container.appendTo(this.element);
        }

        // Fade in shortly after adding the markup to the page (prevents the indicator from abruptly showing)
        setTimeout(function() {
          if (self.container) {
            self.container.removeClass('is-hidden');
          }
          if (self.overlay) {
            self.overlay.removeClass('is-hidden');
          }
        }, self.delay);

        // Lets external code know that we've successully kicked off.
        this.element.trigger('afterstart');

        // Start the JS Animation Loop if IE9
        if (!$.fn.cssPropSupport('animation')) {
          self.isAnimating = true;
          self.animateWithJS();
        }

        // Triggers complete if the "timeToComplete" option is set.
        if (this.completionTime > 0) {
          setTimeout(function() {
            self.element.trigger('complete');
          }, self.completionTime);
        }
      },

      /**
      * Removes the appended markup and hides any trace of the indicator
      */
      close: function(fromEvent) {
        var self = this;

        // If closed from an event, fire the necessary event triggers
        // and removes the 'is-loading' CSS class.
        if (fromEvent) {
          this.element.removeClass('is-loading');
          this.element.removeClass('is-blocked');
        }

        if (this.container) {
          this.container.addClass('is-hidden');
        }

        if (this.overlay) {
          this.overlay.addClass('is-hidden');
        }

        // Give the indicator time to fade out before removing all of its components from view
        self.closeTimeout = setTimeout(function() {
          clearTimeout(self.closeTimeout);
          if (self.container) {
            self.container.remove();
          }

          self.container = undefined;
          self.loader = undefined;
          self.label = undefined;

          if (self.overlay) {
            self.overlay.remove();
            self.element[0].style.position = self.originalPositionProp;
            self.originalPositionProp = undefined;
          }
          self.overlay = undefined;
          self.element.trigger('aftercomplete.busyindicator');
          self.element.off('complete.busyindicator');
        }, 600);
      },

      // Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
      animateWithJS: function() {
        var self = this,
          bar1 = this.container.find('.bar.one'),
          bar2 = this.container.find('.bar.two'),
          bar3 = this.container.find('.bar.three'),
          bar4 = this.container.find('.bar.four'),
          bar5 = this.container.find('.bar.five'),
          t = 0,
          interval;

        // Animation Loop
        function animate() {
          if (!self.isAnimating) {
            clearInterval(interval);
            return;
          }

          t += 1;

          if (t === 1) {
            bar1.addClass('half');
          }
          if (t === 13) {
            bar1.removeClass('half').addClass('full');
            bar2.addClass('half');
          }
          if (t === 26) {
            bar1.removeClass('full').addClass('half');
            bar2.removeClass('half').addClass('full');
            bar3.addClass('half');
          }
          if (t === 39) {
            bar1.removeClass('half');
            bar2.removeClass('full').addClass('half');
            bar3.removeClass('half').addClass('full');
            bar4.addClass('half');
          }
          if (t === 51) {
            bar2.removeClass('half');
            bar3.removeClass('full').addClass('half');
            bar4.removeClass('half').addClass('full');
            bar5.addClass('half');
          }
          if (t === 64) {
            bar3.removeClass('half');
            bar4.removeClass('full').addClass('half');
            bar5.removeClass('half').addClass('full');
          }
          if (t === 77) {
            bar4.removeClass('half');
            bar5.removeClass('full').addClass('half');
          }
          if (t === 90) {
            bar5.removeClass('half');
          }

          if (t === 103) {
            t = 0;
          }
        }

        setInterval(animate, 10);
      },

      updated: function() {
        return this.setup();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component listens to the following events.
       *
       * @fires Busyindicator#events
       * @param {Object} start  &nbsp;-&nbsp; Starts / shows the indictor.
       * @param {Object} complete  &nbsp;-&nbsp; Hides / Ends the indictaor
       * @param {Object} updated  &nbsp;-&nbsp; Sync the UI/Settings. Fx chnaging the text in the DOM.
       *
       */
      handleEvents: function() {
        var self = this;
        self.element.on('start.busyindicator', function(e) {
          e.stopPropagation();
          self.activate();
        }).on('afterstart.busyindicator', function() {
          // Complete event is only active once the indicator is "started"
          self.element.on('complete.busyindicator', function(e) {
            e.stopPropagation();
            self.close(true);
          });
        }).on('updated.busyindicator', function() {
          self.close(true);
          self.updated();
        });

        return this;
      },

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new BusyIndicator(this, settings));
      }
    });
  };


  $.fn.button = function(options) {
    'use strict';

    /**
    * Clickable Button Elements.
    *
    * @class Button
    *
    * @param {String} toggleOnIcon  &nbsp;-&nbsp; The icon to use for on state on toggle buttons
    * @param {String} toggleOffIcon  &nbsp;-&nbsp; The icon to use for off state on toggle buttons
    *
    */
    var pluginName = 'button',
      defaults = {
        toggleOnIcon: null,
        toggleOffIcon: null
      },
      settings = $.extend({}, defaults, options);

    function Button(element) {
      this.element = $(element);
      this.settings = $.extend({}, settings);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Button.prototype = {
      init: function() {
        var self = this;

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isSafari = $('html').is('.is-safari');
        this.isFirefox = $('html').is('.is-firefox');

        if (this.element.hasClass('no-ripple')) {
          return;
        }

        if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
          var ddIcon = this.element.children('svg.icon'),
              use = ddIcon.find('use'), hasIcon = false;

          if (ddIcon.length > 0 && use.length === 1) {
            hasIcon = use.attr('xlink:href').indexOf('#icon-dropdown') > -1;
          }

          if (!hasIcon) {
            ddIcon = $.createIconElement({ icon: 'dropdown', classes: ['icon-dropdown']});
            this.element.append(ddIcon);
          }

          if (!ddIcon.hasClass('icon-dropdown')) {
            ddIcon.addClass('icon-dropdown');
          }
        }

        if (this.element.hasClass('btn-toggle') || this.element.hasClass('icon-favorite')) {
          this.element.on('click.favorite', function() {
            var elem = $(this),
              svg = elem.find('svg:not(.ripple-effect)'),
              isPressed = elem.attr('aria-pressed') === 'true';

            elem.attr('aria-pressed', isPressed ? 'false' : 'true');
            if (self.settings.toggleOffIcon && self.settings.toggleOnIcon) {
              svg.changeIcon(isPressed ? self.settings.toggleOffIcon : self.settings.toggleOnIcon);
            } else {
              elem.toggleClass('is-pressed');
            }

            if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle') && svg.find('use').attr('xlink:href') === '#icon-star-filled') {
              svg.changeIcon('star-outlined');
            } else if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle')) {
              svg.changeIcon('star-filled');
            }

          });

          if (!this.element.attr('aria-pressed')) {
            this.element.attr('aria-pressed', 'false');
          }

        }

        if (!this.element.parent().is('.field') && this.element.hasClass('btn-actions') && !this.element.data('tooltip')) {
          this.element.attr('title', Locale.translate('More')).tooltip({
            content: Locale.translate('More')
          });
        }

        this.element.hideFocus();

        this.element
        .on('touchstart.button click.button', function (e) {

          if ((self.element.attr('disabled')) || self.element.is('.is-disabled') || (!self.isTouch && e.which !== 1) ||
              ($('.ripple-effect', this).length) || (self.isTouch && e.type !== 'touchstart')) {
            return;
          }

          var element = $(this),
            btnOffset = element.offset(),
            xPos = e.pageX - btnOffset.left,
            yPos = e.pageY - btnOffset.top,
            ripple = $('<svg class="ripple-effect" focusable="false" aria-hidden="true" role="presentation"><circle r="0" class="ripple-circle"></circle></svg>');


          if (self.isTouch) {
            // Make sure the user is using only one finger and then get the touch position relative to the ripple wrapper
            e = e.originalEvent;
            if (e && e.touches && e.touches.length === 1) {
              xPos = e.touches[0].pageX - btnOffset.left;
              yPos = e.touches[0].pageY - btnOffset.top;
            }
          }

          // Using keyboard to click
          xPos = (xPos < 0) ? self.element.outerWidth()/2 : xPos;
          yPos = (yPos < 0) ? self.element.outerHeight()/2 : yPos;

          $('svg.ripple-effect', element).remove();
          ripple[0].style.left = xPos + 'px';
          ripple[0].style.top = yPos + 'px';
          element.prepend(ripple);

          // Start the JS Animation Loop if IE9
          // Or Safari/Firefox has bug with combination like: animation, overflow, position, border-radius etc.)
          if (!$.fn.cssPropSupport('animation') || self.isSafari || self.isFirefox) {
            ripple.removeClass('is-animation');
            self.animateWithJS(ripple);
          } else {
            var elem = $('svg.ripple-effect', element);
            elem.attr('class', elem.attr('class') + ' is-animation');
          }

          setTimeout(function() {
            ripple.remove();
          }, 1000);

        });
      },

      // Browsers that don't support CSS-based animation can still show the animation
      animateWithJS: function(el) {
        var scale = 200,
        elStyle = el[0].style,
        xPos = (parseFloat(elStyle.left) - (scale / 2)) + 'px',
        yPos = (parseFloat(elStyle.top)  - (scale / 2)) + 'px';

        el[0].style.opacity = '0.4';
        el.animate({
          opacity: 0,
          left: xPos,
          top: yPos,
          width: scale,
          height: scale
        }, 1000);
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('click.button touchstart.button focusin.hide-focus focusout.hide-focus mousedown.hide-focus touchstart.hide-focus');

        var moreTooltip = this.element.data('tooltip');
        if (this.element.hasClass('btn-actions') && moreTooltip) {
          moreTooltip.destroy();
        }

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} click  &nbsp;-&nbsp; Fires when the button is clicked (if enabled).
       * @param {Object} focus  &nbsp;-&nbsp; Fires when the menu is focused.
       */
      handleEvents: function () {
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Button(this));
      }
    });
  };

/**
* @constructor
*/

window.Chart = function(container) {
  'use strict';

  var charts = this;

  //IE8 and Below Message
  if (typeof d3 === 'undefined') {
    $(container).append('<p class="chart-message"></p>');
    return null;
  }

  var colorRange = ['#1D5F8A', '#8ED1C6', '#9279A6', '#5C5C5C', '#F2BC41', '#66A140', '#AD4242',
   '#8DC9E6', '#EFA836', '#317C73', '#EB9D9D', '#999999', '#488421', '#C7B4DB',
   '#54A1D3', '#6e5282', '#AFDC91', '#69ADA3', '#DB7726', '#D8D8D8'];

  this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  this.pieColors = d3.scale.ordinal().range(colorRange);
  this.colorRange = colorRange;
  this.greyColors = d3.scale.ordinal().range(['#737373', '#999999', '#bdbdbd', '#d8d8d8']);
  this.sparklineColors = d3.scale.ordinal().range(['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']);
  this.colors = d3.scale.ordinal().range(colorRange);

  this.chartColor = function(i, chartType, data) {
    var specColor = (data && data.color ? data.color : null);

    //error, alert, alertYellow, good, neutral or hex
    if (specColor) {
      if (specColor ==='error' ) {
        return '#e84f4f';
      }
      if (specColor ==='alert' ) {
        return '#ff9426';
      }
      if (specColor ==='alertYellow' ) {
        return '#ffd726';
      }
      if (specColor ==='good' ) {
        return '#80ce4d';
      }
      if (specColor ==='neutral' ) {
        return '#bdbdbd';
      }
      if (specColor && specColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    if (chartType === 'pie' || chartType === 'donut') {
      return this.colorRange[i];
    }
    if (chartType === 'bar-single' || chartType === 'column-single') {
      return '#1D5F8A';
    }
    if (chartType === 'bar' || chartType === 'line') {
      return this.colors(i);
    }
  };

  // Help Function to Select from legend click
  this.selectElem = function (line, series) {
    var idx = $(line).index(),
      elem = series[idx],
      s = charts.settings,
      selector;

    if (s.chartType === 'Pie') {
      selector = d3.select(s.svg.selectAll('.arc')[0][idx]);
    }
    else if (s.type === 'column-positive-negative') {
      if (!elem.option || (elem.option && elem.option === 'target')) {
        return;
      }
      selector = s.svg.select('.bar.'+ elem.option);
    }
    else if (['Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      // Grouped or singlular
      if (s.isGrouped || s.isSingular) {
        selector = s.svg.select('.series-'+ idx);
      }
      // Stacked
      else if (s.isStacked && !s.isSingular) {
        var thisGroup = d3.select(s.svg.selectAll(s.chartType==='HorizontalBar' ? '.series-group' : '.g')[0][idx]);
        selector = thisGroup.select('.bar');
      }
    }

    if (['Pie', 'Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      s.isByLegends = true;
      selector.on('click').call(selector.node(), selector.datum(), idx);
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj[0][idx]), elem.selectionInverse, elem.data);
    }
  };

  this.addLegend = function(series, chartType) {
    var i, s = charts.settings;

    if (series.length === 0) {
      return;
    }
    var isTwoColumn = series[0].display && series[0].display === 'twocolumn',
      legend = isTwoColumn ? $('<div class="chart-legend" style="margin: 2em auto auto; border-top: 1px solid #ccc;  padding-bottom: 1em; padding-top: 1em;"></div>') : $('<div class="chart-legend"></div>');

    // Legend width
    var width = 0,
      currentWidth,
      widthPercent;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name.length * 6;
      width = (series[i].name && currentWidth > width) ? currentWidth : width;
    }

    width += 55;
    widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      if (!series[i].name) {
        continue;
      }

      var extraClass = '';
      if (isTwoColumn || (series[i].display && series[i].display === 'block')) {
        extraClass += ' lg';
      }
      if (s.type === 'column-positive-negative' && series[i].option) {
        extraClass += ' '+ series[i].option;
      }

      var seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0"></span>',
        hexColor = charts.chartColor(i, chartType ? chartType : (series.length === 1 ? 'bar-single' : 'bar'), series[i]);

      var color = $('<span class="chart-legend-color" style="background-color: '+ (series[i].pattern ? 'transparent' : hexColor) +'"></span>'),
        textBlock = $('<span class="chart-legend-item-text">'+ series[i].name + '</span>');

      if (series[i].pattern) {
        color.append('<svg width="12" height="12"><rect style="fill: '+ hexColor +'" mask="url(#'+ series[i].pattern +')" height="12" width="12" /></svg>');
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display==='block') {
        seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
      }

      if (isTwoColumn) {
        if(widthPercent > 45) {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
        } else {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: inline-block; width: 45%;"></span>';
        }
      }
      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);
      legend.append(seriesLine);
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
          charts.selectElem(this, series);
        }).on('keypress.chart', '.chart-legend-item', function (e) {
          if (e.which === 13 || e.which === 32) {
            charts.selectElem(this, series);
          }
        });

      $(container).append(legend);
    }
  };

  this.renderLegend = function() {
    if (charts.legendformatter && typeof charts.legendformatter === 'function') {
      var markup = '';
      var runInterval = true,
      legendInterval = setInterval(function () {
        if(runInterval) {
          runInterval = false;
          charts.legendformatter(function (data) {
            markup = data;
          });
        }
        if(markup !== '') {
          clearInterval(legendInterval);
          $(container).append(markup);
        }
      }, 10);
    }
  };

  //Add Toolbar to the page
  this.appendTooltip = function() {
    this.tooltip = $('#svg-tooltip');
    if (this.tooltip.length === 0) {
      this.tooltip = $('<div id="svg-tooltip" class="tooltip right is-hidden"><div class="arrow"></div><div class="tooltip-content"><p><b>32</b> Element</p></div></div>').appendTo('body');
      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          charts.hideTooltip();
        });
      }
    }
  };

  this.triggerContextMenu = function(elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();

    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };

  //Show Tooltip
  this.showTooltip = function(x, y, content, arrow) {
    //Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = x + 'px';
    this.tooltip[0].style.top = y + 'px';
    this.tooltip.find('.tooltip-content').html(content);

    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.removeClass('is-hidden');
  };

  this.getTooltipSize = function(content) {
    this.tooltip.find('.tooltip-content').html(content);
    return {height: this.tooltip.outerHeight(), width: this.tooltip.outerWidth()};
  };

  //Hide Tooltip
  this.hideTooltip = function() {
    d3.select('#svg-tooltip').classed('is-hidden', true).style('left', '-999px');
  };

  //Format Currency
  this.formatCurrency = function(num) {
    var symbol = (Locale.currentLocale.data ? Locale.currentLocale.data.currencySign : '$');
    num = (isNaN(num * 1)) ? 0 : num;
    return symbol + (num * 1).toFixed(2);
  };

  this.HorizontalBar = function(chartData, isNormalized, isStacked) {
    //Original http://jsfiddle.net/datashaman/rBfy5/2/

    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var dataset, maxTextWidth, width, height, series, rects, svg, stack, xMin, xMax,
        xScale, yScale, yAxis, yMap, xAxis, groups, isGrouped, isSingle, legendMap,
        gindex, totalBarsInGroup, totalGroupArea, totalHeight, gap, barHeight;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var maxBarHeight = 30,
      legendHeight = 40,
      gapBetweenGroups = 0.5; // As of one bar height (barHeight * 0.5)

    isStacked = isStacked === undefined ? true : isStacked;

    var isViewSmall = $(container).parent().width() < 450;

    var margins = {
      top: isStacked ? 30 : 20,
      left: 30,
      right: 30,
      bottom: 30 // 30px plus size of the bottom axis (20)
    };

    dataset = chartData;
    $(container).addClass('chart-vertical-bar');

    width =  parseInt($(container).parent().width()) - margins.left - margins.right;
    height =  parseInt($(container).parent().height()) - margins.top - margins.bottom - legendHeight;  //influences the bar width

    //Get the Legend Series'
    series = dataset.map(function (d) {
      return {name: d.name, color: d.color, pattern: d.pattern};
    });

    //Map the Data Sets and Stack them.
    dataset = dataset.map(function (d) {
      return d.data.map(function (o) {
        return $.extend({}, o, {
            y: o.value,
            x: o.name,
            color: o.color,
            pattern: o.pattern
        });
      });
    });
    stack = d3.layout.stack();
    stack(dataset);

    //Calculate max text width
    maxTextWidth = 0;
    dataset = dataset.map(function (group, i) {
      if (!isStacked) {
        if (series[i]) {
          maxTextWidth = (series[i].name.length > maxTextWidth ? series[i].name.length : maxTextWidth);
        }
      }
      return group.map(function (d) {
        if(isStacked) {
          maxTextWidth = (d.x.length > maxTextWidth ? d.x.length : maxTextWidth);
        }

        // Invert the x and y values, and y0 becomes x0
        return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
        });

      });
    });

    var h = parseInt($(container).parent().height()) - margins.bottom - (isStacked ? 0 : (legendHeight / 2)),
      w = parseInt($(container).parent().width()) - margins.left,
      textWidth = margins.left + (maxTextWidth * 6);

    svg = d3.select(container)
      .append('svg')
      .attr('width',  w)
      .attr('height', h)
      .append('g')
      .attr('class', 'group')
      .attr('transform', 'translate(' + (textWidth) + ',' + margins.top + ')');

    xMin = d3.min(dataset, function (group) {
      return d3.min(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    xMax = d3.max(dataset, function (group) {
      return d3.max(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    if (isStacked && isNormalized) {
      var gMax = [];
      //get the max for each array group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
        gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d.x;
       });
      });

      //Normalize Each Group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
          var xDif = gMax[i]/100;
          d.x = d.x / xDif;
          d.x0 = d.x0 / xDif;
       });
      });
      xMax = 100;
    }

    //Width of the bar minus the margin
    var barWith = w - textWidth - margins.left;

    if (settings.useLogScale) {
      xScale = d3.scale.log()
        .domain([(xMin > 0 ? xMin : 1), xMax])
        .nice()
        .range([1, barWith]).nice();

    } else {
      xScale = d3.scale.linear()
        .domain([(xMin < 0 ? xMin : 0), xMax])
        .nice()
        .range([0, barWith]).nice();
    }

    if (isStacked) {
      yMap = dataset[0].map(function (d) {
        return d.y;
      });

      barHeight = 0.32;
    } else {
      yMap = series.map(function (d) {
        return d.name;
      });

      (function() {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].map(function (d) {
            return d;
          });
          $.extend(true, legendMap, lm);
          // Convert back to array from object
          legendMap = $.map(legendMap, function(d) {
            return d;
          });
        }
      })();

      gindex = 0;
      totalBarsInGroup = legendMap.length;
      totalGroupArea = height / yMap.length;
      barHeight = totalGroupArea / totalBarsInGroup;
      totalHeight = totalBarsInGroup > 1 ?
        totalGroupArea - (barHeight * gapBetweenGroups) : maxBarHeight;
      gap = totalGroupArea - totalHeight;
      maxBarHeight = totalHeight / totalBarsInGroup;
      barHeight = 0;
    }

    yScale = d3.scale.ordinal()
      .domain(yMap)
      .rangeRoundBands([0, height], barHeight, barHeight);

    xAxis = d3.svg.axis()
      .scale(xScale)
      .tickSize(-height)
      .orient('middle');

    if (isViewSmall) {
      xAxis.ticks(textWidth < 100 ? 5 : 3);
    }

    if (isStacked && isNormalized) {
      xAxis.tickFormat(function(d) { return d + '%'; });
    }

    if (settings.useLogScale) {
      xAxis.ticks(10, ',.1s');

      if (settings.showLines === false) {
        xAxis.tickSize(0);
      }
    }

    if (settings.ticks) {
      xAxis.ticks(settings.ticks.number, settings.ticks.format);
    }

    yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(0)
      .orient('left');

    svg.append('g')
      .attr('class', 'axis x')
      .attr('transform', 'translate(0,' + height + ')')
      .call(xAxis);

    svg.append('g')
      .attr('class', 'axis y')
      .call(yAxis);

    groups = svg.selectAll('g.group')
      .data(dataset)
      .enter()
      .append('g')
      .attr('class', 'series-group')
      .attr('data-group-id', function (d, i) {
        return i;
      });

    isGrouped = (svg.selectAll('.series-group')[0].length > 1 && !isStacked);
    isSingle = (svg.selectAll('.series-group')[0].length === 1 && isStacked);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'HorizontalBar',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked
    });

    rects = groups.selectAll('rect')
      .data(function (d, i) {
        d.forEach(function(d) {
          d.index = i;

          if(!isStacked) {
            d.gindex = gindex++;
          }

        });
        return d;
    })
    .enter()
    .append('rect')
    .attr('class', function(d, i) {
      return 'bar series-'+ i;
    })
    .style('fill', function(d, i) {
      return isStacked ?
        (series.length === 1 ? (charts.chartColor(i, 'bar-single', d)) :
          (charts.chartColor(d.index, 'bar', series[d.index]))) :
        (charts.chartColor(i, 'bar', legendMap[i]));
    })
    .attr('mask', function (d, i) {
      if (dataset.length === 1 && dataset[0][i].pattern) {
        return 'url(#'+ dataset[0][i].pattern +')';
      }
      else if (isStacked && series[d.index].pattern) {
        return 'url(#'+ series[d.index].pattern +')';
      }
      else if (!isStacked && legendMap[i].pattern) {
        return 'url(#'+ legendMap[i].pattern +')';
      }
    })
    .attr('x', function (d) {
      if (settings.useLogScale) {
        return 0;
      }
      return (isStacked && !isSingle) ? xScale(d.x0) : xScale(0);
    })
    .attr('y', function (d) {
      return isStacked ? yScale(d.y) :
        ((((totalGroupArea - totalHeight) / 2) + (d.gindex * maxBarHeight)) + (d.index * gap));
    })
    .attr('height', function () {
      return isStacked ? (yScale.rangeBand()) : maxBarHeight;
    })
    .attr('width', 0) //Animated in later
    .on('mouseenter', function (d, i) {
      var j, l, hexColor,
        total = 0,
        totals = [],
        content = '',
        data = d3.select(this.parentNode).datum(),
        mid = Math.round(data.length/2),
        shape = d3.select(this),
        setPattern = function(pattern, hexColor) {
          return !pattern || !hexColor ? '' :
            '<svg width="12" height="12">'+
              '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
            '</svg>';
        },

        show = function(xPosS, yPosS, isTooltipBottom) {
          var size = charts.getTooltipSize(content),
            x = xPosS+(parseFloat(shape.attr('width'))/2)-(size.width/2),
            y = isTooltipBottom ? yPosS : (yPosS-size.height-13);

          if(content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

       if (dataset.length === 1) {
          content = '<p><b>'+ d.y +' </b>'+ d.x +'</p>';
        }
        else {
          content = '<div class="chart-swatch">';

          if (isStacked) {
            for (j=0,l=dataset.length; j<l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);
              for (var k=0,kl=dataset.length; k<kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(series[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ series[j].name +'</span><b> '+ (isFormatter ? format(totals[j]) : (Math.round((totals[j]/total)*100)+'%')) +' </b>'+
                '</div>';
            }

          }
          else {
            if(mid > 1) {
              shape = d3.select(this.parentNode).select('.series-' + mid);
            }
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (legendMap[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(legendMap[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
          }
          content += '</div>';
        }

        if (total > 0) {
          content = '<span class="chart-tooltip-total"><b>' + total + '</b> '+Locale.translate('Total')+'</span>' +content;
        }

        var yPosS = shape[0][0].getBoundingClientRect().top + $(window).scrollTop(),
            xPosS = shape[0][0].getBoundingClientRect().left + $(window).scrollLeft();

        var maxBarsForTopTooltip = 6,
          isTooltipBottom = (!isStacked && (data.length > maxBarsForTopTooltip));

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function() {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCache[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show(xPosS, yPosS, isTooltipBottom);
              }
            }, 10);
          } else {
            content = tooltipDataCache[i] || tooltipData || d.tooltip || content || '';
            show(xPosS, yPosS, isTooltipBottom);
          }
    })
    .on('mouseleave', function () {
      clearInterval(tooltipInterval);
      charts.hideTooltip();
    })
    .on('click', function (d, i) {
      var isSelected = this && d3.select(this).classed('is-selected'),
        thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

      charts.setSelectedElement({
        task: (isSelected ? 'unselected' : 'selected'),
        container: container,
        selector: this,
        isTrigger: !isSelected,
        triggerGroup: isGrouped,
        d: d,
        i: i
      });

      if (isSelected) {
        $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
      }
      return;
    });

    //Adjust the labels
    svg.selectAll('.axis.y text').attr({'x': charts.isRTL ? 15 : -15});
    svg.selectAll('.axis.x text').attr('class', function(d) {
      return d < 0 ? 'negative-value' : 'positive-value';
    });

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    if (isViewSmall && settings.useLogScale) {
      var ticks = d3.selectAll('.x .tick text'),
        foundMid = false;

      //At small breakpoint hide the last ones
      ticks.attr('class', function(d, i){
          var middleTick = Math.round(ticks.size()/2);

          if (i >= middleTick && !foundMid && d.toString().startsWith('1')) {
            foundMid =  true;
            middleTick = d;
          }

          if (i !==0 && i !== ticks.size() -1 && (settings.useLogScale ? d !== middleTick : i !== middleTick )) {
            d3.select(this).remove();
          }
      });
    }

    //Animate the Bars In
    svg.selectAll('.bar')
      .transition().duration(1000)
      .attr('width', function (d) {
        var scale = xScale(d.x),
          scale0 = xScale(0);

        if (isNaN(scale)) {
          scale = 0;
        }

        if (isNaN(scale0)) {
          scale0 = 0;
        }

        return Math.abs(scale - scale0);
      })
      .attr('x', function (d) {
        if (settings.useLogScale) {
          return 0;
        }
        return (isStacked && !isSingle) ? xScale(d.x0) : (d.x < 0 ? xScale(d.x) : xScale(0));
      });

    //Add Legends
    if (charts.showLegend) {
      charts.addLegend(isStacked ? series : legendMap);
    }
    charts.appendTooltip();

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if (d.selected && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingle)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };


  this.Pie = function(initialData, isDonut, options) {
    var defaults = {
      labels: {
        // true|false
        hideLabels: true,
        isTwoline: true,

        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        contentsTop: 'percentage',
        contentsBottom: 'name',

        // Use d3 Format
        // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
        // [null | formatter string] - Only value will be formated
        formatterTop: null,
        formatterBottom: null,

        // 'default'|'color-as-arc'|'#000000'|'black'
        colorTop: 'color-as-arc',
        colorBottom: 'default',
        lineColor: 'default',
        lineWidth: 2,
        linehideWhenMoreThanPercentage: 10
      }
    },
    settings = $.extend(true, defaults, options),
    lb = settings.labels;

    if (!lb.isTwoline && options && !options.labels.colorTop) {
      lb.colorTop = lb.colorBottom;
    }

    var self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    charts.appendTooltip();

    var showLegend = charts.showLegend || false;

    var chartData = initialData[0].data;
    chartData = chartData.sort(function(a, b) {
      return isRTL ? +b.value - +a.value : +a.value - +b.value;
    });

    var total = d3.sum(chartData, function(d) { return d.value; });

    chartData = chartData.map(function (d) {
      return { data: d, elm: d, name: d.name, color: d.color, value: d.value, percent: d3.round(100*(d.value/total)) };
    });

    if (total === 0) {
      // Handle zero based pies
      chartData.push({data: {}, color: '#BDBDBD', name: 'Empty-Pie', value: 100, percent: 100});
    }

    var svg = d3.select(container).append('svg'),
      arcs = svg.append('g').attr('class','arcs'),
      lines = svg.append('g').attr('class','lines'),
      centerLabel = initialData[0].centerLabel;

    $(container).addClass('chart-pie');

    var pie = d3.layout.pie().value(function (d) {
      return d.value;
    }).sort(null);

    // Store our chart dimensions
    var dims = {
      height: parseInt(parent.height()),  //header + 20 px padding
      width: parseInt(parent.width()),
      widgetheight: 318
    };
    var isSmall = (dims.width < 405);
    dims.height = dims.height > dims.widgetheight ? dims.widgetheight : dims.height;
    dims.height = isSmall && !lb.hideLabels ? dims.width : dims.height;

    var donutWidth = 30;

    dims.outerRadius = ((Math.min(dims.width, dims.height) / 2) - 40);
    dims.innerRadius = isDonut ? dims.outerRadius - (donutWidth + 5) : 0;
    dims.labelRadius = dims.outerRadius + (donutWidth - 10);
    dims.center = { x: (dims.width / 2) + 7, y: dims.height / 2 };

    svg.attr({
      'width': '100%',
      'height': ((isSmall && !lb.hideLabels) || dims.height === dims.widgetheight) ? dims.height - 50 : '100%',
      'viewBox': '0 0 ' + dims.width + ' ' + dims.height
    });

    // move the origin of the group's coordinate space to the center of the SVG element
    arcs.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y  + ')');
    lines.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

    var pieData = pie(chartData);

    // calculate the path information for each wedge
    var pieArcs = d3.svg.arc()
        .innerRadius(dims.innerRadius)
        .outerRadius(dims.outerRadius);

    var pieCircles = d3.svg.arc()
        .innerRadius(dims.outerRadius)
        .outerRadius(dims.outerRadius);

    var pieLabelCircles = d3.svg.arc()
        .innerRadius(dims.labelRadius)
        .outerRadius(dims.labelRadius);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Pie'
    });

    // Draw the arcs.
    var enteringArcs = arcs.selectAll('.arc').data(pieData).enter();
    enteringArcs.append('path')
      .attr('class', 'arc')
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this).select('path')[0][0], d);
      })
      .on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');

        if (isSelected) {
          // Make unselected
          charts.setSelectedElement({
            task: 'unselected',
            container: container,
            selector: '.chart-container .is-selected',
            isTrigger: false,
            d: d.data,
            i: i
          });
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, i]);
        }
        else {
          // Make selected
          charts.setSelectedElement({
            task: 'selected',
            container: container,
            selector: this,
            isTrigger: true,
            d: d.data,
            i: i
          });
        }
      })
      .on('mouseenter', function(d, i) {
        var size, x, y, t, tx, ty,
          offset = parent.offset(),
          content = '',
          show = function() {
            size = charts.getTooltipSize(content);
            x -= size.width/2;
            y -= size.height/2;

            if (content !== '') {
              charts.showTooltip(x, y, content, 'top');
            }
          };

        var circles = svg.selectAll('.pie-circle');
        t = d3.transform(d3.select(circles[0][i]).attr('transform'));
        tx = t.translate[0] + (t.translate[0] > 0 ? 10 * -1: 10 * 1);
        ty = t.translate[1] + (t.translate[1] > 0 ? 10 * -1: 10 * 1);

        //Adjustments
        ty += (t.translate[0] > 0 && t.translate[1] > 0 ? -32 : 0);
        tx += (t.translate[1] > 0 && t.translate[0] < 0 ? 17 : 0);
        ty += (t.translate[1] < 0 && t.translate[0] < 0 ? -17 : 0);
        ty += (t.translate[0] < 0 && t.translate[1] > 0 ? -24 : 0);

        x = tx + offset.left + dims.center.x;
        y = ty + offset.top + dims.center.y;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if(runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }
            if(content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {
          tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
          content = tooltipDataCache[i] || tooltipData || d.data.tooltip || d.data.data.tooltip || '';
          content = content.replace('{{percent}}', d.data.percent + '%');
          content = content.replace('{{value}}', d.value);
          content = content.replace('%percent%', d.data.percent + '%');
          content = content.replace('%value%', d.value);
          show();
        }
      })
      .on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })
      .style('fill', function(d, i) {return charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data); })
      .transition().duration(settings.animate === false ? 0 : 350)
      .attrTween('d', function(d) {
        var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
        return function(t) { d.endAngle = i(t); return pieArcs(d); };
      });

    // Now we'll draw our label lines, etc.
    var textLabels, textX=[], textY=[], textLabelsLength = 0,
      perEvenRound = [], perRound = [], perRoundTotal = 0,

      // http://stackoverflow.com/a/13484393
      // Fix: http://jira/browse/SOHO-4951
      evenRound = function(orig, target) {
        var i = orig.length,
          j = 0,
          total = 0,
          change,
          newVals = [],
          next, factor1,
          factor2,
          len = orig.length,
          marginOfErrors = [],
          errorFactor = function (oldNum, newNum) {
            return Math.abs(oldNum - newNum) / oldNum;
          };

        // map original values to new array
        while (i--) {
          total += newVals[i] = Math.round(orig[i]);
        }

        change = total < target ? 1 : -1;

        while (total !== target) {
          // Iterate through values and select the one that once changed will introduce
          // the least margin of error in terms of itself. e.g. Incrementing 10 by 1
          // would mean an error of 10% in relation to the value itself.
          for (i = 0; i < len; i++) {
            next = i === len - 1 ? 0 : i + 1;
            factor2 = errorFactor(orig[next], newVals[next] + change);
            factor1 = errorFactor(orig[i], newVals[i] + change);

            if (factor1 > factor2) {
              j = next;
            }
          }
          newVals[j] += change;
          total += change;
        }
        for (i = 0; i < len; i++) {
          marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
        }

        // Math.round() causes some problems as it is difficult to know at the beginning
        // whether numbers should have been rounded up or down to reduce total margin of error.
        // This section of code increments and decrements values by 1 to find the number
        // combination with least margin of error.
        for (i = 0; i < len; i++) {
          for (j = 0; j < len; j++) {
            if (j === i) {
              continue;
            }
            var roundUpFactor = errorFactor(orig[i], newVals[i] + 1)  + errorFactor( orig[j], newVals[j] - 1);
            var roundDownFactor = errorFactor(orig[i], newVals[i] - 1) + errorFactor( orig[j], newVals[j] + 1);
            var sumMargin = marginOfErrors[i] + marginOfErrors[j];

            if(roundUpFactor < sumMargin) {
              newVals[i] = newVals[i] + 1;
              newVals[j] = newVals[j] - 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
            if(roundDownFactor < sumMargin) {
              newVals[i] = newVals[i] - 1;
              newVals[j] = newVals[j] + 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
          }
        }
        return newVals;
      },

      setEvenRoundPercentage = function() {

        var arr = [];
        for (var i = 0, l = chartData.length; i < l; i++) {
          var d = chartData[i],
            v = (total === 0 ? 0 : d.value / total),
            f1 = d3.format('0.0%'),
            f2 = d3.format('0.3%'),
            r1 = f1(v),
            r2 = f2(v);
          perRound.push(+(r1.replace('%','')));
          arr.push(+(r2.replace('%','')));
        }

        perEvenRound = evenRound(arr, 100);
        perRoundTotal = perRound.reduce(function(a, b) { return a + b; });
      },

      labelsContextFormatter = function (d, context, formatterString, isShortName, idx) {
        formatterString = /percentage/i.test(context) ? '0.0%' : formatterString;
        var r,
          format = d3.format(formatterString || ''),
          percentage = format(d.value / total),
          name = isShortName ? (d.data.shortName || d.data.name.substring(0, 9) + (d.data.name.length > 9 ? '...' : '')) : d.data.name,
          value = formatterString && formatterString !== '0.0%' ? format(d.value) : d.value;

        if (/percentage/i.test(context) && perRoundTotal !== 100) {
          percentage = perEvenRound[idx] +'%';
        }
        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        switch (context) {
          case 'name': r = name; break;
          case 'value': r = value; break;
          case 'percentage': r = percentage; break;
          case 'name, value': r = name + ', '  + value; break;
          case 'name (value)': r = name + ' (' + value + ')'; break;
          case 'name (percentage)': r = name + ' (' + percentage + ')'; break;
          default: r = name + ', ' + value + ' (' + percentage + ')'; break;
        }
        return r || '';
      },

      labelsColorFormatter = function (d, i, opt) {
        return opt === 'color-as-arc' ? (charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data)) : (opt === 'default' ? '' : opt);
      },

      drawTextlabels = function (isShortName) {
        svg.selectAll('.lb-top').each(function(d, i) {
          var parentX = +d3.select(this.parentNode).attr('x');

          if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
          parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
            isShortName =  true;
          }

          d3.select(this)
            .text(function() {
              return labelsContextFormatter(d, lb.contentsTop, lb.formatterTop, isShortName, i);
            })
            .style({
              'font-weight': lb.isTwoline ? 'normal' : 'normal',
              'font-size': lb.isTwoline ? (dims.width > 450 ? '1.8em' : '1.1em') : '1em',
              'fill': function() {
                var color = labelsColorFormatter(d, i, lb.colorTop);
                color = color === '#bdbdbd' ? '#868686' : color;
                return color;
              }
            });
        });

        if (lb.isTwoline) {
          svg.selectAll('.lb-bottom').each(function(d, i) {
            var parentX = +d3.select(this.parentNode).attr('x');

            if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
            parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
              isShortName =  true;
            }

            d3.select(this)
              .text(function() {
                return labelsContextFormatter(d, lb.contentsBottom, lb.formatterBottom, isShortName);
              })
              .style({
                'font-size': '1em',
                'fill': function() {
                  return labelsColorFormatter(d, i, lb.colorBottom);
                }
              });

              isShortName = null;
          });
        }
      },

      addLabels = function () {

        svg.selectAll('.labels').remove();

        var labels = svg.append('g').attr('class','labels'),
          enteringLabels = labels.selectAll('.label').data(pieData).enter(),
          labelGroups = enteringLabels.append('g').attr('class', 'label');

        labels.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'pie-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieCircles.centroid(d)[0],
                y = pieCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'label-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieLabelCircles.centroid(d)[0],
                y = pieLabelCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        textLabels = labelGroups.append('text').attr({
          'class': 'label-text',
          'x': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius,
              sign = (x > 0) ? 1 : -1,
              labelX = x + (1 * sign);

            textLabelsLength++;
            textX.push(x);
            return labelX;
          },
          'y': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              y = Math.sin(midAngle) * dims.labelRadius;
            textY.push(y);
            return y;
          },
          'text-anchor': function (d) {
            var centroid = pieArcs.centroid(d),
             midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius;

            if (isRTL && charts.isIE) {
              return (x > 0 ? 'start' : 'end');
            }

            return isRTL ? (x > 0 ? 'end' : 'start') : (x > 0 ? 'start' : 'end');
          }
        });

        textLabels.append('tspan').attr('class', 'lb-top');
        if (lb.isTwoline) {
          textLabels.append('tspan')
            .attr({'class': 'lb-bottom',
              'x': function(d, i) {
                  var x = textX[i];
                  return x;
              },
              'dy': '17'
            });
        }

        setEvenRoundPercentage();

        if (lb.hideLabels) {
          drawTextlabels();

          // Add center label only if its donut chart
          if (isDonut) {
            arcs.append('text')
              .attr('dy', '.35em')
              .style('text-anchor', 'middle')
              .attr('class', 'chart-donut-text')
              .html(centerLabel);

            // FIX: IE does not render .html
            if (charts.isIE) {
              if (charts.isHTML(centerLabel)) {
                // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text
                var text  = arcs.select('.chart-donut-text'),
                  tmp = document.createElement('text');
                tmp.innerHTML = centerLabel;
                var nodes = Array.prototype.slice.call(tmp.childNodes);
                nodes.forEach(function(node) {
                  text.append('tspan')
                    .attr('style', node.getAttribute && node.getAttribute('style'))
                    .attr('x', node.getAttribute && node.getAttribute('x'))
                    .attr('dy', node.getAttribute && node.getAttribute('dy'))
                    .text(node.textContent);
                });
              }
              else {
                arcs.select('.chart-donut-text').text(centerLabel);
              }
            }
          }
        }
      };
      addLabels();

      if (lb.hideLabels) {
        var isRunning = true,
          maxRunning = textLabelsLength * 15,
          orgLabelPos,
          spacing = 35;

        // Resolve label positioning collisions

        // Record org x, y position
        orgLabelPos = textLabels[0].map(function(d) {
          d = d3.select(d);
          return { x: +d.attr('x'), y: +d.attr('y') };
        });

        // Fix y position
        var relax = function () {
          var again = false;
          maxRunning--;
          textLabels.each(function (d, i) {
            var a = this,
              da = d3.select(a),
              y1 = +da.attr('y');

            textLabels.each(function (d2, i2) {
              if (i2 > i) {
                var deltaY,
                  b = this,
                  db = d3.select(b),
                  y2 = +db.attr('y');

                if (da.attr('text-anchor') === db.attr('text-anchor') && (a === textLabels[0][i2-1])) {
                  deltaY = Math.round(Math.abs(y1 - y2));
                  if (deltaY < spacing) {
                    deltaY += 1;
                    var newY = y2 > 0 ? y2-(deltaY/2) : y2+(deltaY/2)+1;
                    again = true;
                    db.attr('y', newY); //padding

                    if (Math.round(Math.abs(newY)) < 2) {
                      again = false;
                      newY = y2 > 0 ? y2-(spacing) : y2+(spacing/2);
                      db.attr('y', newY);
                    }
                  }
                }
              }
            });
          });

          if (again && maxRunning > 0) {
            relax();
          } else {
            isRunning = false;
          }
        };

        relax();

        // Draw lines and set short name
        // Fix x position
        var labelCircles = svg.selectAll('.label-circle');
        spacing *=  -1;
        textLabels.each(function(d, i) {
          var x,
            label = d3.select(this),
            x1 = +label.attr('x'),
            y1 = +label.attr('y'),
            sign = (x1 > 0 ? 1 : -1);

            x = isRTL ?
              ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x - (spacing * 1.5))) * sign):
              ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x + (spacing * 1.5))) * sign);

          if (orgLabelPos[i].y !== y1 || (i === 0 && chartData[i].percent < 10)) {
            x += chartData[i].percent <= 10 ? Math.ceil(x1/2) : Math.ceil(x1-x)- (spacing/2);
            label.attr('x', x);

            if (lb.isTwoline) {
              label.select('.lb-bottom').attr('x', x);
            }

            var t = d3.transform(d3.select(labelCircles[0][i]).attr('transform')),
              tx = t.translate[0] + (t.translate[0] > 0 ? 10 : -10);

            if (x < tx || Math.abs(x) > dims.center.x) {
              label.attr('x', tx);
              if (lb.isTwoline) {
                label.select('.lb-bottom').attr('x', tx);
              }
            }
          }
        });

        var lineFunction = d3.svg.line()
          .x(function(d) { return d.x; })
          .y(function(d) { return d.y; })
          .interpolate('basis');

        var labels = svg.selectAll('.label');

        svg.selectAll('.label-text tspan').each(function() {
          if (d3.select(this).text().substring(5) === '...') {
            showLegend = true;
          }
        });

        // Collect source and targets [x, y] position
        labels.each(function(d, i) {
          var label = d3.select(this),
            pieCircle = label.select('.pie-circle'),
            labelCircle = label.select('.label-circle'),
            text = label.select('.label-text'),
            ct = d3.transform(pieCircle.attr('transform')),
            ct2 = d3.transform(labelCircle.attr('transform')),
            points = [
              { x:Number(ct.translate[0]), y:Number(ct.translate[1]) },
              { x:Number(ct2.translate[0]), y:Number(ct2.translate[1]) },
              { x:Number(text.attr('x')), y:Number(text.attr('y')) + (lb.isTwoline ? 5 : 0) }
            ];

          // Draw line from center of arc to label
          if (lb.linehideWhenMoreThanPercentage > chartData[i].percent) {
            lines.append('path')
              .attr({
                'class': 'label-line',
                'd': lineFunction(points)
              })
              .style({
                'stroke-width': lb.lineWidth,
                'stroke': function() { return labelsColorFormatter(d, i, lb.lineColor); }
              });
            }
        });

      } else {
        showLegend = true;
      }

    //Get the Legend Series'
    var series = chartData.map(function (d) {
      var name = d.name +' ('+ (isNaN(d.percent) ? 0 : d.percent) +'%)';

      if (d.name === 'Empty-Pie') {
        name= '';
      }
      return {name: name, display:'twocolumn', color: d.color};

    });

    // Add Legends
    if (showLegend || charts.legendformatter) {
      charts[charts.legendformatter ? 'renderLegend' : 'addLegend'](series, 'donut');
    }

    // Set initial selected
    (function () {
      var selected = 0,
        selector;
      arcs.selectAll('.arc').each(function(d, i) {
        if (!d || !d.data || !d.data.data) {
          return;
        }
        if (d.data.data.selected && selected < 1) {
          selected++;
          selector = d3.select(this);
          selector.on('click').call(selector.node(), selector.datum(), i);
        }
      });
    })();

    if (isRTL && lb.isTwoline) {
      // Fix: incorrect text tspan position when RTL
      // https://connect.microsoft.com/IE/feedback/details/846683
      setTimeout(function() {
        svg.selectAll('.label-text').each(function() {
          var label = d3.select(this),
            parent = d3.select(label.node().parentNode),
            clone = d3.select(parent.node().appendChild(label.node().cloneNode(true)));
          label.select('.lb-bottom').remove();
          clone.select('.lb-top').remove();
        });
      }, 100);
    }

    $(container).trigger('rendered');
    return $(container);
  };

  this.elementTransform = function(options) {
    options.element.attr('transform', function () {
      var el = options.sameAs || this,
        t = d3.transform(d3.select(el).attr('transform')),
        x = t.translate[0],
        y = t.translate[1];

      x = options.addtoX ? (x>0?(x+options.addtoX):(x-options.addtoX)) : x;
      y = options.addtoY ? (y>0?(y+options.addtoY):(y-options.addtoY)) : y;
      return 'translate('+ x +','+ y +')';
    });
  };

  this.moveLabels = function(options) {
    var labelElements = options.textLabels[0];
    if (options.addtoX) {
      options.textLabels.attr('x',function() {
        var x = d3.select(this).attr('x');
        return x > 0 ? (x + options.addtoX) : (x - options.addtoX);
      });
      options.textLines.attr('x2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('x');
      });
    }
    else if (options.addtoY) {
      options.textLabels.attr('y',function() {
        var y = Number(d3.select(this).attr('y'));
        return y > 0 ? (y + options.addtoY) : (y - options.addtoY);
      });
      options.textLines.attr('y2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('y');
      });
    }
  };

  //TODO: Test this with two charts on the page.
  this.handleResize = function () {
    var timeout = null,
      width = 0;

    //Handle Resize / Redraw
    function resizeCharts() {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        var api = $(container).data('chart'),
            cont = $(container);

        if (width === cont.width()) {
          return;
        }

        width = cont.width();

        if (!cont.is(':visible')) {
          return true;
        }
        cont.empty();
        api.initChartType(api.settings);
      }, 100);
    }

    if (this.redrawOnResize) {
      $(window).on('resize.charts', resizeCharts);
      $(container).off('resize').on('resize', resizeCharts);
    }
  };

  // Donut Chart - Same as Pie but inner radius
  this.Ring = function(chartData) {
    return charts.Pie(chartData, true);
  };

  //Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
  this.calculateAspectRatioFit = function (d) {
    var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
    return { width: d.srcWidth*ratio, height: d.srcHeight*ratio };
  };

  // Sparkline Chart
  this.Sparkline = function(chartData, options) {
    var tooltipIntervalMedianRange,
      tooltipIntervalDots,
      tooltipDataCacheMedianRange = [],
      tooltipDataCacheDots = [],
      tooltipData = charts.options.tooltip;

    // calculate max and min values in the NLWest data
    var max=0, min=0, len=0, i,
      dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: $(container).width(),
        maxHeight: 600 //container min-height
      }),
      dotsize = dimensions.width > 300 ? 4 : 3;

    for (i = 0; i < chartData.length; i++) {
      min = d3.min([d3.min(chartData[i].data), min]);
      max = d3.max([d3.max(chartData[i].data), max]);
      len = d3.max([chartData[i].data.length, len]);
    }

    var p = 10,
      w = dimensions.width,
      h = dimensions.height,
      x = d3.scale.linear().domain([0, len]).range([p, w - p]),
      y = d3.scale.linear().domain([min, max]).range([h - p, p]),
      line = d3.svg.line()
                   .x(function(d, i) { return x(i); })
                   .y(function(d) { return y(d); });

    charts.appendTooltip();
    var svg = d3.select(container)
      .append('svg')
      .attr('height', h)
      .attr('width', w);

    //Add Median Range
    //https://www.purplemath.com/modules/meanmode.htm
    if(options.isMedianRange) {
      max = d3.max(chartData[0].data);
      min = d3.min(chartData[0].data);

      var minWidth = 10,
        maxWidth = w-45,
        median = d3.median(chartData[0].data),
        range = max-min,
        scaleMedianRange = d3.scale.linear().domain([min, max]).range([0, h]),
        top = h-scaleMedianRange(median>range ? median : range),
        bot = h-scaleMedianRange(median<range ? median : range);

      svg.append('g')
        .attr('class', 'medianrange')
        .attr('transform', function() {return 'translate('+ minWidth +','+ top +')';})
        .append('rect')
        .attr('width', maxWidth)
        .attr('height', bot)
        .style('fill', '#d8d8d8')
        .on('mouseenter', function(d, i) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name +'<br> ' : '') +
            Locale.translate('Median') + ': <b>'+ median +'</b><br>'+
            Locale.translate('Range') +': <b>'+ range +'</b>'+
            (options.isPeakDot ? '<br>'+Locale.translate('Peak') +': <b>'+ max +'</b>' : '') +'</p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + ((rect.width - size.width)/2),
                y = rect.top - size.height - 5; // 5: extra padding

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheMedianRange[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        })
        .on('mouseleave', function() {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
    }

    for (i = 0; i < chartData.length; i++) {
      var set = chartData[i],
        g = svg.append('g');
        g.append('path')
         .attr('d', line(set.data))
         .attr('stroke', options.isMinMax ? '#999999' : charts.sparklineColors(i))
         .attr('class', 'team');
    }


    //Add Dots (Dots/Peak/MinMAx)
    min = d3.min(chartData[0].data);
      svg.selectAll('.point')
        .data(chartData[0].data)
        .enter()
        .append('circle')
        .attr('r', function(d) {
          return (options.isMinMax && max === d || options.isMinMax && min === d) ? (dotsize+1) :
            (options.isDots || (options.isPeakDot && max === d)) ? dotsize : 0;
        })
        .attr('class', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? 'point peak' :
            (options.isMinMax && max === d) ? 'point max' :
            (options.isMinMax && min === d) ? 'point min' : 'point';
        })
        .style('fill', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? '#ffffff' :
            (options.isMinMax && max === d) ? '#56932E' :
            (options.isMinMax && min === d) ? '#941E1E' : charts.sparklineColors(0);
        })
        .style('stroke', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? charts.sparklineColors(0) :
            (options.isMinMax && max === d) ? 'none' :
            (options.isMinMax && min === d) ? 'none' : '#ffffff';
        })
        .style('cursor', 'pointer')
        .attr('cx', function(d, i) { return x(i); })
        .attr('cy', function(d) { return y(d); })
        .on('mouseenter', function(d) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name + '<br> ' +
              ((options.isMinMax && max === d) ? Locale.translate('Highest') + ': ' :
               (options.isMinMax && min === d) ? Locale.translate('Lowest') + ': ' :
               (options.isPeakDot && max === d) ? Locale.translate('Peak') + ': ' : '') : '') + '<b>' + d  + '</b></p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left - (size.width /2) + 6,
                y = rect.top - size.height - 8;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalDots = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheDots[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalDots);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }

          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+2) : (dotsize+1));
        })
        .on('mouseleave', function(d) {
          clearInterval(tooltipIntervalDots);
          charts.hideTooltip();
          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+1) : dotsize);
        });

    $(container).trigger('rendered');

    return $(container);
  };

  // Column Chart - Sames as bar but reverse axis
  this.Column = function(chartData, isStacked) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var datasetStacked,
      dataset = chartData,
      self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL,
      isPositiveNegative = (charts.settings.type === 'column-positive-negative'),
      isSingular = (dataset.length === 1),
      margin = {top: 40, right: 40, bottom: (isSingular && chartData[0].name === undefined ? (isStacked ? 20 : 50) : 35), left: 45},
      legendHeight = 40,
      width = parent.width() - margin.left - margin.right - 10,
      height = parent.height() - margin.top - margin.bottom - (isSingular && chartData[0].name === undefined ? (isStacked || isPositiveNegative ? (legendHeight - 10) : 0) : legendHeight),
      yMin, yMax, yMinTarget, yMaxTarget, series, seriesStacked,
      pnColors, pnPatterns, pnLegends, pnSeries;

    yMin = d3.min(dataset, function (group) {
      return d3.min(group.data, function (d) {
          return d.value;
      });
    });

    yMax = d3.max(dataset, function (group) {
      return d3.max(group.data, function (d) {
          return d.value;
      });
    });

    if (isPositiveNegative) {
      yMinTarget = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
            return d.target;
        });
      });

      yMaxTarget = d3.max(dataset, function (group) {
        return d3.max(group.data, function (d) {
            return d.target;
        });
      });

      yMin = d3.min([yMin, yMinTarget]);
      yMax = d3.max([yMax, yMaxTarget]);

      pnLegends = {target: 'Target', positive: 'Positive', negative: 'Negative'};
      pnColors = {target: 'neutral', positive: 'good', negative: 'error'};
      pnPatterns = {};

      if (dataset[0]) {
        if (dataset[0].colors) {
          $.extend(true, pnColors, dataset[0].colors);
        }
        if (dataset[0].legends) {
          $.extend(true, pnLegends, dataset[0].legends);
        }
        if (dataset[0].patterns) {
          $.extend(true, pnPatterns, dataset[0].patterns);
        }
      }
      //Converting object into array
      pnSeries = [];
      $.each(pnLegends, function(key, val) {
        pnSeries.push({
          name: val,
          color: pnColors[key],
          pattern: pnPatterns[key],
          option: key
        });
      });
    }

    $(container).addClass('column-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var x0 = d3.scale.ordinal()
      .rangeRoundBands([0, width], 0.1);

    var x1 = d3.scale.ordinal();

    var y = d3.scale.linear()
      .range([height, 0]);

    if (isStacked) {
      //Map the Data Sets and Stack them.
      if (isSingular) {
        datasetStacked = dataset[0].data.map(function (d) {
          return [$.extend({}, d, {
            y: d.value,
            x: d.name,
            color: d.color,
            pattern: d.pattern,
            parentName: d.name,
            tooltip: d.tooltip
          })];
        });
      } else {
        datasetStacked = dataset.map(function (d) {
          return d.data.map(function (o) {
            return $.extend({}, o, {
              y: o.value,
              x: o.name,
              color: o.color,
              pattern: o.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            });
          });
        });
      }

      var stack = d3.layout.stack();
      stack(datasetStacked);

      var xScale = d3.scale.ordinal()
        .domain(d3.range(datasetStacked[0].length))
        .rangeRoundBands([0, width], 0.05);

      var yScale = d3.scale.linear()
        .domain([0,
          d3.max(datasetStacked, function(d) {

            return d3.max(d, function(d) {
              return d.y0 + d.y;
            });
          })
        ])
        .range([0, height]);
    }

    //List the values along the x axis
    var xAxisValues = dataset[0].data.map(function (d) {return d.name;});

    var xAxis = d3.svg.axis()
        .scale(x0)
        .tickSize(0)
        .tickPadding(12)
        .orient('bottom');

    var yAxis = d3.svg.axis()
        .scale(y)
        .tickSize(-width)
        .tickPadding(isRTL ? -12 : 12)
        .tickFormat(d3.format(charts.format || 's'))
        .orient('left');

    var svg = d3.select(container)
      .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
          .attr('transform', 'translate('+ margin.left +','+ margin.top +')');

    // Get the Different Names
    var names = dataset.map(function (d) {
      return d.name;
    });

    //Get the Maxes of each series
    var maxesStacked, maxes = dataset.map(function (d) {
      return d3.max(d.data, function(d){
        return isPositiveNegative ? d.target : d.value;
      });
    });

    if (isStacked) {
      maxesStacked = datasetStacked.map(function (d) {
        return d3.max(d, function(d){ return d.y + d.y0;});
      });
    }

    if (isSingular) {
      names = dataset[0].data.map(function (d) {
        return d.name;
      });
    }

    // Extra ticks
    if (isPositiveNegative) {
      yMin += yMin / y.ticks().length;
      maxes[0] += maxes[0] / y.ticks().length;
    }

    // Set series
    (function() {
      if (isStacked && isSingular) {
        series = dataset[0].data;
      }
      else {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].data.map(function (d) {
            return d;
          });
          $.extend(true, series, lm);
          // Convert back to array from object
          series = $.map(series, function(d) {
            return d;
          });
        }
      }
    })();

    if (isStacked && !isSingular) {
      seriesStacked = names.map(function (d, i) {
        return dataset[i];
      });
    }

    x0.domain(isStacked ? xAxisValues : names);
    x1.domain(xAxisValues).rangeRoundBands([0, (isSingular||isStacked) ? width : x0.rangeBand()]);
    y.domain([(yMin < 0 ? yMin : (charts.settings.minValue || 0)), d3.max(isStacked ? maxesStacked : maxes)]).nice();

    if (!isSingular || (isSingular && !isStacked)) {
      svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + (height + (isPositiveNegative ? 10 : 0)) + ')')
        .call(xAxis);
    }

    svg.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    // Adjust extra(x) space for negative values for RTL
    if (isRTL && yMin < 0) {
      var yMaxLength = 0,
        tempLength;

      svg.selectAll('.axis.y text')
        .attr('class', function(d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = (tempLength > yMaxLength) ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        })
        .attr('x', function(d) {
          return d < 0 ? ((yMaxLength ) * 9) : ((yMaxLength ) * 5);
        });

    }

    //Make an Array of objects with name + array of all values
    var dataArray = [];
    chartData.forEach(function(d) {
      dataArray.push($.extend({}, d, {values: d.data}));
    });

    if (isSingular) {
      dataArray = [];
      names = dataset[0].data.forEach(function (d) {
        dataArray.push(d);
      });
    }

    var bars, targetBars, pnBars,
      barMaxWidth = 35,
      color = function(colorStr) {
        return charts.chartColor(0, '', {'color': colorStr});
      },
      onEndAllTransition = function (transition, callback) {
        var n;
        if (transition.empty()) {
          callback();
        }
        else {
          n = transition.size();
          transition.each('end', function() {
            n--;
            if (n === 0) {
              callback();
            }
          });
        }
      };

    function drawBars(isTargetBars) {
      var bars;
      isTargetBars = isPositiveNegative && isTargetBars;

      // Add the bars - done different depending on if grouped or singlular
      if (isSingular || isPositiveNegative) {
        bars = svg.selectAll('rect' + (isTargetBars ? '.target-bar' : '.bar'))
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('rect')
          .attr('class', function(d, i) {
            var classStr = 'bar series-'+ i;

            if (isPositiveNegative) {
              classStr = (isTargetBars ? ('target-bar series-'+ i) : classStr) +
                (d.value > 0 ? ' positive' : ' negative');
            }
            return classStr;
          })
          .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
          .attr('x', function(d) {
            return isStacked ? xScale(0) : (x1(d.name) + (x1.rangeBand() - barMaxWidth)/2);
          })
          .attr('y', function() {
            return y(0) > height ? height : y(0);
          })
          .attr('height', function() {
            return 0;
          })
          .attr('mask', function (d) {
            return !isPositiveNegative ? null :
              (isTargetBars ? (pnPatterns.target ? 'url(#' + pnPatterns.target + ')' : null) :
                (d.value < 0 ? (pnPatterns.negative ? 'url(#' + pnPatterns.negative + ')' : null) :
                (pnPatterns.positive ? 'url(#' + pnPatterns.positive + ')' : null))
              );
          })
          .style('fill', function(d) {
            return !isPositiveNegative ? null :
              color(isTargetBars ? pnColors.target : (d.value < 0 ? pnColors.negative : pnColors.positive));
          });

        if (isPositiveNegative) {
          var yTextPadding = 12;
          svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext')
            .data(dataArray)
            .enter()
            .append('text')
            .attr('class', function(d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') +
                (d.value > 0 ? ' positive' : ' negative');
            })
            .attr('text-anchor', 'middle')
            .attr('x', function(d) {
              return (x1(d.name) + (x1.rangeBand())/2) * (isRTL ? -1 : 1);
            })
            .attr('y', function(d) {
              return isTargetBars ?
                (y(d.target) - (yTextPadding/2)) : (y(d.value > 0 ? 0 : d.value) + yTextPadding);
            })
            .style('opacity', 0)
            .style('fill', function(d) {
              return isTargetBars ? '' /* color(pnColors.target) */ :
                (d.value < 0 ? color(pnColors.negative) : color(pnColors.positive));
            })
            .style('font-weight', 'bold')
            .text(function(d) {
              return format(isTargetBars ? d.target : d.value);
            });
        }

        bars.transition().duration(1000)
          .call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext')
              .transition().duration(300).style('opacity', 1);
          })
          .attr('y', function(d) {
            var r = isStacked ? (height - yScale(d[0].y) - yScale(d[0].y0)) :
            (d.value < 0 ? y(0) : y(d.value));
            return (isTargetBars ? y(d.target) : (d.value < 0 ? r : (r > (height-3) ? height-2 : r)));
          })
          .attr('height', function(d) {
            var r;
            if (isStacked) {
              r = yScale(d[0].y);
            }
            else {
              if (d.value < 0) {
                r = (height-y(0)) - (height-y(d.value));
              }
              else {
                r = (height-y(d.value)) - (height-y(0));
              }
            }
            r = d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
            return isTargetBars ? (height-y(d.target)) - (height-y(0)) : r;
          });
      } else {
        var xValues = svg.selectAll('.x-value')
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('g')
          .attr('class', 'series-group g')
          .attr('data-group-id', function (d, i) {
            return i;
          })
          .attr('transform', function(d) {
            return 'translate(' + x0(isStacked ? xAxisValues[0] : d.name) + ',0)';
          });

        bars = xValues.selectAll('rect')
          .data(function(d) {return isStacked ? d : d.values;})
          .enter()
          .append('rect')
            .attr('class', function(d, i) {
              return 'series-'+ i +' bar';
            })
            .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
            .attr('x', function(d, i) {
              var width = Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]);
              return isStacked ? xScale(i) : (x1.rangeBand()/2 + ((width + 2) * i) - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4  ? (width/2) : 0) );//' * (dataArray[0].values.length/2)) );
            })
            .attr('y', function() {return y(0) > height ? height : y(0);})
            .attr('height', function() {return 0;});

        bars
          .transition().duration(1000)
          .attr('y', function(d) {
            var r = isStacked ? (height-yScale(d.y)-yScale(d.y0)) : (d.value < 0 ? y(0) : y(d.value));
            return d.value < 0 ? r : (r > (height-3) ? height-2 : r);
          })
          .attr('height', function(d) {
            var r;
           if (isStacked) {
             r = yScale(d.y);
           }
           else {
             if (d.value < 0) {
               r = (height-y(0)) - (height-y(d.value));
             }
             else {
               r = (height-y(d.value)) - (height-y(0));
             }
           }
           return d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
          });
      }
      return bars;
    }

    if (isPositiveNegative) {
      targetBars = drawBars(true); //Draw target bars
    }
    bars = drawBars();

    if (isPositiveNegative) {
      pnBars = d3.selectAll('.empty-bars');
      charts.mergeArrays(pnBars[0], targetBars[0], bars[0]);
    }

    if (!isPositiveNegative) {
      //Style the bars and add interactivity
      if (!isStacked) {
        bars
          .style('fill', function(d, i) {
            return isSingular ?
              charts.chartColor(i, 'column-single', chartData[0].data[i]) :
              charts.chartColor(i, 'bar', series[i]);
          })
          .attr('mask', function (d, i) {
            return isSingular ?
              (chartData[0].data[i].pattern ? 'url(#'+ chartData[0].data[i].pattern +')' : null) :
              (series[i].pattern ? 'url(#'+ series[i].pattern +')' : null);
          });
      } else if (isStacked && !isSingular) {
        bars
          .style('fill', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          })
          .attr('mask', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return (dataset[thisGroup].pattern ? 'url(#'+ dataset[thisGroup].pattern +')' : null);
          });
      } else if (isStacked && isSingular) {
        bars
          .style('fill', function(d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          })
          .attr('mask', function(d) {
            return (d[0].pattern ? 'url(#'+ d[0].pattern +')' : null);
          });
      }
    }

    var isSingle = isSingular || !isSingular && isStacked,
      isGrouped = !isSingle;

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Column',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked,
      isSingular: isSingular
    });

    (isPositiveNegative ? pnBars : bars)
      .on('mouseenter', function(d, i) {
        var x, y, j, l, hexColor, size, isTooltipBottom,
          maxBarsForTopTooltip = 6,
          thisShape = this,
          shape = $(this),
          content = '',
          ePageY = d3.event.pageY,

          setPattern = function(pattern, hexColor) {
            return !pattern || !hexColor ? '' :
              '<svg width="12" height="12">'+
                '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
              '</svg>';
          },

          show = function(isTooltipBottom) {
            size = charts.getTooltipSize(content);
            x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);

            if (isStacked) {
              y = shape[0].getBoundingClientRect().top - size.height - 10;
            } else {
              y = ePageY-charts.tooltip.outerHeight() - 25;
              if (dataset.length > 1) {
                x = thisShape.parentNode.getBoundingClientRect().left - (size.width /2) + (thisShape.parentNode.getBoundingClientRect().width/2);
                if (isTooltipBottom) {
                  y += charts.tooltip.outerHeight() + 50;
                  if (y > (thisShape.parentNode.getBoundingClientRect().bottom + 10)) {
                    y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                  }
                } else {
                  y = thisShape.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
                }
              }
            }

            if (content !== '') {
              charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
            }
          };

        // Stacked
        if (isStacked) {
          if (isSingular) {
            content = '<p><b>'+ format(d[0].value) +'</b> '+ d[0].name +'</p>';
          } else {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ datasetStacked[0][i].name +'</b></div>';
            for (j=datasetStacked.length-1,l=0; j>=l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (dataset[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(dataset[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ datasetStacked[j][i].parentName +'</span><b>'+ format(datasetStacked[j][i].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
          }
          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        }

        // No Stacked
        else {
          if (isPositiveNegative) {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ d.name +'</b></div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (pnPatterns.target ? 'transparent' : color(pnColors.target)) +';">'+
                    (setPattern(pnPatterns.target, color(pnColors.target)))+
                  '</div>'+
                  '<span>'+ pnLegends.target +'</span><b>'+ format(d.target) +'</b>'+
                '</div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (d.value < 0 ?
                    (pnPatterns.negative ? 'transparent' : color(pnColors.negative)) :
                    (pnPatterns.positive ? 'transparent' : color(pnColors.positive))) +
                  ';">'+
                    (d.value < 0 ?
                      setPattern(pnPatterns.negative, color(pnColors.negative)) :
                      setPattern(pnPatterns.positive, color(pnColors.positive)))+
                  '</div>'+
                  '<span>'+ pnLegends[d.value < 0 ? 'negative' : 'positive'] +'</span><b>'+ format(d.value) +'</b>'+
                '</div>'+
              '</div>';
          }
          else if (dataset.length === 1) {
            content = '<p><b>'+ format(d.value) + '</b> '+ d.name +'</p>';
          } else {
            var data = d3.select(this.parentNode).datum().values;

            content = '<div class="chart-swatch">';
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(series[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = ePageY-charts.tooltip.outerHeight() - 25;
          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - (size.width /2) + (this.parentNode.getBoundingClientRect().width/2);
            y = this.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {

          content = tooltipDataCache[i] || tooltipData || content || '';
          if (d.tooltip) {
            var val = d.tooltip.replace('{{value}}', format(d.value));
            content = '<p>'+ val +'</p>';
          }
          show(isTooltipBottom);
        }

      })

      // Mouseleave
      .on('mouseleave', function() {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })

      // Click
      .on('click', function (d, i) {
        var selector, isTargetBar = this && d3.select(this).classed('target-bar');
        if (isTargetBar) {
          selector = svg.select('.bar.series-'+ i);
          selector.on('click').call(selector.node(), selector.datum(), i);
          return;
        }

        var isSelected = this && d3.select(this).classed('is-selected'),
          thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        charts.setSelectedElement({
          task: (isSelected ? 'unselected' : 'selected'),
          container: container,
          selector: this,
          isTrigger: !isSelected,
          triggerGroup: isGrouped,
          d: d,
          i: i
        });

        if (isSelected) {
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
        }
        return;
      })

      // Contextmenu
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this)[0][0], d);
      });

    //Add Legend
    if (isSingular && chartData[0].name) {
      charts.addLegend([{name: chartData[0].name}]);
    } else if (isPositiveNegative) {
      charts.addLegend(pnSeries);
    } else if (isStacked && isSingular) {
      charts.addLegend(series);
    } else if (!isSingular) {
      charts.addLegend(isStacked ? seriesStacked : series);
    }

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');

      if (isPositiveNegative) {
        svg.selectAll('.negative-value').style('text-anchor', 'end');
      }

    }

    //Add Tooltips
    charts.appendTooltip();

    //See if any labels overlap and use shorter */
    // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)
    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'shortName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'abbrName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, null, null, true);

      // Adjust extra(x) space with short name for RTL
      if (isPositiveNegative) {
        svg.selectAll('.target-bartext, .bartext').attr('x', function() {
          return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
        });
      }
    }

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if ((isSingular && isStacked ? d[0].selected : d.selected) && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingular && !isGrouped)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isSingular && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };

  // Merge the contents of multiple arrays together into the first array
  this.mergeArrays = function() {
    var i, len = arguments.length;
    if (len > 1) {
      for (i = 1; i < len; i++) {
        arguments[i].forEach(function(v) {
          this.push(v);
        }, arguments[0]);
      }
    }
  };

  this.labelsColide = function(svg) {
    var ticks = svg.selectAll('.x text'),
      collides = false;

    ticks.each(function(d, i) {
      var rect1 = this.getBoundingClientRect(), rect2;

      ticks.each(function(d, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();

          var overlap = !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);

          if (overlap) {
            collides = true;
          }
        }

      });
    });

    return collides;
  };

  this.applyAltLabels = function(svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');

    ticks.each(function(d, i) {
      var text = dataArray[i][elem];

      text = text || (isNoEclipse ?
        ((d3.select(this).text().substring(0, 1))) : (d3.select(this).text().substring(0, 6) +'...'));
      d3.select(this).text(text);
    });
  };

  this.Line = function(chartData, options, isArea, isBubble) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    $(container).addClass('line-chart' + (isBubble ? ' bubble' : ''));

    var dots = {
      radius: 5,
      radiusOnHover: 7,
      strokeWidth: 2,
      class: 'dot'
    };
    if (isBubble) {
      dots.radius = 0;
      dots.radiusOnHover = 0;
      dots.strokeWidth = 0;
    }
    $.extend(true, dots, settings.dots);

    var isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Config axis labels
    var i, l,
      axisLabels = {},
      isAxisLabels = {atLeastOne: false},
      axisArray = ['left', 'top', 'right', 'bottom'];
    if (charts.options.axisLabels) {
      $.extend(true, axisLabels, charts.options.axisLabels);
    }
    if (!$.isEmptyObject(axisLabels)) {
      for (i = 0, l = axisArray.length; i < l; i++) {
        var thisAxis = axisLabels[axisArray[i]];
        if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
          isAxisLabels[axisArray[i]] = true;
          isAxisLabels.atLeastOne = true;
        }
      }
    }

    //Append the SVG in the parent area.
    var longestLabel = '',
      longestLabelLength = 0,
      dataset = chartData,
      isAxisXRotate = (settings.xAxis && settings.xAxis.rotate !== undefined),
      getMaxes = function (d, option) {
        return d3.max(d.data, function(d) {
          return option ? d.value[option] : d.value;
        });
      };

    if (isAxisXRotate) {
      //get the longeset label
      dataset[0].data.map(function (d) {
        if (d.name.length > longestLabel.length) {
          longestLabel = d.name;
        }
      });
      longestLabelLength = longestLabel.length;
    }

    var hideDots = (options.hideDots),
      parent = $(container).parent(),
      isCardAction = !!$('.widget-chart-action', parent).length,
      isViewSmall = parent.width() < 450,
      margin = {
        top: (isAxisLabels.top ? (isCardAction ? 15 : 40) : (isCardAction ? 5 : 30)),
        right: (isAxisLabels.right ? (isViewSmall ? 45 : 65) : (isViewSmall ? 45 : 55)),
        bottom: (isAxisLabels.bottom ? (isAxisXRotate ? 60 : 50) : (isAxisXRotate ? (longestLabelLength * 5) + 35 : 35)),
        left: (isAxisLabels.right ? (isViewSmall ? 55 : 75) : (isViewSmall ? 45 : 65))
      },
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    if (isCardAction) {
      height -= 40;
    }

    var svg = d3.select(container).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    var names = dataset[0].data.map(function (d) {
      return d.name;
    });

    var formatValue,
      valueFormatterString = {};
    if (dataset[0] && dataset[0].valueFormatterString) {
      $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
    }
    formatValue = function (s, value) {
      return !$.isEmptyObject(valueFormatterString) && !!s ?
        (d3.format(s)(s === '0.0%' ? value/100 : value)) : value;
    };

    var labels = {
      name: 'Name',
      value: {
        x: 'Value.x',
        y: 'Value.y',
        z: 'Value.z'
      }
    };
    if (dataset[0] && dataset[0].labels) {
      $.extend(true, labels, dataset[0].labels);
    }

    // Calculate the Domain X and Y Ranges
    var maxes,
      x = ((!!settings.xAxis && !!settings.xAxis.scale) ? (settings.xAxis.scale) : (d3.scale.linear())).range([0, width]),
      y = d3.scale.linear().range([height, 0]),
      z = d3.scale.linear().range([1, 25]);

    if (isBubble) {
      maxes = {
        x: dataset.map(function (d) { return getMaxes(d, 'x'); }),
        y: dataset.map(function (d) { return getMaxes(d, 'y'); }),
        z: dataset.map(function (d) { return getMaxes(d, 'z'); })
      };
    } else {
      maxes = dataset.map(function (d) { return getMaxes(d); });
    }

    var entries = d3.max(dataset.map(function(d){ return d.data.length; })) -1,
      xScale = x.domain(!!settings.xAxis && !!settings.xAxis.domain ? (settings.xAxis.domain) : ([0, isBubble ? d3.max(maxes.x) : entries])).nice(),
      yScale = y.domain([0, d3.max(isBubble ? maxes.y : maxes)]).nice(),
      zScale = z.domain([0, d3.max(isBubble ? maxes.z : maxes)]).nice();

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient('bottom')
      .ticks((!!settings.xAxis && !!settings.xAxis.ticks) ? (settings.xAxis.ticks) : (isBubble && isViewSmall ? Math.round(entries/2) : entries))
      .tickPadding(10)
      .tickSize(isBubble ? -(height + 10) : 0)
      .tickFormat(function (d, i) {
        if (!!settings.xAxis && !!settings.xAxis.formatter) {
          return settings.xAxis.formatter(d, i);
        }
        return isBubble ? d : names[i];
      });

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(-(width + 20))
      .tickPadding(isRTL ? -18 : 20)
      .orient('left');

    if (settings.yAxis && settings.yAxis.formatter) {
      yAxis.tickFormat(function (d, i) {
        if (typeof settings.yAxis.formatter === 'function') {
          return settings.yAxis.formatter(d, i);
        }
        return d;
      });
    }

    if (settings.yAxis && settings.yAxis.ticks) {
      yAxis.ticks(settings.yAxis.ticks.number, settings.yAxis.ticks.format);
    }

    //Append The Axis Labels
    if (isAxisLabels.atLeastOne) {
      var axisLabelsGroup = svg.append('g').attr('class', 'axis-labels'),
        place = {
          top: 'translate('+ (width/2) +','+(-10)+')',
          right: 'translate('+ (width+28) +','+(height/2)+')rotate(90)',
          bottom: 'translate('+ (width/2) +','+(height+40)+')',
          left: 'translate('+ (-40) +','+(height/2)+')rotate(-90)'
        },
        placeStyle = {
          top: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (-10) +'px)',
          right: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, -'+ (width+28) +'px)',
          bottom: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (height+40) +'px)',
          left: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, '+ (55) +'px)'
        },
        addAxis = function(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text')
              .attr({
                'class': 'axis-label-'+ pos,
                'text-anchor': 'middle',
                'transform': isRTL ? '' : place[pos]
              })
              .style({
                'font-size': '1.3em',
                'transform': isRTL ? placeStyle[pos] : ''
              })
              .text(axisLabels[pos]);
          }
        };

      for (i = 0, l = axisArray.length; i < l; i++) {
        addAxis(axisArray[i]);
      }
    }


    //Append The Axis to the svg
    svg.append('g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

    svg.append('g')
      .attr('class', 'y axis')
      .call(yAxis);

    //Offset the tick inside, uses the fact that the yAxis has 20 added.
    svg.selectAll('.tick line').attr('x1', '-10');

    if (isBubble) {
      svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
      svg.select('.x.axis .tick line').attr('x2', '-10').style('opacity', 1);
      svg.select('.y.axis .tick line').style('opacity', 1);
    }

    if (charts.isRTL) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    if (isAxisXRotate) {
      svg.selectAll('.x.axis .tick text')  // select all the text for the xaxis
      .attr('y', 0)
      .attr('x', function () {
        return -(this.getBBox().width + 10);
      })
      .attr('dy', '1em')
      .attr('transform', 'rotate(' + settings.xAxis.rotate + ')')
      .style('text-anchor', 'start');
    }

    // Create the line generator
    var line = d3.svg.line()
      .x(function(d, i) {
        if (!!settings.xAxis && !!settings.xAxis.parser)  {
          return xScale(settings.xAxis.parser(d, i));
        }
        return xScale(isBubble ? d.value.x : i);
      })
      .y(function(d) {
        return yScale(isBubble ? d.value.y : d.value);
      });

    //append the three lines.
    dataset.forEach(function(d, i) {

      var lineGroups = svg.append('g')
        .attr({'data-group-id': i, 'class': 'line-group'});

      if (isArea) {
        var area = d3.svg.area()
          .x(function(d, i) {
            return xScale(i);
          })
          .y0(height)
          .y1(function(d) {
            return yScale(isBubble ? d.value.y : d.value);
          });

        lineGroups.append('path')
          .datum(d.data)
          .attr('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', '.2')
          .attr('class', 'area')
          .attr('d', area);
      }

      var path = lineGroups.append('path')
        .datum(d.data)
        .attr('d', line(d.data))
        .attr('stroke', function () { return isBubble ? '' : charts.chartColor(i, 'line', d); })
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('class', 'line')
        .on('click.chart', function() {
          charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
        });

      // Add animation
      var totalLength = path.node().getTotalLength();
      path
        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
        .attr('stroke-dashoffset', totalLength)
        .transition()
          .duration(750)
          .ease('cubic')
          .attr('stroke-dashoffset', 0);

      if (!hideDots) {
          lineGroups.selectAll('circle')
          .data(d.data)
          .enter()
          .append('circle')
          .attr('class', dots.class)
          .attr('cx', function (d, i) {
            if (!!settings.xAxis && !!settings.xAxis.parser)  {
              return xScale(settings.xAxis.parser(d, i));
            }
            return xScale(isBubble ? d.value.x : i);
          })
          .attr('cy', function (d) { return yScale(isBubble ? 0 : d.value); })
          .attr('r', dots.radius)
          .style('stroke-width', dots.strokeWidth)
          .style('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', (isBubble ? '.7' : '1'))
          .on('mouseenter.chart', function(d2) {
            var rect = this.getBoundingClientRect(),
              content = '<p><b>' + d2.name + ' </b> ' + format(d2.value) + '</p>',

              show = function() {
                var size = charts.getTooltipSize(content),
                  x = rect.left - (size.width /2) + 6,
                  y = rect.top - size.height - 18;

                x = isBubble ? ((rect.left + (rect.width /2)) - (size.width /2)) : x;

                if(content !== '') {
                  charts.showTooltip(x, y, content, 'top');
                }
              };

            if (isBubble) {
              content = ''+
                '<div class="chart-swatch" style="min-width: 95px;">'+
                  '<div class="swatch-caption">'+
                    '<span style="background-color:'+ charts.chartColor(i, 'line', d) +';" class="indicator-box"></span>'+
                    '<b>'+ d.name +'</b>'+
                  '</div>';

                var obj = d2;
                for (var key in obj) {
                  if(obj.hasOwnProperty(key)) {
                    if (typeof obj[key] !== 'object') {
                      content += ''+
                        '<div class="swatch-row">'+
                          '<span>'+ labels[key] +'</span>'+
                          '<b>'+ obj[key] +'</b>'+
                        '</div>';
                    } else {
                      var obj2 = obj[key];
                      for (var key2 in obj2) {
                        if(obj2.hasOwnProperty(key2)) {
                          content += ''+
                            '<div class="swatch-row">'+
                              '<span style="text-transform: capitalize;">'+ labels[key][key2] +'</span>'+
                              '<b>'+ formatValue(valueFormatterString[key2], obj2[key2]) +'</b>'+
                            '</div>';
                        }
                      }
                    }
                  }
                }
              content += '</div>';
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || d2.tooltip || d.tooltip || content || '';
              show();
            }

            //Circle associated with hovered point
            d3.select(this).attr('r', function (d) {
              return isBubble ? (2 + zScale(d.value.z)) : dots.radiusOnHover;
            });
          })
          .on('mouseleave.chart', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
            d3.select(this).attr('r', function (d) {
              return isBubble ? zScale(d.value.z) : dots.radius;
            });
          })
          .on('click.chart', function(d) {
            charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
          });

        if (isBubble) {
          // Add animation
          lineGroups.selectAll('circle')
            .attr('cy', function (d) { return yScale(d.value.y); })
            .transition().duration(750).ease('cubic')
            .attr('r', function (d) { return zScale(d.value.z); });
        }
      }

    });

    var series = dataset.map(function (d) {
      return {color: d.color, name: d.name, selectionObj: svg.selectAll('.line-group'), selectionInverse: svg.selectAll('.line-group'), data: d};
    });

    if (charts.showLegend) {
      charts.addLegend(series);
    }
    charts.appendTooltip();

    // Set initial selected
    (function () {
      var selected = 0,
        selector,
        selectorData,

        setSelected = function (node, d, i) {
          if (node.selected && selected < 1) {
            selected++;
            selector = d3.select(svg.selectAll('.line-group')[0][i]);
            selectorData = d;
          }
        };

      dataset.forEach(function(d, i) {
        if (d) {
          setSelected(d, d, i);
        }
      });
      dataset.forEach(function(d, i) {
        if (d || d.data) {
          d.data.forEach(function(d2) {
            setSelected(d2, d, i);
          });
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, svg.selectAll('.line-group'), selectorData);
      }
    })();


    $(container).trigger('rendered');
    return $(container);
  };

  this.Bullet = function(chartData) {
    $(container).addClass('bullet-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Append the SVG in the parent area.
    var dataset = chartData,
      noMarkers = false,
      parent = $(container).parent(),
      margin = {top: 30, right: 55, bottom: 35, left: 55},
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    height = height < 0 ? 50 : height; //default minimum height

    var svg = d3.select(container).append('svg')
              .attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    //Functions Used in the Loop
    function bulletWidth(x) {
      var x0 = x(0);
      return function(d) {
        return Math.abs(x(d) - x0);
      };
    }

    for (var i = 0; i < dataset[0].data.length; i++) {
      var duration = 600,
          barHeight = 20,
          rowData = dataset[0].data[i],
          ranges = rowData.ranges.slice().sort(d3.descending),
          markers = (rowData.markers ? rowData.markers.slice().sort(d3.descending) : []),
          measures = (rowData.measures ? rowData.measures.slice().sort(d3.descending) : []),
          rangesAsc = rowData.ranges.slice().sort(d3.ascending),
          markersAsc = (rowData.markers ? rowData.markers.slice().sort(d3.ascending) : []),
          measuresAsc = (rowData.measures ? rowData.measures.slice().sort(d3.ascending) : []);

      if (markers.length === 0) {
        markers = measures;
        markersAsc = measuresAsc;
        noMarkers = true;
      }

      var g = svg.append('g')
              .attr('class', 'bullet')
              .attr('transform', 'translate(0, ' + (i * (barHeight * 3.5)) + ')');

      //Add Title and Subtitle
      var title = g.append('g');

      var text = title.append('text')
          .attr('class', 'title')
          .attr('dy', '-10px')
          .text(function() { return rowData.title; });

      text.append('tspan')
          .attr('class', 'subtitle')
          .attr('dx', '15px')
          .text(function() { return rowData.subtitle; });

      var maxAll = Math.max(ranges[0], markers[0], measures[0]),
          minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);

      minAll = minAll < 0 ? minAll : 0;

      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain([minAll, maxAll])
          .range([0, width])
          .nice();

      // Derive width-scales from the x-scales.
      var w1 = bulletWidth(x1);

      // Update the range rects.
      var range = g.selectAll('rect.range')
          .data(ranges);

      range.enter().append('rect')
          .attr('class', function(d, i) { return 'range s' + i; })
          .attr('data-idx', i)
          .attr('width', 0)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d, i) {
            if (chartData[0].barColors) {
              return chartData[0].barColors[i];
            }
          })
          .attr('height', barHeight)
          .on('click', function () {
            var bar = d3.select(this);
            $(container).trigger('selected', [bar, chartData[0].data[bar.attr('data-idx')]]);
          })
          .on('mouseenter', function(d, i) {

            var bar = d3.select(this),
              data = chartData[0].data[bar.attr('data-idx')],
              rect = this.getBoundingClientRect(),
              content = '<p>' + d + '</p>',

              show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + rect.width - (size.width/2),
                y = rect.top - size.height + $(window).scrollTop() - 5;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

            if (data.tooltip && data.tooltip[i]) {
              content = data.tooltip[data.tooltip.length - i -1];
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || content || '';
              show();
            }

          })
          .on('mouseleave', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
          });


      range.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the measure rects.
      var measure = g.selectAll('rect.measure')
          .data(measures);

      measure.enter().append('rect')
          .attr('class', function(d, i) { return 'measure s' + i; })
          .attr('width', 0)
          .attr('height', 3)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d,i) {
            if (chartData[0].lineColors) {
              return chartData[0].lineColors[i];
            }
          })
          .attr('y', 8.5);

      measure.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the marker lines.
      var marker = g.selectAll('line.marker')
          .data(markers);

      marker.enter().append('line')
          .attr('class', (noMarkers ? 'hidden' : 'marker'))
          .attr('x1', 0)
          .attr('x2', 0)
          .style('stroke', function(d, i) {
            if (chartData[0].markerColors) {
              return chartData[0].markerColors[i];
            }
          })
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      marker.transition()
          .duration(duration)
          .attr('x1', x1)
          .attr('x2', x1)
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      //Difference
      var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]),
        line;

      if (Math.abs(markers[0] - measures[0]) !== 0) {
        line = marker.enter().append('text')
            .attr('class', 'inverse')
            .attr('text-anchor', 'middle')
            .attr('y', barHeight /2 + 4)
            .attr('dx', charts.isRTL ? '-20px' : '20px')
            .attr('x', 0)
            .text(diff);

          marker.transition()
              .duration(duration)
              .attr('x', function() {
                var total = 0;

                g.selectAll('.measure').each(function(d) {
                  var w = w1(d),
                    x = x1(d);

                  if (w > total) {
                    total = w;
                  }

                  if (x > total) {
                    total = x;
                  }
                });

                return charts.isRTL ? -total : total;
              })
              .style('opacity', 1);
      }

      // Update the tick groups.
      var tick = g.selectAll('g.tick')
          .data(x1.ticks(8));

      // Initialize the ticks with the old scale, x0.
      var tickEnter = tick.enter().append('g')
          .attr('class', 'tick')
          .attr('transform', 'translate(0,0)')
          .style('opacity', 0);

      tickEnter.append('line')
          .attr('y1', barHeight)
          .attr('y2', Math.round((barHeight * 7) / 4.7));

      tickEnter.append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', '1.1em')
          .attr('y', Math.round((barHeight * 7) / 4.7))
          .attr('class', function(d) {
            return d < 0 ? 'negative-value' : 'positive-value';
          })
          .text(function (d) {
            return d;
          });

      // Transition the entering ticks to the new scale, x1.
      tickEnter.transition()
          .duration(duration)
          .attr('transform', function (d) {
            return 'translate(' + x1(d) + ',0)';
          })
          .style('opacity', 1);

      if (charts.isRTL && charts.isIE) {
        svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      }

    }

    //Add Legends
    //charts.addLegend(isStacked ? series);
    charts.appendTooltip();
    $(container).trigger('rendered');

  };

  //Completion chart
  this.Completion = function(chartData) {

    // Set dataset
    var dataset = chartData[0].data[0],
      isTarget = charts.settings.type === 'completion-target',
      isAchievment = charts.settings.type === 'targeted-achievement';

    $(container).addClass('completion-chart' + (charts.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement': ''));

    // Set total defaults
    dataset.total = $.extend({}, {value: 100}, dataset.total);

    // Basic functions
    var isUndefined = function(value) {
        return typeof value === 'undefined';
      },
      fixUndefined = function(value, isNumber) {
        return !isUndefined(value) ? value : (isNumber ? 0 : '');
      },
      toValue = function(percent) {
        return percent /100 * fixUndefined(dataset.total.value, true);
      },
      toPercent = function(value) {
        return d3.round(100 * (value / fixUndefined(dataset.total.value, true)));
      },
      format = function (value, formatterString) {
        if (formatterString === '.0%') {
          return toPercent(value) +'%';
        }
        return d3.format(formatterString || '')(value);
      },
      fixPercent = function(value) {
        var s = value.toString();
        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''));
        }
        return value;
      },
      updateWidth = function(elem, value) {
        var w = toPercent(value) > 100 ? 100 : (toPercent(value) < 0 ? 0 : toPercent(value));
        elem[0].style.width = w + '%';
      },
      updateTargetline = function(elem, value) {
        var w = value > 100 ? 100 : (value < 0 ? 0 : value);
        elem[0].style.left = w + '%';
      },
      setFormat = function(obj) {
        return (obj && !isUndefined(obj.value) && obj.format) ?
          format(fixPercent(obj.value), obj.format) : (obj ? fixPercent(obj.value) : 0);
      },
      setOverlap = function() {
        if (isTarget && !isAchievment) {
          setTimeout(function() {
            var remaining = $('.remaining', container),
              total = $('.total', container),
              rect1 = $('.completed .value', container)[0].getBoundingClientRect(),
              rect2 = remaining.find('.value')[0].getBoundingClientRect();

            remaining.add(total)
              [(rect1.right > rect2.left-20) ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      };

      this.update = function(o) {
        var type, bar, nodes, jsonData;
        if (!o.data) {
          return;
        }

        if (!o.type) {
          nodes = o.node;
        }
        else {
          type = o.type;
          if (!dataset[type]) {
            return;
          }
          nodes = (type === 'name') ?
            $('.name', container) : ((type === 'total') ?
              $('.total.value', container) :
                $('.'+ type +' .value, .'+ type +' .text', container));
        }

        jsonData = (nodes.length === 1 ? nodes : nodes.first()).data('jsonData');

        type = jsonData ? Object.keys(jsonData)[0] : 'name';
        bar = $('.'+ type +'.bar', container);
        $.extend(true, dataset[type], o.data);

        nodes.each(function() {
          var node = $(this);

          // Update text
          if (o.data.text && node.is('.name, .text')) {
            node.html(fixUndefined(dataset[type].text));
          }

          // Update color for text, value, bar
          if (o.data.color && node.is('.name, .info, .text, .value')) {
            if (o.data.color.indexOf('#') === -1) {
              ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                node.add($('.info .value', container)) : node).add(bar)
                  .removeClass('error dark good primary amethyst07')
                  .addClass(o.data.color);
            }
            else {
              if (node.is('.name, .total')) {
                node[0].style.color = dataset[type].color;
              }
              else {
                ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                  $('.'+ type +' .value, .'+ type +' .text, .info .value', container) :
                  $('.'+ type +' .value, .'+ type +' .text', container))[0].style.color = dataset[type].color;
                bar[0].style.backgroundColor = dataset[type].color;
              }
            }
          }

          // Update value & bar width
          if (o.data.value && node.is('.value')) {
            var w,
              completed = $('.completed', container),
              remaining = $('.remaining', container);

            if (type === 'completed') {
              ((!dataset.info || (dataset.info && isUndefined(dataset.info.value))) ?
                node.add($('.info .value', container)) : node)
                  .html(setFormat(dataset[type]));

              if (toPercent(fixPercent(dataset[type].value)) >= 100) {
                remaining.hide();
                completed[0].style.marginTop = 'inherit';
              }
            }
            else {
              node.html(setFormat(dataset[type]));
            }

            if (!node.is('.name, .total') && type !== 'targetline') {
              if (type === 'completed') {
                w = fixPercent(dataset[type].value);
                updateWidth(bar, w);
                w += fixPercent(dataset.remaining.value);
                updateWidth($('.remaining.bar', container), w);
              }
              else if (type === 'remaining') {
                w = fixPercent(dataset[type].value) + fixPercent(dataset.completed.value);
                updateWidth(bar, w);
              }
            }
            else if (!node.is('.name, .total, .remaining') && type === 'targetline') {
              w = fixPercent(dataset[type].value);
              updateTargetline(bar, w);
            }
            setOverlap();
          }
        });
      };

    // Render
    var html = {body: $('<div class="total bar" />')};
    if (isTarget || isAchievment) {
      var difference = {};
      html.body.addClass('chart-completion-target' + (isAchievment ? ' chart-targeted-achievement' : ''));

      if (dataset.total.difference) {
        difference.value = (dataset.total.value - dataset.completed.value);
        difference.format = dataset.total.format;
      }

      var totalText = setFormat(dataset.total.difference ? difference : dataset.total) + (dataset.total.text ? dataset.total.text : '');
      totalText = isAchievment && dataset.remaining ? setFormat(dataset.remaining) + (dataset.remaining.text ? dataset.remaining.text : ''): totalText;

      html.label = ''+
      '<span class="label">'+
        '<span class="name">'+
        (dataset.completed.color && dataset.completed.color === 'error' ? '<svg class="icon icon-error" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-error"></use></svg>' : '' ) +
        fixUndefined(dataset.name.text) + '</span>'+
        '<span class="l-pull-right total value">'+ totalText +'</span>'+
      '</span>';
    }
    else {
      html.body.addClass('chart-completion');
      html.label = ''+
      '<b class="label name ">'+ fixUndefined(dataset.name.text) +'</b>'+
      '<b class="label info '+ (dataset.info.color ?
        fixUndefined(dataset.info.color) :
          fixUndefined(dataset.completed.color) +' colored') +'">'+
        '<span class="value">'+
        (dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) :
          setFormat(dataset.completed)) +
        '</span> '+
        '<span class="text">'+ fixUndefined(dataset.info.text) +'</span>'+
      '</b>';
    }

    if (dataset.remaining) {
      html.remaining = ''+
      '<div class="target remaining bar '+ fixUndefined(dataset.remaining.color) +'">'+
      (isAchievment ? '' : '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+
            setFormat(dataset.remaining) +
          '</span><br />'+
          '<span class="text">'+
            fixUndefined(dataset.remaining.text) +
          '</span>'+
        '</span>') +
      '</div>';
    } else {
      html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
    }

    if (dataset.completed && isAchievment) {
      html.completed = ''+
      '<div class="completed bar '+ fixUndefined(dataset.completed.color) +'"></div>'+
        '<span class="completed-label" aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="text">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span>';
    }

    if (dataset.completed && !isAchievment) {
      html.completed = ''+
      '<div class="completed bar '+ fixUndefined(dataset.completed.color) +'">'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+ setFormat(dataset.completed) + '</span><br />'+
          '<span class="text">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span></div>';
    }

    if (dataset.targetline) {
      html.targetline = ''+
      '<div class="target-line targetline bar">'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+
            setFormat(dataset.targetline) +
            '</span><br />'+
            '<span class="text">'+
              fixUndefined(dataset.targetline.text) +
            '</span>'+
        '</span>'+
      '</div>';
    }

    html.body.append(html.remaining, html.completed, html.targetline);
    $(container).append(html.label, html.body);

    // Caching elements
    var c = {
      name: $('.name', container),
      info: {
        value: $('.info .value', container),
        text: $('.info .text', container)
      },
      completed: {
        bar: $('.completed.bar', container),
        value: $('.completed .value', container),
        text: $('.completed .text', container)
      },
      remaining: {
        bar: $('.remaining.bar', container),
        value: $('.remaining .value', container),
        text: $('.remaining .text', container)
      },
      targetline: {
        bar: $('.targetline', container),
        value: $('.targetline .value', container),
        text: $('.targetline .text', container)
      },
      total: {
        bar: $('.total.bar', container),
        value: $('.total.value', container),
      }
    };

    // Set jsonData
    c.name.data('jsonData', {name: dataset.name});
    c.info.value.add(c.info.text).data('jsonData', {info: dataset.info});
    c.completed.bar.add(c.completed.value).add(c.completed.text)
      .data('jsonData', {completed: dataset.completed});
    c.remaining.bar.add(c.remaining.value).add(c.remaining.text)
      .data('jsonData', {remaining: dataset.remaining});
    c.targetline.bar.add(c.targetline.value).add(c.targetline.text)
      .data('jsonData', {targetline: dataset.targetline});
    c.total.bar.add(c.total.value).data('jsonData', {total: dataset.total});

    var w;
    // Update completed bar width
    if (dataset.completed) {
      w = fixPercent(dataset.completed.value);
      updateWidth(c.completed.bar, w);
    }

    // Update remaining bar width
    if (dataset.remaining) {
      w = fixPercent(dataset.completed.value) + fixPercent(dataset.remaining.value);
      updateWidth(c.remaining.bar, w);
      setOverlap();
    }

    // Update target line bar position
    if (dataset.targetline) {
      w = fixPercent(dataset.targetline.value);
      updateTargetline(c.targetline.bar, w);
    }
  };

  //Select the element and fire the event, make the inverse selector opace
  this.selectElement = function(elem, inverse, data) {
    var isSelected = elem.node() && elem.classed('is-selected');

    inverse.classed('is-not-selected', false)
      .classed('is-selected', false)
      .classed('is-not-selected', !isSelected);

     elem.classed('is-not-selected', false)
        .classed('is-selected', !isSelected);

    //Fire Events
     $(container).triggerHandler('selected', [elem, (!isSelected ? data : {})]);
  };

  // Make bars to be Selected or Unselected
  this.setSelectedElement = function (o) {
    var s = charts.settings,
      dataset = s.dataset,
      isPositiveNegative = s.type === 'column-positive-negative',
      isTypeHorizontalBar = s.chartType === 'HorizontalBar',
      isTypeColumn = s.chartType === 'Column',
      isTypePie = s.chartType === 'Pie',

      svg = s.svg,
      isSingle = s.isSingle,
      isGrouped = s.isGrouped,
      isStacked = s.isStacked,
      isSingular = s.isSingular,

      taskSelected = (o.task === 'selected'),
      selector = d3.select(o.selector),
      isPositive = selector.classed('positive'),
      ticksX = svg.selectAll('.axis.x .tick'),
      ticksY = svg.selectAll('.axis.y .tick'),
      pnPositiveText = svg.selectAll('.bartext.positive, .target-bartext.positive'),
      pnNegativeText = svg.selectAll('.bartext.negative, .target-bartext.negative'),
      thisGroup = d3.select(o.selector.parentNode),
      thisGroupId = parseInt((thisGroup.node() ? thisGroup.attr('data-group-id') : 0), 10),
      triggerData = [],
      selectedBars = [],
      thisData;

    if (isStacked || isTypePie) {
      dataset = dataset || null;
    } else {
      dataset = (dataset && dataset[thisGroupId]) ? dataset[thisGroupId].data : null;
    }

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);

    // Task make selected
    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6);

      // By legends only
      if (s.isByLegends && !isTypePie) {
        if (isPositiveNegative) {
          s.svg.selectAll(isPositive ?
            '.bar.positive, .target-bar.positive': '.bar.negative, .target-bar.negative')
              .classed('is-selected', true).style('opacity', 1);

          (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');

          svg.selectAll('.bar').each(function(d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({elem: bar[0], data: (dataset ? dataset[i] : d)});
            }
          });
          triggerData = selectedBars;
        }
        // Grouped and stacked only -NOT singular-
        else if (isTypeColumn || isTypeHorizontalBar) {
          if (isGrouped || isSingular) {
            s.svg.selectAll('.series-'+ o.i).classed('is-selected', true).style('opacity', 1);
          } else {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function(d, i) {
            var bar = d3.select(this);

            thisData = s.dataset;
            thisData = thisData ? (isStacked ? isSingular ? (thisData[0].data[o.i]) : (thisData[o.i].data[i]) : thisData[i].data[o.i]) : d;
            selectedBars.push({elem: bar[0], data: thisData});
          });
          triggerData = selectedBars;
        }
      }

      // Single and stacked only -NOT grouped-
      else if (isSingular && isStacked && isTypeColumn) {
        thisData = dataset[0] && dataset[0].data ? dataset[0].data : o.d;
        selector.classed('is-selected', true).style('opacity', 1);
        triggerData.push({elem: selector[0], data: thisData[o.i]});
      }

      // Single or groups only -NOT stacked-
      else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isTypeHorizontalBar)) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ ((isGrouped ? thisGroupId : o.i) + 1) +')')
          .style('font-weight', 'bolder');

        selector.classed('is-selected', true).style('opacity', 1);
        svg.select('.target-bar.series-'+ o.i).style('opacity', 1);
        d3.select(svg.selectAll('.bartext')[0][o.i]).style('font-weight', 'bolder');
        d3.select(svg.selectAll('.target-bartext')[0][o.i]).style('font-weight', 'bolder');

        if (isGrouped || isPositiveNegative || isTypeColumn) {
          if (!isPositiveNegative && !isTypeColumn || (isTypeColumn && isGrouped)) {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          thisGroup.selectAll('.bar').each(function(d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({elem: bar[0], data: (dataset ? dataset[i] : d)});
            }
          });
          if (isGrouped) {
            triggerData.push({groupIndex: thisGroupId, groupElem: thisGroup[0], groupItems: selectedBars});
          } else {
            triggerData = selectedBars;
          }
        }
      }

      // Stacked Only
      else if (isTypeColumn || isTypeHorizontalBar) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ (o.i + 1) +')')
          .style('font-weight', 'bolder');

        svg.selectAll('.bar:nth-child('+ (o.i + 1) +')')
          .classed('is-selected', true).style('opacity', 1);

        svg.selectAll('.bar.is-selected').each(function(d, i) {
          var bar = d3.select(this);
          selectedBars.push({elem: bar[0], data: (dataset ? dataset[i].data[o.i] : d)});
        });
        triggerData = selectedBars;
      }

      // Pie
      else if (isTypePie) {
        //Unselect selected ones
        svg.selectAll('.arc')
          .style({'stroke': '', 'stroke-width': ''})
          .attr('transform', '');

        var color = charts.chartColor(o.i, 'pie', o.d.data),
          thisArcData = dataset && dataset[0] && dataset[0].data ? dataset[0].data[o.i] : (o.d ? o.d.data : o.d);
        selector.classed('is-selected', true)
          .style({'stroke': color, 'stroke-width': 0})
          .attr('transform', 'scale(1.025, 1.025)');
        triggerData.push({elem: selector[0], data: thisArcData, index: o.i});
      }
    }
    // Task make unselected
    else {
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if (isTypePie) {
        selector.classed('is-selected', false)
          .style('stroke', '#fff')
          .style('stroke-width', '1px')
          .attr('transform', '');
      }
    }

    if (s.isByLegends) {
      s.isByLegends = false;
    }

    this._selected = triggerData;

    if (o.isTrigger) {
      $(o.container).triggerHandler((taskSelected ? 'selected' : 'unselected'), [triggerData]);
    }
  };

  this.isHTML = function (str) {
    return /(<([^>]+)>)/i.test(str);
  };

  this.initChartType = function (options) {
    //default
    this.options = options;
    this.redrawOnResize = true;
    this.isRTL = Locale.isRTL();
    this.isIE = $('html').hasClass('ie');

    if (options.redrawOnResize !== undefined) {
      this.redrawOnResize = options.redrawOnResize;
    }
    if (options.format) {
      this.format = options.format;
    }
    if (options.tooltip) {
      this.tooltip = options.tooltip;
    }
    if (options.showLegend) {
      this.showLegend = options.showLegend;
    }
    if (options.legendformatter) {
      this.legendformatter = options.legendformatter;
    }
    // Prevent error from passed empty dataset
    if (!options.dataset || !options.dataset.length) {
      $.extend(true, options, {dataset: [{data: []}]});
    }
    if (options.type === 'pie') {
      this.Pie(options.dataset, false, options);
    }
    if (options.type === 'bar' || options.type === 'bar-stacked') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset);
    }
    if (options.type === 'bar-normalized') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true);
    }
    if (options.type === 'bar-grouped') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true, false); //dataset, isNormalized, isStacked
    }
    if (options.type === 'column-stacked') {
      this.Column(options.dataset, true);
    }
    if (['column', 'column-grouped', 'column-positive-negative'].indexOf(options.type) > -1) {
      this.Column(options.dataset);
    }
    if (options.type === 'donut') {
      this.Pie(options.dataset, true, options);
    }
    if (options.type === 'sparkline') {
      this.Sparkline(options.dataset, options);
    }
    if (options.type === 'sparkline-dots') {
      this.Sparkline(options.dataset, {isDots: true});
    }
    if (options.type === 'sparkline-peak') {
      this.Sparkline(options.dataset, {isPeakDot: true});
    }
    if (options.type === 'sparkline-dots-n-peak') {
      this.Sparkline(options.dataset, {isDots: true, isPeakDot: true});
    }
    if (options.type === 'sparkline-minmax') {
      this.Sparkline(options.dataset, {isMinMax: true});
    }
    if (options.type === 'sparkline-medianrange') {
      this.Sparkline(options.dataset, {isMedianRange: true});
    }
    if (options.type === 'sparkline-medianrange-n-peak') {
      this.Sparkline(options.dataset, {isMedianRange: true, isPeakDot: true});
    }
    if (options.type === 'line') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options);
    }
    if (options.type === 'area') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, true);
    }
    if (options.type === 'bubble') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, false, true);
    }
    if (options.type === 'bullet') {
      this.Bullet(options.dataset);
    }
    if (options.type === 'completion' ||
        options.type === 'completion-target' || options.type === 'targeted-achievement') {
      this.redrawOnResize = false;
      this.Completion(options.dataset);
    }
  };

};

//Make it a plugin
$.fn.chart = function(options) {
  return this.each(function() {
    var instance = $.data(this, 'chart'),
      chartInst;

    if (instance) {
      $(window).off('resize.line');
      $(window).off('resize.pie');
      $(window).off('resize.charts load.charts');
      $(this).empty();
    }

    chartInst = new Chart(this, options);
    instance = $.data(this, 'chart', chartInst);
    instance.settings = options;
    instance._selected = [];
    instance.getSelected = function() {
      return this._selected;
    };

    if ($.isEmptyObject(chartInst)) {
     return;
    }

    setTimeout(function () {
      chartInst.initChartType(options);
      chartInst.handleResize();
    }, instance ? 0 : 300);

  });
};

  $.fn.colorpicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'colorpicker',
        defaults = {

          // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])

          // BORDERS
          // Use (,) commas to separate themes or single entry for border as:
          // colors[{label: 'Slate', number: '01', value: 'F0F0F0', border: 'light-theme, high-contrast-theme'}]
          // and assign which swatch theborder should apply ['all' or 'matched-only']
          // themes: { 'high-contrast-theme': {'border': 'all'} }

          // CHECKMARKS
          // checkmark: {'one': [1, 2], 'two': [3, 10]}
          // will add class as "checkmark-{key}", where current colors number is in range [{value[0]} to {value[1]}]
          // will add class "checkmark-one", where current colors number is in range [1 to 3]
          // and will add class "checkmark-two", where current colors number is in range [3 to 10]
          themes: {
            'light': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'dark': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'high-contrast': {'border': 'all', checkmark: {'one': [1, 3], 'two': [4, 10]} }
          },
          colors: [
            {label: 'Slate', number: '10', value: '1a1a1a'},
            {label: 'Slate', number: '09', value: '292929'},
            {label: 'Slate', number: '08', value: '383838', border: 'dark'},
            {label: 'Slate', number: '07', value: '454545', border: 'dark'},
            {label: 'Slate', number: '06', value: '5C5C5C'},
            {label: 'Slate', number: '05', value: '737373'},
            {label: 'Slate', number: '04', value: '999999'},
            {label: 'Slate', number: '03', value: 'BDBDBD'},
            {label: 'Slate', number: '02', value: 'D8D8D8'},
            {label: 'Slate', number: '01', value: 'F0F0F0', border: 'light, high-contrast'},
            {label: 'Amber', number: '10', value: 'D66221'},
            {label: 'Amber', number: '09', value: 'DE7223'},
            {label: 'Amber', number: '08', value: 'E68425'},
            {label: 'Amber', number: '07', value: 'EB9728'},
            {label: 'Amber', number: '06', value: 'EFAA30'},
            {label: 'Amber', number: '05', value: 'F2BC41'},
            {label: 'Amber', number: '04', value: 'F4C951'},
            {label: 'Amber', number: '03', value: 'F7D475'},
            {label: 'Amber', number: '02', value: 'F8E09C'},
            {label: 'Amber', number: '01', value: 'FBE9BF'},
            {label: 'Ruby', number: '10', value: '880E0E'},
            {label: 'Ruby', number: '09', value: '941E1E'},
            {label: 'Ruby', number: '08', value: 'A13030'},
            {label: 'Ruby', number: '07', value: 'AD4242'},
            {label: 'Ruby', number: '06', value: 'B94E4E'},
            {label: 'Ruby', number: '05', value: 'C65F5F'},
            {label: 'Ruby', number: '04', value: 'D26D6D'},
            {label: 'Ruby', number: '03', value: 'DE8181'},
            {label: 'Ruby', number: '02', value: 'EB9D9D'},
            {label: 'Ruby', number: '01', value: 'F4BCBC'},
            {label: 'Turquoise', number: '10', value: '0E5B52'},
            {label: 'Turquoise', number: '09', value: '206B62'},
            {label: 'Turquoise', number: '08', value: '317C73'},
            {label: 'Turquoise', number: '07', value: '448D83'},
            {label: 'Turquoise', number: '06', value: '579E95'},
            {label: 'Turquoise', number: '05', value: '69ADA3'},
            {label: 'Turquoise', number: '04', value: '7BBFB5'},
            {label: 'Turquoise', number: '03', value: '8ED1C6'},
            {label: 'Turquoise', number: '02', value: 'A9E1D6'},
            {label: 'Turquoise', number: '01', value: 'C0EDE3'},
            {label: 'Emerald', number: '10', value: '397514'},
            {label: 'Emerald', number: '09', value: '44831F'},
            {label: 'Emerald', number: '08', value: '56932E'},
            {label: 'Emerald', number: '07', value: '66A140'},
            {label: 'Emerald', number: '06', value: '76B051'},
            {label: 'Emerald', number: '05', value: '89BF65'},
            {label: 'Emerald', number: '04', value: '9CCE7C'},
            {label: 'Emerald', number: '03', value: 'AFDC91'},
            {label: 'Emerald', number: '02', value: 'C3E8AC'},
            {label: 'Emerald', number: '01', value: 'D5F6C0'},
            {label: 'Amethyst', number: '10', value: '4B2A5E'},
            {label: 'Amethyst', number: '09', value: '5A3A6F'},
            {label: 'Amethyst', number: '08', value: '6C4B81'},
            {label: 'Amethyst', number: '07', value: '7D5F92'},
            {label: 'Amethyst', number: '06', value: '8E72A4'},
            {label: 'Amethyst', number: '05', value: 'A189B8'},
            {label: 'Amethyst', number: '04', value: 'B59ECA'},
            {label: 'Amethyst', number: '03', value: 'C7B4DB'},
            {label: 'Amethyst', number: '02', value: 'DACCEC'},
            {label: 'Amethyst', number: '01', value: 'EDE3FC'},
            {label: 'Azure', number: '10', value: '133C59'},
            {label: 'Azure', number: '09', value: '134D71'},
            {label: 'Azure', number: '08', value: '1D5F8A'},
            {label: 'Azure', number: '07', value: '2876A8'},
            {label: 'Azure', number: '06', value: '368AC0'},
            {label: 'Azure', number: '05', value: '4EA0D1'},
            {label: 'Azure', number: '04', value: '69B5DD'},
            {label: 'Azure', number: '03', value: '8DC9E6'},
            {label: 'Azure', number: '02', value: 'ADD8EB'},
            {label: 'Azure', number: '01', value: 'CBEBF4'}
          ],
          placeIn: null, // null|'editor'
          showLabel: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The ColorPicker Component is a trigger field with a listing colors that can be selected.
    *
    * @class ColorPicker
    * @param {String} colors  &nbsp;-&nbsp; An array of objects of the form {label: 'Azure', number: '01', value: 'CBEBF4'} that can be used to populate the color grid.
    * @param {String} showLabel  &nbsp;-&nbsp; Show the label if true vs the hex value if false.
    *
    */
    function ColorPicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ColorPicker.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build();
        this.handleEvents();
      },

      // Add the extra markup
      build: function() {
        this.isEditor = this.settings.placeIn === 'editor';
        var colorpicker = this.element,
          initialValue = this.isEditor ? this.element.attr('data-value') :  this.element.val();

        if (!this.isEditor) {
          //Add Button
          if (this.isInlineLabel) {
            this.inlineLabel.addClass('colorpicker-container');
          }
          else {
            this.container = $('<span class="colorpicker-container"></span>');
            colorpicker.wrap(this.container);
          }

          this.container = colorpicker.parent();
          this.swatch = $('<span class="swatch"></span>').prependTo(this.container);

          //Add Masking to show the #
          colorpicker.attr('data-mask', '*******').mask();
        }

        this.icon = $.createIconElement('dropdown')
          .appendTo(this.isEditor ? this.element : this.container);
        this.icon.wrap('<span class="trigger"></span>');

        if (initialValue && initialValue.substr(0,1) !== '#' && !this.settings.showLabel) {
          initialValue = '#' + initialValue;
          this.element.attr(this.isEditor ? 'data-value' : 'value', initialValue);
        }

        if (initialValue && this.settings.showLabel) {
          var hexValue = this.getHexFromLabel(initialValue);
          this.setColor(hexValue);
          this.element.attr(this.isEditor ? 'data-value' : 'value', hexValue);
        }

        if (initialValue && initialValue.length === 7 && !this.settings.showLabel) {
          this.setColor(initialValue);
          this.element.attr(this.isEditor ? 'data-value' : 'value', initialValue);
        }

         if (this.element.is(':disabled')) {
          this.disable();
        }

        this.addAria();
      },

      getHexFromLabel: function(label) {
        for (var i = 0; i < this.settings.colors.length; i++) {
          var data = this.settings.colors[i];

          if (label === data.label + data.number) {
            return data.value;
          }
        }
      },

      // Add/Update Aria
      addAria: function () {
        this.element.attr('role', 'combobox').attr('aria-autocomplete', 'list');

        $('label[for="'+ this.element.attr('id') + '"]')
          .append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      // Toggle / Open the List
      toggleList: function () {
        var self = this,
          menu =  $('#colorpicker-menu');

        if (self.element.is(':disabled')) {
          return;
        }

        if (menu.length) {
          var isPickerOpen = self.isPickerOpen;
          $(document).trigger($.Event('keydown', {keyCode: 27, which: 27})); // escape

          if (isPickerOpen) {
            return;
          }
        }

        //Append Color Menu
        menu =  self.updateColorMenu();

        var popupmenuOpts = {
          ariaListbox: true,
          menuId: 'colorpicker-menu',
          trigger: 'immediate',
          placementOpts: {
            containerOffsetX: 10,
            containerOffsetY: 10,
            parentXAlignment: (Locale.isRTL() ? 'right': 'left'),
            strategies: ['flip', 'nudge', 'shrink']
          },
          offset: {
            x: 0,
            y: 10
          }
        };

        // Show Menu
        self.element
        .popupmenu(popupmenuOpts)
        .on('open.colorpicker', function () {
          self.element.parent().addClass('is-open');
          self.isPickerOpen = true;
        })
        .on('close.colorpicker', function () {
          menu.on('destroy.colorpicker', function () {
            $(this).off('destroy.colorpicker').remove();
          });
          self.element.parent().removeClass('is-open');
          self.isPickerOpen = false;
        })
        .on('selected.colorpicker', function (e, item) {
          if (!self.isEditor) {
            self.element.val(self.settings.showLabel ? item.data('label') : '#'+item.data('value'));
            self.swatch[0].style.backgroundColor = '#' + item.data('value');
          }
          self.element.focus();
        });

        //Append Buttons
        this.menu = $('#colorpicker-menu');

        setTimeout(function () {
          self.menu.find('.is-selected').focus();
        }, 1);
      },

      /**
      * Set the Visible Color
      * @param {String} hex  &nbsp;-&nbsp; The hex value to use (can have the # or not).
      * @param {String} text  &nbsp;-&nbsp; The text to display
      */
      setColor: function (hex, text) {
        // Make sure there is always a hash
        if (hex.substr(0,1) !== '#') {
          hex = '#' + hex;
          this.element.attr(this.isEditor ? 'data-value' : 'value', hex);
        }

        if (hex.length !== 7) {
          return;
        }

        if (!this.isEditor) {
          this.swatch[0].style.backgroundColor = hex;
        }
        this.element.attr('aria-describedby', text);
      },

      // Refresh and Append the Color Menu
      updateColorMenu: function () {
        var isMenu =  !!($('#colorpicker-menu').length),
          self = this,
          menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>'),
          currentTheme = Soho.theme;

        var isBorderAll = (settings.themes[currentTheme].border === 'all'),
          checkmark = settings.themes[currentTheme].checkmark,
          checkmarkClass = '';

        for (var i = 0, l = settings.colors.length; i < l; i++) {
          var li = $('<li></li>'),
            a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li),
            number = settings.colors[i].number,
            num = parseInt(number, 10),
            text = (Locale.translate(settings.colors[i].label) || settings.colors[i].label) + (settings.colors[i].number || ''),
            value = settings.colors[i].value,
            isBorder = false,
            regexp = new RegExp('\\b'+ currentTheme +'\\b'),
            elemValue = this.isEditor ? this.element.attr('data-value') : this.element.val();

          if (self.settings.showLabel && !this.isEditor) {
            elemValue = this.getHexFromLabel(elemValue);
          }

          // Set border to this swatch
          if (isBorderAll || regexp.test(settings.colors[i].border)) {
            isBorder = true;
          }

          if (elemValue && (elemValue + '').toLowerCase().replace('#', '') === (value + '').toLowerCase()) {
            // Set checkmark color class
            if (checkmark) {
              $.each(checkmark, function(k, v) {
                // checkmark: {'one': [1, 2], 'two': [3, 10]}
                // will add class "checkmark-one", where current colors number is in range [1 to 3]
                // and will add class "checkmark-two", where current colors number is in range [3 to 10]
                if ((num >= v[0]) && (num <= v[1])) {
                  checkmarkClass = ' checkmark-'+ k;
                }
              });
            }
            a.addClass('is-selected'+ checkmarkClass);
          }

          var swatch = a.find('.swatch');
          if (swatch[0]) {
            swatch[0].style.backgroundColor = '#'+ value;
          }
          swatch.addClass(isBorder ? 'is-border' : '');
          a.data('label', text)
            .data('value', value)
            .attr('title', text +' #'+ value)
            .tooltip();

          // menu.append(li);
          if (!isMenu) {
            menu.append(li);
          }
        }

        if (!isMenu) {
          $('body').append(menu);
        }

        return menu;
      },

      /**
      * Change the color picker from enabled to disabled.
      */
      enable: function() {
        this.element.prop('disabled', false);
        this.element.parent().removeClass('is-disabled');
      },

      /**
      * Make the color picker disabled
      */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      /**
      * Returns true if the color picker is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      decimal2rgb: function(n) {
        if (typeof n !== 'number') {
          return n;
        }
        return 'rgb('+
          (n & 0xFF) +', '+
          ((n & 0xFF00) >> 8) +', '+
          ((n & 0xFF0000) >> 16 ) +
        ')';
      },

      rgb2hex: function (rgb) {
        if (rgb.search('rgb') === -1) {
          return rgb;
        }
        else if (rgb === 'rgba(0, 0, 0, 0)') {
          return 'transparent';
        }
        else {
          var hex = function (x) {
            return ('0' + parseInt(x).toString(16)).slice(-2);
          };
          rgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
          return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
        }
      },

      /**
      * Detach events and restore DOM to default.
      */
      destroy: function() {
        this.swatch.remove();
        this.element.off('keypress.colorpicker');
        this.swatch.off('click.colorpicker');
        $.removeData(this.element[0], pluginName);
      },

    /**
     *  This component fires the following events.
     *
     * @fires About#events
     * @param {Object} change  &nbsp;-&nbsp; Fires when a color is typed or selected.
     * @param {Object} blur  &nbsp;-&nbsp; Fires as the input looses focus
     *
     */
      handleEvents: function () {
        var self = this;
        this.icon.parent().onTouchClick().on('click.colorpicker', function () {
          self.toggleList();
        });

        this.element.on('focus.colorpicker', function () {
          $(this).parent().addClass('is-focused');
        })
        .on('blur.colorpicker', function () {
          $(this).parent().removeClass('is-focused');
        });

        this.element.on('keypress.colorpicker', function () {
          self.setColor($(this).val());
        }).on('change.colorpicker', function () {
          self.setColor($(this).val());
        });

        //Handle Key Down to open
        this.element.on('keydown.colorpicker', function (e) {
          if (e.keyCode === 38 || e.keyCode === 40) {
            self.toggleList();
          }
        });
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ColorPicker(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.compositeform = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'compositeform',
        defaults = {
          trigger: null,
          expandedText: Locale.translate('ShowLess'),
          collapsedText: Locale.translate('ShowMore'),
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class CompositeForm
    * @param {String} trigger  &nbsp;-&nbsp; Expandable area trigger selector. Passed to expandable area.
    * @param {String} expandedText  &nbsp;-&nbsp; Text to use for the expand button (Default localized)
    * @param {String} collapsedText  &nbsp;-&nbsp; Text to use for the collapse button (Default localized)
    *
    */
    function CompositeForm(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    CompositeForm.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      /**
       * Adds markup to the control and stores references to some sub-elements
       * @returns {this}
       */
      build: function() {
        var classList = this.element[0].classList;
        if (!classList.contains('composite-form')) {
          classList.add('composite-form');
        }

        // Get expandable area reference, if applicable
        var expandableArea = this.element.find('.expandable-area');
        if (expandableArea.length) {
          this.hasSummary = true;
          this.expandableArea = expandableArea;
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
          if (!this.expandableAreaAPI) {
            this.expandableArea.expandablearea({ trigger: this.settings.trigger });
            this.expandableAreaAPI = this.expandableArea.data('expandablearea');
          }

          // Get expandable trigger
          this.expander = this.expandableAreaAPI.expander;
          this.setExpanderText(this.settings.expandedText);
        } else {
          this.hasSummary = false;
        }

        // Check size and append class, if necessary
        this.checkResponsive();

        return this;
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      handleEvents: function() {
        var self = this;

        $('body').on('resize.' + pluginName, function(e) {
          self.checkResponsive(e);
        });

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        function changeExpanderText() {
          var isExpanded = self.expandableAreaAPI.isExpanded();
          self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
        }

        if (this.hasSummary) {
          this.expandableArea
            .on('expand.' + pluginName, changeExpanderText)
            .on('collapse.' + pluginName, changeExpanderText);
        }

        return this;
      },

      /**
       * Checks if we've passed the breakpoint for switching into Responsive mode.
       * @returns {undefined}
       */
      checkResponsive: function() {
        var cl = this.element[0].classList;

        if (Soho.breakpoints.isBelow('phone-to-tablet')) {
          cl.add('is-in-responsive-mode');
        } else {
          cl.remove('is-in-responsive-mode');
        }
      },

      /**
       * Sets the text content of the Composite Form's Expandable Area Expander.
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      setExpanderText: function(expanderText) {
        if (!this.hasSummary) {
          return;
        }

        if (!(expanderText instanceof String) || !expanderText.length) {
          return;
        }

        var textSpan = this.expander.find('span');
        if (!textSpan) {
          textSpan = this.expander;
        }
        textSpan.text(expanderText);
      },

      /**
       * Re-invokes the Composite Form
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Simple Teardown - remove events & rebuildable markup.
       * @returns {this}
       */
      teardown: function() {
        $('body').off('resize.' + pluginName);
        this.element.off('updated.' + pluginName);

        if (this.hasSummary) {
          this.expandableArea.off('expand.' + pluginName + ' collapse.' + pluginName);
        }

        return this;
      },

      /**
       * Destroys the component instance by removing it from its associated element.
       * @returns {this}
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CompositeForm(this, settings));
      }
    });
  };


  $.fn.contextualactionpanel = function(options) {

    // Settings and Options
    var pluginName = 'contextualactionpanel',
        defaults = {
          id: 'contextual-action-modal-' + (parseInt($('.modal').length, 10)+1),
          buttons: null, // List of buttons that will sit in the toolbar's Buttonset area
          title: 'Contextual Action Panel', // string that fits into the toolbar's Title field
          content: null, //Pass content through to modal
          initializeContent: true, // initialize content before opening
          trigger: 'click'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ContextualActionPanel(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ContextualActionPanel.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.panel = this.element.next('.contextual-action-panel');
        if (this.panel[0]) {
          this.panel[0].style.display = 'none';
        }
        this.panel.addClass('is-animating');
        return this;
      },

      build: function() {
        var self = this;

        // Build the Content
        if (this.panel.length === 0) {
          if (this.settings.content  instanceof jQuery) {

            if (this.settings.content.is('.contextual-action-panel')) {
              this.panel = this.settings.content;
            } else {
              this.settings.content.wrap('<div class="contextual-action-panel"></div>');
              this.panel = this.settings.content.parent();
            }

            this.panel.addClass('modal').appendTo('body');

            if (this.settings.content.is('iframe')) {
              this.settings.content.ready(function () {
                self.completeBuild();
                self.settings.content.show();
              });
              return self;
            }
            this.settings.content.show();

          } else {
            this.panel = $('<div class="contextual-action-panel">'+ this.settings.content +'</div>').appendTo('body');
            this.panel.addClass('modal').attr('id', this.settings.id);
          }

        }

        this.completeBuild();
        return this;
      },

      completeBuild: function() {
        var self = this,
          children,
          isIframe = false,
          contents;

        this.panel.find('svg').icon();

        if (this.panel.find('.modal-content').length === 0) {
          children = this.panel.children();
          if (children.is('iframe')) {
            contents = children.contents();
            this.toolbar = contents.find('.toolbar');
            isIframe = true;
          }

          if (!isIframe) {
            children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
            this.panel.addClass('modal');
          }
        }

        if (this.panel.find('.modal-header').length === 0) {
          this.header = $('<div class="modal-header"></div>');
          this.header.insertBefore(this.panel.find('.modal-body'));

          if (!this.toolbar) {
            this.toolbar = this.panel.find('.toolbar');
          }

          if (!this.toolbar.length) {
            this.toolbar = $('<div class="toolbar"></div>');
          }

          this.toolbar.appendTo(this.header);
          var toolbarTitle = this.toolbar.find('.title');
          if (!toolbarTitle.length) {
            toolbarTitle = $('<div class="title">' + this.settings.title + '</div>');
            this.toolbar.prepend(toolbarTitle);
          }

          var toolbarButtonset = this.toolbar.find('.buttonset');
          if (!toolbarButtonset.length) {
            toolbarButtonset = $('<div class="buttonset"></div>');
            toolbarButtonset.insertAfter(toolbarTitle);
          }
        }

        // Move to the body element to break stacking context issues.
        if (!isIframe) {
          this.panel.detach().appendTo('body');
        }

        this.element.attr('data-modal', this.settings.id);
        if (!this.panel.attr('id')) {
          this.panel.attr('id', this.settings.id);
        }

        this.panel.modal({
          buttons: self.settings.buttons,
          trigger: (self.settings.trigger ? self.settings.trigger : 'click')
        });

        this.buttons = this.panel.find('.buttonset').children('button');
        this.closeButton = this.buttons.filter('.btn-close, [name="close"], .icon-close');

        if (!this.toolbar) {
          this.toolbar = this.panel.find('.toolbar');
        }

        if (this.toolbar.length) {
          this.toolbar.toolbar();
        }

        Soho.utils.fixSVGIcons(this.element);
        return this;
      },

      handleEvents: function() {
        var self = this;

        // Convenience method that takes an event from the Modal control's panel element,
        // and triggers any listeners that may be looking at the Contextual Action Panel's trigger instead.
        function passEvent(e) {
          self.element.triggerHandler(e.type);
        }

        this.panel.addClass('is-animating').on('open.contextualactionpanel', function(e) {
          passEvent(e);
          self.panel.removeClass('is-animating');
        }).on('beforeclose.contextualactionpanel', function() {
          self.panel.addClass('is-animating');
        }).on('close.contextualactionpanel', function(e) {
          passEvent(e);
        }).on('beforeopen.contextualactionpanel', function(e) {
          if (self.settings.initializeContent) {
            $(this).initialize();
          }
          passEvent(e);
        }).on('afteropen.contextualactionpanel', function() {
          if (self.toolbar) {
            self.toolbar.trigger('recalculate-buttons');
          }

          // Select the proper element on the toolbar
          if (self.toolbar.length) {
            var selected = self.toolbar.find('.buttonset > .is-selected');
            if (!selected.length) {
              selected = self.toolbar.find('.buttonset > *:first-child');
              if (selected.is('.searchfield-wrapper')) {
                selected = selected.children('.searchfield');
              }
            }
            self.toolbar.data('toolbar').setActiveButton(selected, true);
          }

          // Focus the first focusable element inside the Contextual Panel's Body
          self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
          Soho.utils.fixSVGIcons(self.panel);
        }).on('beforedestroy.contextualactionpanel', function() {
          self.teardown();
        });

        if (this.toolbar)  {
          this.toolbar.children('.buttonset').children('.btn-close, [name="close"], .icon-close')
            .onTouchClick('contextualactionpanel').on('click.contextualactionpanel', function() {
            self.handleToolbarSelected();
          });
        }

        return this;
      },

      handleToolbarSelected: function() {
        this.close();
      },

      teardown: function() {
        var self = this,
          buttonset = self.toolbar.children('.buttonset');

        this.panel.off('open.contextualactionpanel close.contextualactionpanel ' +
          'beforeopen.contextualactionpanel afterclose.contextualactionpanel');

        buttonset.children('*:not(.searchfield)')
          .offTouchClick('contextualactionpanel').off('click.contextualactionpanel');

        var menuButtons = buttonset.children('.btn-menu');
        menuButtons.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.destroy();
          }
        });

        //self.panel.detach().insertAfter(self.element);
        var toolbar = self.toolbar.data('toolbar');
        if (toolbar) {
          toolbar.destroy();
        }

        if (self.header){
          self.header.remove();
        }

        var children = self.panel.find('.modal-body').children();
        children.first().unwrap().unwrap(); // removes $('.modal-body'), then $('.modal-content')

        self.element.removeAttr('data-modal');

        // Trigger an afterclose event on the Contextual Action Panel's trigger element (different from the panel, which is already removed).
        self.element.trigger('afterteardown');
      },

      close: function() {
        var destroy;
        if (this.settings.trigger === 'immediate') {
          destroy = true;
        }
        if (this.panel.data('modal')) {
          this.panel.data('modal').close(destroy);
        }
      },

      disable: function() {
        this.element.prop('disabled', true);
        if (this.panel.hasClass('is-visible')) {
          this.close();
        }
      },

      enable: function() {
        this.element.prop('disabled', false);
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        this.panel.data('modal').destroy();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {

        instance.settings = $.extend({}, instance.settings, options);
        if (settings.trigger === 'immediate') {
          instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
        }

      } else {
        instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
      }
    });
  };


  $.fn.datepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'datepicker',
        defaults = {
          showTime: false,
          timeFormat: undefined,
          minuteInterval: undefined,
          secondInterval: undefined,
          mode: undefined,
          roundToInterval: undefined,
          dateFormat: 'locale', //or can be a specific format like 'yyyy-MM-dd' iso8601 format
          placeholder: false,
          /*  Disabling of dates
          **    dates: 'M/d/yyyy' or
          **      ['M/d/yyyy'] or
          **      ['M/d/yyyy', new Date('M/d/yyyy')] or
          **      ['M/d/yyyy', new Date('M/d/yyyy'), new Date(yyyy,(M-0),d)]
          **    minDate: 'M/d/yyyy'
          **    maxDate: 'M/d/yyyy'
          **    dayOfWeek: [2] or [0,6] - {0-sun, 1-mon, 2-tue, 3-wed, 4-thu, 5-fri, 6-sat}
          **    isEnable: false or true
          **/
          disable: {
            'dates'     : [],
            'minDate'   : '',
            'maxDate'   : '',
            'dayOfWeek' : [],
            'isEnable' : false
          },
          showLegend: false,
          legend: [
            //Legend Build up example
            //Color in level 6 - http://usmvvwdev53:424/controls/colors
            {name: 'Public Holiday', color: '#76B051', dates: []},
            {name: 'Weekends', color: '#EFA836', dayOfWeek: []}
          ]
        },
        settings = $.extend({}, defaults, options);

    /**
    * A component to support date entry.
    *
    * @class DatePicker
    * @param {Boolean} showTime  &nbsp;-&nbsp; If true the time selector will be shown.
    * @param {String} timeFormat  &nbsp;-&nbsp; The format to use on the time section fx HH:mm, defaults to current locale's settings.
    * @param {String} mode  &nbsp;-&nbsp; Time picker mode: options: 'standard', 'range', this controls the avilable selections in the time picker.
    * @param {Boolean} roundToInterval  &nbsp;-&nbsp; In time picker mode, if a non-matching minutes value is entered, rounds the minutes value to the nearest interval when the field is blurred.
    * @param {String} dateFormat  &nbsp;-&nbsp; Defaults to current locale but can be overriden to a specific format
    * @param {Boolean} disable  &nbsp;-&nbsp; Disabled Dates Build up. `{
      'dates'     : [],
      'minDate'   : '',
      'maxDate'   : '',
      'dayOfWeek' : [],
      'isEnable' : false
    }`
    * @param {Boolean} showLegend  &nbsp;-&nbsp; If true a legend is show to associate dates.
    * @param {Array} legend  &nbsp;-&nbsp; Legend Build up for example `[{name: 'Public Holiday', color: '#76B051', dates: []}, {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
    *
    */
    function DatePicker(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    DatePicker.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        //Append a trigger button
        this.trigger = $.createIconElement('calendar').insertAfter(this.element);
        this.addAria();

        this.isIslamic = Locale.calendar().name === 'islamic-umalqura';
        this.conversions = Locale.calendar().conversions;
      },

      addAria: function () {
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('PressDown') + '</span>');
      },

      // Handle Keyboard Stuff
      handleKeys: function (elem) {
        var self = this;

        if (elem.is('#calendar-popup')) {
          elem.off('keydown.datepicker').on('keydown.datepicker', '.calendar-table', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0;

            //Arrow Down: select same day of the week in the next week
            if (key === 40) {
                handled = true;
                self.currentDate.setDate(self.currentDate.getDate() + 7);
                self.insertDate(self.currentDate);
            }

            //Arrow Up: select same day of the week in the previous week
            if (key === 38) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 7);
              self.insertDate(self.currentDate);
            }

            //Arrow Left
            if (key === 37) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 1);
              self.insertDate(self.currentDate);
            }

            //Arrow Right
            if (key === 39) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() + 1);
              self.insertDate(self.currentDate);
            }

            //Page Up Selects Same Day Next Month
            if (key === 33 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() + 1);
              self.insertDate(self.currentDate);
            }

            //Page Down Selects Same Day Prev Month
            if (key === 34 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() - 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Up Selects Same Day Next Year
            if (key === 33 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() + 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Down Selects Same Day Prev Year
            if (key === 34 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() - 1);
              self.insertDate(self.currentDate);
            }

            //Home Moves to End of the month
            if (key === 35) {
              handled = true;
              var lastDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth()+1, 0);
              self.currentDate = lastDay;
              self.insertDate(self.currentDate);
            }

            //End Moves to Start of the month
            if (key === 36) {
              var firstDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth(), 1);
              self.currentDate = firstDay;
              self.insertDate(self.currentDate);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            // Space or Enter closes Date Picker, selecting the Date
            if (key === 32 || key === 13) {
              self.closeCalendar();
              self.element.focus();
              handled = true;
            }

            // Tab closes Date Picker and goes to next field
            if (key === 9) {
              if (!self.settings.showTime) {
                self.element.focus();
                self.closeCalendar();
              }
            }

            // Esc closes Date Picker and goes back to field
            if (key === 27) {
              self.closeCalendar();
              self.element.focus();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });
        }
        else {
          elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0,
              focused = $(':focus'),
              focusedlabel = focused.attr('aria-label');

            // Focus did not auto move from readonly
            if (key === 9 && self.element.is('[readonly]')) { //tab
              self.setFocusOnFocusableElement(self.element, (e.shiftKey ? 'prev' : 'next'));
              return;
            }

            if (focusedlabel) {
              var focusedDate = new Date(focusedlabel);
              self.currentDate = new Date(focusedDate.getTime());
            } else if (focused.hasClass('alternate')) {
                var year = parseInt(self.header.find('.year').text()),
                month = parseInt(self.header.find('.month').attr('data-month')),
                day = parseInt(focused.text());

              if (focused.hasClass('prev-month')) {
                if(month === 0) {
                  month = 11;
                  year--;
                }
                else {
                  month--;
                }
              } else if (focused.hasClass('next-month')) {
                if(month === 11) {
                  month = 0;
                  year++;
                }
                else {
                  month++;
                }
              }
              self.currentDate = new Date(year, month, day);
            }

           //Arrow Down or Alt first opens the dialog
            if (key === 40 && !self.isOpen()) {
              handled = true;
              self.openCalendar();

              setTimeout(function() {
                self.setFocusAfterOpen();
              }, 200);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });
        }

      },

      //Parse the Date Format Options
      setFormat: function () {
        var localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat : null),
          localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null);

        if (this.settings.dateFormat === 'locale') {
          this.pattern = localeDateFormat.short + (this.settings.showTime ? ' ' + (this.settings.timeFormat || localeTimeFormat) : '');
        } else {
          this.pattern = this.settings.dateFormat + (this.settings.showTime && this.settings.timeFormat ? ' ' + this.settings.timeFormat : '');
        }

        this.show24Hours = (this.pattern.match('HH') || []).length > 0;
        this.isSeconds = (this.pattern.match('ss') || []).length > 0;
      },

      // Add masking with the mask function
      mask: function () {
        this.setFormat();

        var validation = 'date availableDate',
          events = {'date': 'blur', 'availableDate': 'blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events'),
          mask = this.pattern.toLowerCase()
                   .replace(/yyyy/g,'####')
                   .replace(/mmmm/g,'*********')
                   .replace(/mmm/g,'***')
                   .replace(/mm/g,'##')
                   .replace(/dd/g,'##')
                   .replace(/hh/g,'##')
                   .replace(/ss/g,'##')
                   .replace(/[mdh]/g,'##')
                   .replace(/[a]/g,'am');

        //TO DO - Time seperator
        // '##/##/#### ##:## am' -or- ##/##/#### ##:##' -or- ##/##/####'
        // '##/##/#### ##:##:## am' -or- ##/##/#### ##:##:##'
        mask = (this.settings.showTime ?
          (this.show24Hours ? mask.substr(0, (this.isSeconds ? 19:16)) : mask) : mask);

        if (customValidation === 'required' && !customEvents) {
          validation = customValidation + ' ' + validation;
          $.extend(events, {'required': 'change blur'});
        } else if (!!customValidation && !!customEvents) {
          // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
          if (customValidation.indexOf('no-default-validation') > -1) {
            validation = customValidation.replace(/no-default-validation/g, '');
            events = $.fn.parseOptions(this.element, 'data-validation-events');
          }
          // Keep default validation along custom validation
          else {
            validation = customValidation + ' ' + validation;
            $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
          }
        }

        this.element
          .attr({
            'data-mask': mask,
            'data-validate': validation,
            'data-validation-events': JSON.stringify(events),
            'data-mask-mode': 'date'
          }).mask().validate();

        if (this.settings.placeholder && (!this.element.attr('placeholder') ||  this.element.attr('placeholder') === 'M / D / YYYY')) {
          this.element.attr('placeholder', this.pattern);
        }
      },

      /**
      * Return whether or not the calendar div is open.
      */
      isOpen: function () {
        return (this.popup && this.popup.is(':visible') &&
          !this.popup.hasClass('is-hidden'));
      },

      /**
      * Open the Calendar Popup.
      */
      open: function() {
        return this.openCalendar();
      },

      activeTabindex: function(elem, isFocus) {
        $('td', this.days).removeAttr('tabindex');
        elem.attr('tabindex', 0);

        if (isFocus) {
          elem.focus();
        }
        return elem;
      },

      // Open the calendar in a popup
      openCalendar: function () {
        var self = this,
          timeOptions = {};


        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        $('#validation-tooltip').addClass('is-hidden');


        this.element.addClass('is-active').trigger('listopened');

        // Calendar Html in Popups
        var prevButton = '<button type="button" class="btn-icon prev">' + $.createIcon('caret-left') + '<span>'+ Locale.translate('PreviousMonth') +'</span></button>',
            nextButton = '<button type="button" class="btn-icon next">' + $.createIcon('caret-right') + '<span>'+ Locale.translate('NextMonth') +'</span></button>';

        this.table = $('<table class="calendar-table" aria-label="'+ Locale.translate('Calendar') +'" role="application"></table>');
        this.header = $('<div class="calendar-header"><span class="month">november</span><span class="year">2015</span>'+ (Locale.isRTL() ? prevButton + nextButton : prevButton + nextButton) +'</div>');
        this.dayNames = $('<thead><tr><th>SU</th> <th>MO</th> <th>TU</th> <th>WE</th> <th>TH</th> <th>FR</th> <th>SA</th> </tr> </thead>').appendTo(this.table);
        this.days = $('<tbody> <tr> <td class="alternate">26</td> <td class="alternate">27</td> <td class="alternate">28</td> <td class="alternate">29</td> <td class="alternate" >30</td> <td class="alternate">31</td> <td>1</td> </tr> <tr> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> </tr> <tr> <td>9</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td> </tr> <tr> <td>16</td> <td>17</td> <td>18</td> <td>19</td> <td class="is-today">20</td> <td>21</td> <td>22</td> </tr> <tr> <td>23</td> <td>24</td> <td>25</td> <td>26</td> <td>27</td> <td>28</td> <td class="alternate">1</td> </tr> <tr> <td class="alternate">2</td> <td class="alternate">3</td> <td class="alternate">4</td> <td class="alternate">5</td> <td class="alternate">6</td> <td class="alternate">7</td> <td class="alternate">8</td> </tr> </tbody>').appendTo(this.table);
        this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
        this.footer = $('<div class="popup-footer"> <button type="button" class="cancel btn-tertiary">'+ Locale.translate('Clear') +'</button> <button type="button" class="is-today btn-tertiary">'+Locale.translate('Today')+'</button> </div>');

        // Timepicker options
        if (this.settings.showTime) {
          if (this.settings.timeFormat === undefined) {
            // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
            timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' '));
          }
          else {
            timeOptions.timeFormat = this.settings.timeFormat;
          }
          if (this.settings.minuteInterval !== undefined) {
            timeOptions.minuteInterval = this.settings.minuteInterval;
          }
          if (this.settings.secondInterval !== undefined) {
            timeOptions.secondInterval = this.settings.minuteInterval;
          }
          if (this.settings.mode !== undefined) {
            timeOptions.mode = this.settings.mode;
          }
          if (this.settings.roundToInterval !== undefined) {
            timeOptions.roundToInterval = this.settings.roundToInterval;
          }

        }

        this.calendar = $('<div class="calendar'+ (this.settings.showTime ? ' is-timepicker' : '') +'"></div')
          .append(
            this.header,
            this.table,
            (this.settings.showTime ? this.timepickerContainer : ''),
            this.footer
          );

        var placementParent = this.element,
          placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
          parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        var popoverOpts = {
          content: this.calendar,
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#calendar-popup'
        };

        this.trigger.popover(popoverOpts)
        .off('show.datepicker').on('show.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            $('head').triggerHandler('disable-zoom');
          }
          // Horizontal view on mobile
          if (window.innerHeight < 400) {
            self.popup.find('.arrow').hide();
            self.popup.css('min-height', (self.popupClosestScrollable[0].scrollHeight + 2) +'px');
            self.popupClosestScrollable.css('min-height', '375px');
          }
        })
        .off('hide.datepicker').on('hide.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            self.trigger.one('hide', function() {
              $('head').triggerHandler('enable-zoom');
            });
          }
          self.popupClosestScrollable.add(self.popup).css('min-height', 'inherit');
          self.closeCalendar();
        });

        this.handleKeys($('#calendar-popup'));
        $('.calendar-footer a', this.calendar).button();

        // Show Month
        this.setValueFromField();

        // Set timepicker
        if (this.settings.showTime) {

          //Set to 12:00
          if (this.element.val() === '') {
            this.currentDate.setHours(0);
            this.currentDate.setMinutes(0);
            this.currentDate.setSeconds(0);
          }

          timeOptions.parentElement = this.timepickerContainer;
          this.time = self.getTimeString(this.currentDate, self.show24Hours);
          this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
          this.timepickerContainer.find('dropdown').dropdown();

          // Wait for timepicker to initialize
          setTimeout(function() {
            self.timepicker.initValues = self.timepicker.getTimeFromField(self.time);
            self.timepicker.afterShow(self.timepickerContainer);
            return;
          }, 1);
        }

        this.todayDate = new Date();
        this.todayMonth = this.todayDate.getMonth();
        this.todayYear = this.todayDate.getFullYear();
        this.todayDay = this.todayDate.getDate();

        if (this.isIslamic) {
          this.todayDateIslamic = this.conversions.fromGregorian(this.todayDate);
          this.todayYear = this.todayDateIslamic[0];
          this.todayMonth = this.todayDateIslamic[1];
          this.todayDay = this.todayDateIslamic[2];
        }

        this.showMonth(this.currentMonth, this.currentYear);
        this.popup = $('#calendar-popup');
        this.popupClosestScrollable = this.popup.closest('.scrollable');
        this.popup.attr('role', 'dialog');
        this.originalDate = this.element.val();

        // Calendar Day Events
        this.days.off('click.datepicker').on('click.datepicker', 'td', function () {
          var td = $(this);
          if (td.hasClass('is-disabled')) {
            self.activeTabindex(td, true);
          }
          else {
            self.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected');

            var cell = $(this),
              year = parseInt(self.header.find('.year').text()),
              month = parseInt(self.header.find('.month').attr('data-month')),
              day = parseInt(cell.addClass('is-selected').attr('aria-selected', 'true').text());

            if (cell.hasClass('prev-month')) {
              if(month === 0) {
                month = 11;
                year--;
              }
              else {
                month--;
              }
            }
            else if (cell.hasClass('next-month')) {
              if(month === 11) {
                month = 0;
                year++;
              }
              else {
                month++;
              }
            }

            self.currentDate = new Date(year, month, day);

            if (self.isIslamic) {
              self.currentDateIslamic[0] = year;
              self.currentDateIslamic[1] = month;
              self.currentDateIslamic[2] = day;
              self.currentYear = self.currentDateIslamic[0];
              self.currentMonth = self.currentDateIslamic[1];
              self.currentDay = self.currentDateIslamic[2];
              self.currentDate = self.conversions.toGregorian(self.currentDateIslamic[0], self.currentDateIslamic[1], self.currentDateIslamic[2]);
            }

            self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
            self.closeCalendar();
            self.element.focus();
          }
        });

        // Calendar Footer Events
        this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
          var btn = $(this);

          if (btn.hasClass('cancel')) {
            self.element.val('').trigger('change').trigger('input');
            self.currentDate = null;
            self.closeCalendar();
          }

          if (btn.hasClass('is-today')) {
            self.setToday();
            self.closeCalendar();
          }
          self.element.focus();
          e.preventDefault();
        });

        // Change Month Events
        this.header.off('click.datepicker').on('click.datepicker', 'button', function () {
          self.showMonth(self.currentMonth + ($(this).hasClass('next') ? 1 : -1), self.currentYear);
        });

        setTimeout(function() {
          self.setFocusAfterOpen();
        }, 200);

      },

      /**
      * Close the calendar popup.
      */
      close: function() {
        return this.closeCalendar();
      },

      // Close the calendar in a popup
      closeCalendar: function () {
        // Close timepicker
        if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
          this.timepickerControl.closeTimePopup();
        }

        if (this.popup && this.popup.length) {
          this.popup.hide().remove();
        }

        var popoverAPI = this.trigger.data('tooltip');
        if (popoverAPI) {
          popoverAPI.destroy();
        }

        if (this.element.hasClass('is-active')) {
          this.element.trigger('listclosed');
          this.element.removeClass('is-active');
        }
      },

      // Check through the options to see if the date is disabled
      isDateDisabled: function (year, month, date) {
        var d, i, l,
          self = this,
          d2 = new Date(year, month, date),
          min = (new Date(this.settings.disable.minDate)).setHours(0,0,0,0),
          max = (new Date(this.settings.disable.maxDate)).setHours(0,0,0,0);

        //dayOfWeek
        if(this.settings.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
          return true;
        }

        d2 = d2.setHours(0,0,0,0);

        //min and max
        if ((d2 <= min) || (d2 >= max)) {
          return true;
        }

        //dates
        if (this.settings.disable.dates.length && typeof this.settings.disable.dates === 'string') {
          this.settings.disable.dates = [this.settings.disable.dates];
        }

        for (i=0, l=this.settings.disable.dates.length; i<l; i++) {
          d = new Date(self.settings.disable.dates[i]);
          if(d2 === d.setHours(0,0,0,0)) {
            return true;
          }
        }

        return false;
      },

      // Set disable Date
      setDisabled: function (elem, year, month, date) {
        var dateIsDisabled = this.isDateDisabled(year, month, date);
        elem.removeClass('is-disabled').removeAttr('aria-disabled');

        if ((dateIsDisabled && !this.settings.disable.isEnable) || (!dateIsDisabled && this.settings.disable.isEnable)) {
          elem
            .addClass('is-disabled').attr('aria-disabled','true')
            .removeClass('is-selected').removeAttr('aria-selected');
        }
      },

      //Add a Legend below the table
      addLegend: function () {
        if (!this.settings.showLegend) {
          return;
        }

        //Remove Legend
        if (this.legend && this.legend.length) {
          this.legend.remove();
        }

        this.legend = $('<div class="calendar-legend"></div>');

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i],
            item = '<div class="calendar-legend-item">' +
              '<span class="calendar-legend-swatch" style="background-color:' + this.hexToRgba(series.color, 0.3) + '"></span>' +
              '<span class="calendar-legend-text">' + series.name + '</span></div>';

          this.legend.append(item);
        }

        this.table.after(this.legend);
      },

      // Set Color for the Legend settings
      setLegendColor: function (elem, year, month, date) {
        if (!this.settings.showLegend || !elem[0]) {
          return;
        }

        var hex = this.getLegendColor(year, month, date),
          self = this;

        elem[0].style.backgroundColor = '';

        if (hex) {
          //set color on elem at .3 of provided color as per design
          elem.addClass('is-colored');
          elem[0].style.backgroundColor = this.hexToRgba(hex, 0.3);

          var normalColor = self.hexToRgba(hex, 0.3),
            hoverColor = self.hexToRgba(hex, 0.7);

          //handle hover states
          elem.on('mouseenter', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = hoverColor;
            elem.find('span')[0].style.backgroundColor = 'transparent';
          }).on('mouseleave', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = normalColor;
            elem.find('span')[0].style.backgroundColor = '';
          });

        }
      },

      //This maybe can be later moved into a colors file along with getLuminousColorShade
      ///But convert the provided hex to an RGBA for states
      hexToRgba: function(hex, opacity) {
        var c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');

            if (c.length === 3) {
              c= [c[0], c[0], c[1], c[1], c[2], c[2]];
            }

            c = '0x' + c.join('');
            return 'rgba(' + [(c>>16)&255, (c>>8)&255, c&255].join(',') + ',' + opacity.toString() +')';
        }
        return '';
      },

      // Process Color Options to get the date color
      getLegendColor: function (year, month, date) {
        if (!this.settings.showLegend) {
          return;
        }

        var checkDate = new Date(year, month, date),
          checkHours = checkDate.setHours(0,0,0,0);

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i];

          //Check Day of week
          if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
            return series.color;
          }

          //Check for dates that match
          if (series.dates) {
            for (var j = 0; j < series.dates.length; j++) {
              var d = new Date(series.dates[j]);
              if (checkHours === d.setHours(0,0,0,0)) {
                return series.color;
              }
            }
          }

        }

        return '';
      },

      // Set focus after opening the calendar
      setFocusAfterOpen: function () {
        if (!this.calendar) {
          return;
        }
        this.activeTabindex(this.calendar.find('.is-selected'), true);
      },

      // Update the calendar to show the month (month is zero based)
      showMonth: function (month, year) {
        var self = this;

        var elementDate = this.currentDate.getDate() ?
          this.currentDate : (new Date()).setHours(0,0,0,0);

        if (this.isIslamic) {
          elementDate = this.currentDateIslamic;
        }

        if (year.toString().length < 4) {
          year = new Date().getFullYear();
        }

        if (month === 12) {
          year ++;
          this.currentMonth = month = 0;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        if (month < 0) {
          year --;
          this.currentMonth = month = 11;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        var days = Locale.calendar().days.narrow || Locale.calendar().days.narrow || Locale.calendar().days.abbreviated,
          monthName = Locale.calendar().months.wide[month];

        this.currentMonth = month;
        this.currentYear = year;

        // Set the Days of the week
        var firstDayofWeek = (Locale.calendar().firstDayofWeek || 0);
        this.dayNames.find('th').each(function (i) {
          $(this).text(days[(i + firstDayofWeek) % 7]);
        });

        //Localize Month Name
        this.yearFist = Locale.calendar().dateFormat.year && Locale.calendar().dateFormat.year.substr(1, 1) === 'y';
        this.header.find('.month').attr('data-month', month).text(monthName + ' ');
        this.header.find('.year').text(' ' + year);

        if (this.yearFist) {
          var translation = Locale.formatDate(elementDate, {date: 'year'}),
            justYear = translation.split(' ')[0];

          this.header.find('.year').text(justYear + ' ');
          this.header.find('.year').insertBefore(this.header.find('.month'));
        }

        //Adjust days of the week
        //lead days
        var firstDayOfMonth = this.firstDayOfMonth(year, month),
          leadDays = (firstDayOfMonth - (Locale.calendar().firstDayofWeek || 0) + 7) % 7,
          lastMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 1 : 0)),
          thisMonthDays = this.daysInMonth(year, month+ (this.isIslamic ? 0 : 1)),
          dayCnt = 1, nextMonthDayCnt = 1, exYear, exMonth, exDay;

        this.days.find('td').each(function (i) {
          var th = $(this).removeClass('alternate prev-month next-month is-selected is-today');
          th.removeAttr('aria-selected');

          if (i < leadDays) {
            exDay = lastMonthDays - leadDays + 1 + i;
            exMonth = (month === 0) ? 11 : month - 1;
            exYear = (month === 0) ? year - 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);
            th.addClass('alternate prev-month').html('<span aria-hidden="true">' + exDay + '</span>');
          }

          if (i >= leadDays && dayCnt <= thisMonthDays) {
            th.html('<span aria-hidden="true">' + dayCnt + '</span>');

            //Add Selected Class to Selected Date
            if (self.isIslamic) {
              if (year === elementDate[0] && month === elementDate[1] && dayCnt === elementDate[2]) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            } else {
              var tHours = elementDate.getHours(),
                tMinutes = elementDate.getMinutes(),
                tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

              if ((new Date(year, month, dayCnt)).setHours(tHours, tMinutes, tSeconds,0) === elementDate.setHours(tHours, tMinutes, tSeconds, 0)) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            }

            if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth &&
              self.currentYear === self.todayYear) {
              th.addClass('is-today');
            }

            th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), {date: 'full'}));

            self.setDisabled(th, year, month, dayCnt);
            self.setLegendColor(th, year, month, dayCnt);

            th.attr('role', 'link');
            dayCnt++;
            return;
          }

          if (dayCnt >= thisMonthDays + 1) {
            exDay = nextMonthDayCnt;
            exMonth = (month === 11) ? 0 : month + 1;
            exYear = (month === 11) ? year + 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);

            th.addClass('alternate next-month').html('<span aria-hidden="true">' + nextMonthDayCnt + '</span>');
            nextMonthDayCnt++;
          }

        });

        //Hide 6th Row if all disabled
        var row = this.days.find('tr').eq(5);
        if (row.find('td.alternate').length === 7) {
          row.hide();
        } else {
          row.show();
        }

        //Add Legend
        self.addLegend();
      },

      // Put the date in the field and select on the calendar
      insertDate: function (date, isReset) {
        var month = (date instanceof Array ? date[1] : date.getMonth()),
            year  = (date instanceof Array ? date[0] : date.getFullYear()),
            day = (date instanceof Array ? date[2] : date.getDate()).toString();

        // Make sure Calendar is showing that month
        if (this.currentMonth !== month || this.currentYear !== year) {
          this.showMonth(month, year);
        }

        if (!this.isOpen()) {
          return;
        }

        // Show the Date in the UI
        var dateTd = this.days.find('td:not(.alternate)').filter(function() {
          return $(this).text().toLowerCase() === day;
        });

        if (dateTd.hasClass('is-disabled')) {
          this.activeTabindex(dateTd, true);
        } else {
          if (this.settings.showTime) {
            if (isReset) {
              this.time = this.getTimeString(date, this.show24Hours);

              if (this.settings.roundToInterval) {
                $('#timepicker-minutes').val('');
                date = this.setTime(date);
              }
            }
            else {
              date = this.setTime(date);
            }
          }

          this.setValue(date, true);
          this.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected').removeAttr('tabindex');
          dateTd.addClass('is-selected').attr({'aria-selected': true});
          this.activeTabindex(dateTd, true);
        }
      },

      // Convert a string to boolean
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      // Find the day of the week of the first of a given month
      firstDayOfMonth: function (year, month) {

        if (this.isIslamic) {
		      var firstDay = this.conversions.toGregorian(year, month, 1);
			    return (firstDay === null ? 1 : firstDay.getDay());
        }
        return  (new Date(year, month, 1)).getDay();
      },

      islamicYearIndex: function (islamicYear) {
        var yearIdx = islamicYear - 1318;
        if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
          return 0; // for an out-of-range year, simply returns 0
        } else {
          return yearIdx;
        }
      },

      // Find the date of the Month (29, 30, 31 ect)
      daysInMonth: function (year, month) {

        if (this.isIslamic) {
		      var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
    			var monthDayCount = 0;
    			for (var M = 0; M <= month; M++) {
    				monthDayCount = 29 + (monthLengthBitmap & 1);
    				if (M === month) {
    					return monthDayCount;
    				}
    				monthLengthBitmap = monthLengthBitmap >> 1;
    			}
    			return 0;
        }
        return  (new Date(year, month, 0)).getDate();
      },

      /**
      * Set the Formatted value in the input
      * @param {Date} date  &nbsp;-&nbsp; The date to set in date format.
      * @param {Boolean} trigger  &nbsp;-&nbsp; If true will trigger the change event.
      */
      setValue: function(date, trigger) {
        //TODO Document this as the way to get the date
        this.currentDate = date;

        if (date instanceof Array) {
          this.currentIslamicDate = date;
          this.currentDate = this.conversions.toGregorian(date[0], date[1], date[2]);
          date = new Date(date[0], date[1], date[2]);
        }

        this.element.val(Locale.formatDate(date, {pattern: this.pattern}));

        if (trigger) {
          this.element.trigger('change').trigger('input');
        }

      },

      //Get the value from the field and set the internal variables or use current date
      setValueFromField: function() {
        var fieldValue = this.element.val(),
          gregorianValue = fieldValue;

        if (this.isIslamic && fieldValue) {
          var islamicValue = Locale.parseDate(this.element.val(), this.pattern);
          gregorianValue = this.conversions.toGregorian(islamicValue.getFullYear(), islamicValue.getMonth(),  islamicValue.getDate());
        }

        this.currentDate = gregorianValue || new Date();
        if (typeof this.currentDate === 'string') {
          this.currentDate = Locale.parseDate(this.currentDate, this.pattern, false);
        }

        if (this.currentDate === undefined) {
          this.currentDate = Locale.parseDate(gregorianValue, this.pattern, false);
        }

        this.currentDate = this.currentDate || new Date();
        this.currentMonth = this.currentDate.getMonth();
        this.currentYear = this.currentDate.getFullYear();
        this.currentDay = this.currentDate.getDate();

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
          this.currentYear = this.currentDateIslamic[0];
          this.currentMonth = this.currentDateIslamic[1];
          this.currentDay = this.currentDateIslamic[2];
        }
      },

      /**
      * Set input to enabled.
      */
      enable: function() {
        this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
      },

      /**
      * Set input to disabled.
      */
      disable: function() {
        this.enable();
        this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
      },

      /**
      * Set input to readonly.
      */
      readonly: function() {
        this.enable();
        this.element.attr('readonly', 'readonly');
      },

      /**
      * Set to todays date in current format.
      */
      setToday: function() {
        this.currentDate = new Date();

        if (this.element.val() === '') {
          this.currentDate.setHours(0);
          this.currentDate.setMinutes(0);
          this.currentDate.setSeconds(0);
        } else {
          if (this.timepicker && this.timepicker.hourSelect) {
            this.currentDate.setHours(this.timepicker.hourSelect.val());
          }

          if (this.timepicker && this.timepicker.minuteSelect) {
            this.currentDate.setMinutes(this.timepicker.minuteSelect.val());
          }

          if (this.timepicker && this.timepicker.secondSelect) {
            this.currentDate.setSeconds(this.timepicker.secondSelect.val());
          }
        }

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
        }

        if (this.isOpen()) {
          this.insertDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, true);
        } else {
          this.element.val(Locale.formatDate(this.currentDate, {pattern: this.pattern})).trigger('change').trigger('input');
        }

      },

      // Set time
      setTime: function(date) {
        var hours = $('#timepicker-hours').val(),
          minutes = $('#timepicker-minutes').val(),
          seconds = this.isSeconds ? $('#timepicker-seconds').val() : 0,
          period = $('#timepicker-period');


        hours = (period.length && period.val() === 'PM' && hours < 12) ? (parseInt(hours, 10) + 12) : hours;
        hours = (period.length && period.val() === 'AM' && parseInt(hours, 10) === 12) ? 0 : hours;

        date.setHours(hours, minutes, seconds);
        return date;
      },

      // Get Time String
      getTimeString: function (date, isHours24) {
        var twodigit = function (number) {
            return (number < 10 ? '0' : '') + number;
          },
          d = (date || new Date()),
          h = d.getHours(),
          m = twodigit(d.getMinutes()),
          s = twodigit(d.getSeconds()),
          h12 = (h % 12 || 12) +':'+ m + (this.isSeconds ? ':'+ s : '') +' ' + (h < 12 ? 'AM' : 'PM'),
          h24 = h + ':' + m + (this.isSeconds ? ':'+ s : '');

        return isHours24 ? h24 : h12;
      },

      // Change the order for execution jquery events were bound
      // http://stackoverflow.com/questions/2360655/jquery-event-handlers-always-execute-in-order-they-were-bound-any-way-around-t
      changeEventOrder: function (elements, names, newIndex) {
        // Allow for multiple events.
        $.each(names.split(' '), function (idx, name) {
          elements.each(function () {
            var handlers = $._data(this, 'events')[name.split('.')[0]];
            // Validate requested position.
            newIndex = Math.min(newIndex, handlers.length - 1);
            handlers.splice(newIndex, 0, handlers.pop());
          });
        });
      },

      // Set focus on (opt: next|prev) focusable element
      setFocusOnFocusableElement: function(element, opt) {
        var canfocus = $(':focusable'),
          index = canfocus.index(element);

        index = (opt === 'next') ?
          ((index+1) >= canfocus.length ? 0 : (index+1)) :
          ((index-1) < 0 ? canfocus.length : (index-1));

        canfocus.eq(index).focus();
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        if (this.isOpen()) {
          this.closeCalendar();
        }

        this.trigger.remove();
        this.element.attr('data-mask', '');

        if (this.calendar && this.calendar.length) {
          this.calendar.remove();
        }

        if (this.popup && this.popup.length) {
          this.popup.remove();
        }

        var api = this.element.data('mask');
        if (api) {
          api.destroy();
        }

        this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

        return this;
      },

      /**
      * Remove all events and reset back to default.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Datepicker#events
       * @param {Object} listopened  &nbsp;-&nbsp; Fires as the calendar popup is opened
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires as the calendar popup is closed
       * @param {Object} change  &nbsp;-&nbsp; Fires after the value in the input is changed by any means.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       *
       */
      handleEvents: function () {
        var self = this;

        this.trigger.on('click.datepicker', function () {
          if (self.isOpen()) {
            self.closeCalendar();
          } else {
            self.openCalendar();
          }
        });

        self.mask();
        this.handleKeys(this.element);
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new DatePicker(this, settings));
      }
    });
  };


window.Formatters = {

  Text: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Input: function(row, cell, value, col) {
    if (col.inlineEditor) {
      var html = '<label for="datagrid-inline-input-' + row + '-' + cell +'" class="audible">'+ col.name +'</label>'+
          '<input id="datagrid-inline-input-' + row + '-' + cell +'" class="'+ (col.align === 'right' ? 'is-number-mask': '') + '" value="'+ value +'">';

      return html;
    }

    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Ellipsis: function(row, cell, value, col) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    col.textOverflow = 'ellipsis';
    return str;
  },

  Password: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str.replace(/./g, '*');
  },

  Readonly: function(row, cell, value) {
    return '<span class="is-readonly">' + ((value === null || value === undefined) ? '' : value) + '</span>';
  },

  Date: function(row, cell, value, col, isReturnValue) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      value2;

    if (typeof value === 'string' && value) {

      if (value === '0000' || value === '000000' || value === '00000000') { //Means no date in some applications
        return '';
      }

      if (!col.sourceFormat) {
        value2 = Locale.parseDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        value2 = Locale.parseDate(value, (typeof col.sourceFormat === 'string' ? {pattern: col.sourceFormat}: col.sourceFormat));
      }

      if (value2) {
        formatted = Locale.formatDate(value2, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));

        if (formatted === 'NaN/NaN/NaN') { //show invalid dates not NA/NA/NA
          formatted = value;
        }

      }
    } else if (value) {
      formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
    }

    if (!col.editor || isReturnValue === true) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'calendar', classes: ['icon-calendar'] });
  },

  Time: function(row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat.short : null),
      localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null),
      value2;

    var parseTime = function (timeString) {
      if (timeString === '') {
        return null;
      }
      var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);
      if (time === null) {
        return null;
      }
      var d = new Date();
      d.setHours(parseInt(time[1]) + (time[4] ? 12 : 0));
      d.setMinutes(parseInt(time[2]) || 0);
      d.setSeconds(parseInt(time[3]) || 0);
      return d;
    };

    if (typeof value === 'string' && value) {
      value2 = Locale.formatDate(parseTime(value), { pattern: (localeDateFormat +' '+ (col.sourceFormat || col.timeFormat || localeTimeFormat)) });

      if (value2) {
        formatted = value2.slice(value2.indexOf(' '));
      }
    }

    // Remove extra space in begining
    formatted = formatted.replace(/^\s/, '');

    if (!col.editor) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'clock', classes: ['icon-clock'] });

  },

  Autocomplete: function(row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return formatted;
  },

  Lookup: function(row, cell, value, col, item) {
    var formatted = ((value === null || value === undefined) ? '' : value);

    if (!col.editor) {
      return formatted;
    }

    if (col.editorOptions && typeof col.editorOptions.field === 'function') {
      formatted = col.editorOptions.field(item, null, null);
    }

    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'search-list', classes: ['icon-search-list'] });
  },

  Decimal:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
       formatted = Locale.formatNumber(+value, col.numberFormat);
    }
    return ((formatted === null || formatted === undefined) ? '' : formatted);
  },

  Integer:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
      formatted = Locale.formatNumber(+value, col.numberFormat || {style: 'integer'});
    }
    return (formatted === null || formatted === undefined) ? '' : formatted;
  },

  Hyperlink: function(row, cell, value, col, item, api) {
    var textValue,
      colHref = col.href || '#';

    //Support for dynamic links based on content
    if (col.href && typeof col.href === 'function') {
      colHref = col.href(row, cell, item, col);
      //Passing a null href will produce "just text" with no link
      if (colHref == null) {
        return col.text || value;
      }
    } else  {
      colHref = colHref.replace('{{value}}', value);
    }

    textValue = col.text || value;
    if (!textValue && !col.icon) {
      return '';
    }

    return col.icon ?
      ('<a href="'+ colHref +'" class="btn-icon row-btn '+ (col.cssClass || '') +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+
          $.createIcon({ icon: col.icon, file: col.iconFile }) +
          '<span class="audible">'+ textValue +'</span>'+
        '</a>') :
      ('<a href="'+ colHref +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + ' role="presentation" class="hyperlink '+ (col.cssClass || '') + '"' + (col.target ? ' target="' + col.target + '"' : '') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+ textValue +'</a>');
  },

  Template: function(row, cell, value, col, item) {
    var tmpl = col.template,
      renderedTmpl = '';

    if (Tmpl && item && tmpl) {
      var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
      renderedTmpl = compiledTmpl.render({dataset: item});
    }

    return renderedTmpl;
  },

  Drilldown: function () {
    var text = Locale.translate('Drilldown');

    if (text === undefined) {
      text = '';
    }

    return (
      '<button type="button" tabindex="-1" class="btn-icon small datagrid-drilldown">' +
         $.createIcon({icon: 'drilldown'}) +
        '<span>' + text + '</span>' +
      '</button>'
    );
  },

  RowReorder: function () {
    var text = Locale.translate('ReorderRows');

    if (text === undefined) {
      text = 'Reorder Rows';
    }

    return (
      '<div class="datagrid-reorder-icon">' +
         $.createIcon({icon: 'drag'}) +
        '<span class="audible">' + text + '</span>' +
      '</div>'
    );
  },

  Checkbox: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      //treat 1, true or '1' as checked
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    // We add hidden Yes/No text so that the exported excel spreadsheet shows this text in checkbox columns
    var hiddenText = '<span class="hidden" aria-hidden="true" role="presentation">' + Locale.translate(isChecked ? 'Yes' : 'No') + '</span>';

    var animate = api.wasJustUpdated;
    api.wasJustUpdated = false;
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ col.name +'" class="datagrid-checkbox ' +
     (isChecked ? 'is-checked ' + (!animate ? ' no-animation' : ' ') : '') +'" aria-checked="'+isChecked+'"></span>' + hiddenText + '</div>';
  },

  SelectionCheckbox: function (row, cell, value, col) {
    var isChecked = (value==undefined ? false : value == true); // jshint ignore:line
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ col.name +'" class="datagrid-checkbox datagrid-selection-checkbox' +
     (isChecked ? 'is-checked' : '') +'" aria-checked="'+isChecked+'"></span></div>';
  },

  Actions: function (row, cell, value, col) {
    //Render an Action Formatter
    return (
      '<button type="button" class="btn-actions" aria-haspopup="true" aria-expanded="false" aria-owns="'+ col.menuId +'">' +
        '<span class="audible">'+ col.title +'</span>' +
        $.createIcon({ icon: 'more' }) +
      '</button>'
    );
  },

  // Multi Line TextArea
  Textarea: function (row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return '<span class="datagrid-multiline-text">'+ formatted + '</span>';
  },

  // Rich Text Editor
  Editor: function (row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      classes = 'is-editor';
    classes += col.singleline ? '' : ' datagrid-multiline-text';
    classes += col.contentTooltip ? ' content-tooltip' : '';
    return '<div class="'+ classes +'">'+ $.unescapeHTML(formatted) +'</div>';
  },

  // Expand / Collapse Button
  Expander: function (row, cell, value) {
    var button = '<button type="button" aria-label="' + Locale.translate('ExpandCollapse') + '" class="btn-icon datagrid-expand-btn" tabindex="-1">'+
      '<span class="icon plus-minus"></span>' +
      '</button>' + ( value ? '<span> ' + value + '</span>' : '');

    return button;
  },

  // Datagrid Group Row
  GroupRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      groups = '',
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    for (var i = 0; i < groupSettings.fields.length ; i++) {
      groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
    }

    if (groupSettings.groupRowFormatter) {
      groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
    }

    var button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"' +'>'+
    '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
    '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
    '</button>'+ '<span> '+ groups +'</span>';

    return button;
  },

  GroupFooterRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    var idx = api.columnIdxById(groupSettings.aggregate),
        html = '<td role="gridcell" colspan=' + (idx) + '><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper"> '+ item.sum +'</div></td>';

    if (groupSettings.groupFooterRowFormatter) {
      html = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
    }

    return html;
  },

  SummaryRow: function (row, cell, value, col) {
    var afterText = '',
        beforeText = col.summaryText ||  '<b class="datagrid-summary-totals">' + Locale.translate('Total') + ' </b>';

    if (col.summaryTextPlacement === 'after') {
      afterText = beforeText;
      beforeText = '';
    }

    if (typeof Locale !== undefined && col.numberFormat &&
      value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
    }

    return (beforeText + ((value === null || value === undefined || value === '') ? '' : value.toString()) + afterText);
  },

  // Tree Expand / Collapse Button and Paddings
  Tree: function (row, cell, value, col, item, api) {
    var isOpen = item.expanded,
      depth = api.settings.treeDepth[row].depth,
      button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth -1)) +'px' : '') +'"' : '') +'>'+
      '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
      '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
      '</button>'+ ( value ? '<span> '+ value +'</span>' : ''),
      node = '<span class="datagrid-tree-node"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth-1)) +'px' : '') +'"' : '') +'> '+ value +'</span>';

    return (item[col.children ? col.children : 'children'] ? button : node);
  },

  // Badge / Tags and Visual Indictors
  ClassRange: function (row, cell, value, col) {
    var ranges = col.ranges,
      classes = '', text='';

    if (!ranges) {
      return {};
    }

    for (var i = 0; i < ranges.length; i++) {
      if (value >= ranges[i].min && value <= ranges[i].max) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : classes.split(' ')[0]);
      }

      if (value === ranges[i].value) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : value);
      }
    }

    return {'classes': classes, 'text': text};
  },

  // Badge (Visual Indictors)
  Badge: function (row, cell, value, col) {
    var colorClasses = col.color,
      text = col.name;

    if (col.ranges) {
      var ranges = Formatters.ClassRange(row, cell, value, col);
      colorClasses = ranges.classes;
      text = ranges.text;
    }
    return '<span class="badge ' + colorClasses +'">' + value +' <span class="audible">'+ text+ '</span></span>';
  },

  Tag: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    return '<span class="tag ' + ranges.classes +'">'+ value + '</span>';
  },

  Alert: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    var icon = $.createIcon({
      icon: ranges.classes, classes: [
        'icon',
        'datagrid-alert-icon',
        'icon-' + ranges.classes
      ]
    });
    return icon + '<span class="datagrid-alert-text">' + (ranges.text === 'value' ? value : ranges.text) + '</span>';
  },

  Image: function (row, cell, value, col) {

    return '<img class="datagrid-img"' + ' src="' + value +'" alt= "' + (col.alt ? col.alt : Locale.translate('Image')) +
     '"' + (col.dimensions ? ' style="height:'+col.dimensions.height+';width:'+col.dimensions.height+'"' : '') + '/>';
  },

  Color: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col),
      text = ((value === null || value === undefined || value === '') ? '' : value.toString());

    return '<span class="' + ranges.classes + '">' + text + '</span>';
  },

  Button: function (row, cell, value, col, item, api) {
    var text = col.text ? col.text : ((value === null || value === undefined || value === '') ? '' : value.toString()),
      markup ='<button type="button" class="'+ ( col.icon ? 'btn-icon': 'btn-secondary') + ' row-btn ' + (col.cssClass ? col.cssClass : '') + '"' + (!api.settings.rowNavigation ? '' : ' tabindex="-1"') +' >';

      if (col.icon) {
        markup += $.createIcon({ icon: col.icon, file: col.iconFile });
      }
      markup += '<span>' + text + '</span></button>';

    return markup;
  },

  Dropdown: function (row, cell, value, col) {
    var formattedValue = value, compareValue, i, option, optionValue;

    if (col.options && value !== undefined) {
      compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

      for (i = 0; i < col.options.length; i++) {
        option = col.options[i];
        optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

        if (optionValue === compareValue) {
          formattedValue = option.label;
          break;
        }
      }
    }

    var html = '<span class="trigger dropdown-trigger">' + formattedValue + '</span>' + $.createIcon({ icon: 'dropdown' });

    if (col.inlineEditor) {
      html = '<label for="full-dropdown" class="audible">'+ col.name +'</label>'+
        '<select id="'+ 'datagrid-dropdown' + row +'" class="dropdown">';

      for (i = 0; i < col.options.length; i++) {
        var opt = col.options[i];
        html += '<option' + (opt.id === undefined ? '' : ' id="' + opt.id + '"') +
                  ' value="' + opt.value + '"' +
                  (opt.selected || opt.value === compareValue ? ' selected ' : '') +
                '>'+ (opt.label !== undefined ? opt.label : opt.value !== undefined ? opt.value : '') + '</option>';
      }

      html += '</select>'+
      '<div class="dropdown-wrapper is-inline">'+
        '<div class="dropdown"><span>'+ formattedValue +'</span></div>'+
        '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">'+
          '<use xlink:href="#icon-dropdown"></use>'+
        '</svg>'+
      '</div>';
    }

    return html;
  },

  Spinbox: function (row, cell, value, col) {
    var html = ((value === null || value === undefined || value === '') ? '' : value.toString());

    if (col.inlineEditor) {
      html = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';
    }

    return html;
  },

  Favorite: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    var isEditable = col.editor && api.settings.editable;

    if (isChecked) {
      return '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-filled' }) + '</span>';
    } else {
      return col.showEmpty ? '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-outlined' }) + '</span>' : '';
    }
  },

  Status: function (row, cell, value, col, item) {

    if (!item.rowStatus) {
      return '<span></span>';
    }

    return $.createIcon({ icon: item.rowStatus.icon, classes: ['icon', 'icon-' + item.rowStatus.icon, 'datagrid-alert-icon'] }) + '<span class="audible">' + item.rowStatus.text + '</span>';
  },

  TargetedAchievement: function (row, cell, value, col) {
    var perc = (100*value),
      ranges = Formatters.ClassRange(row, cell, perc, col),
      target = col.target;

    var isWhite = perc > 55;  //Maybe implement this later perc > 60;
    return '<div class="total bar chart-completion-target chart-targeted-achievement"><div class="target remaining bar" style="width: '+ (target || 0) +'%;"></div><div class="completed bar ' + (col.ranges && ranges.classes ? ranges.classes : 'primary') + '" style="width: '+ perc +'%;"></div>' + (col.showPercentText ? '<div class="chart-targeted-text" '+ (isWhite ? 'style="color: white"' : '') +'>'+ perc +'%</div></div>' : '');
  },
  // TODO Possible future Formatters
    // Image?
  // Multi Select
  // Sparkline
  // Progress Indicator (n of 100%)
  // Process Indicator
  // Currency
  // File Upload (Simple)
  // Menu Button
  // Color Picker (Low)
};

window.Editors = {

  //Supports, Text, Numeric, Integer via mask
  Input: function(row, cell, value, container, column, e, api, item) {

    this.name = 'input';
    this.originalValue = value;
    this.useValue = column.inlineEditor ? true : false;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
      } else {
        this.input = $('<input type="'+ (column.inputType || 'text') +'"/>')
          .appendTo(container);
      }

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.mask && typeof column.mask === 'function') {
        var mask = column.mask(row, cell, value, column, item);
        this.input.mask({pattern: mask, mode: column.maskMode});
      } else if (column.mask) {
        this.input.mask({pattern: column.mask, mode: column.maskMode});
      }
    };

    this.val = function (value) {
      var thisValue;
      if (value) {
        this.input.val(value);
      }
      if (column && column.numberFormat && column.numberFormat.style === 'percent') {
        thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
        return Locale.parseNumber(thisValue) / 100;
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus().select();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Textarea: function(row, cell, value, container, column) {

    this.name = 'textarea';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<textarea class="textarea"></textarea>').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

    };

    this.val = function (value) {
      if (value) {
        //note that focus will help move text to end of input.
        this.input.focus().val(value);
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  // Rich Text Editor
  Editor: function(row, cell, value, container, column, e, api) {
    this.name = 'editor';
    this.originalValue = value;

    this.init = function () {
      var self = this,
        // Editor options
        editorOptions = $.extend({}, {
          buttons: { editor: ['bold','italic','underline','strikethrough','separator', 'foreColor'], source: [] },
          excludeButtons: { editor: [] }
        }, column.editorOptions);

      // Editor width
      this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
      delete editorOptions.width;

      container.append(
        '<div class="editor-wrapper" style="width:'+ this.editorWidth +';">'+
          '<div class="editor" data-init="false">'+ $.unescapeHTML(value) +'</div>'+
        '</div>');
      this.td = container.closest('td');
      this.input = $('.editor', container);

      this.input
        .popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: '-'+ (parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink'],
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup'
        })
        .editor(editorOptions)
        .on('hide.editor', function () {
          api.commitCellEdit(self.input);
        })
        .on('keydown.editor', function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          // Ctrl + Enter (Some browser return keyCode: 10, not 13)
          if ((e.ctrlKey || e.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');
            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(e);
            }
          }
        });
      Soho.utils.fixSVGIcons($('#editor-popup'));
    };

    this.val = function () {
      return this.input.html();
    };

    this.focus = function () {
      var self = this;
      setTimeout(function() {
        self.input.focus();
      }, 0);
    };

    this.destroy = function () {
      var self = this;
      container.removeAttr('style');
      api.quickEditMode = false;
      self.input.off('hide.editor keydown.editor');
      setTimeout(function() {
        self.input.remove();
        // Reset tooltip
        var elem = self.td.find('.is-editor.content-tooltip');
        api.setupContentTooltip(elem, self.editorWidth);
      }, 0);
    };

    this.init();
  },

  Checkbox: function(row, cell, value, container, column, event, grid) {

    this.name = 'checkbox';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {

      this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
      this.input.after('<label class="checkbox-label"></label>');

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it if we click right on it
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
    };

    this.focus = function () {
      this.input.trigger('focusout');
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.next('.checkbox-label').remove();
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Dropdown: function(row, cell, value, container, column, event, grid, rowData) {

    this.name = 'dropdown';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value
    this.cell = grid.activeCell;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('select');
        return;
      }

      this.input = $('<select class="dropdown"></select>').appendTo(container);

      if (column.options) {
        var html, opt, optionValue;
        value = grid.fieldValue(rowData,column.field);

        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0; i < column.options.length; i++) {
          html = $('<option></<option>');
          opt = column.options[i];
          optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

          if (opt.selected || compareValue === optionValue) {
            html.attr('selected', 'true');
            this.originalValue = optionValue;
          }

          html.attr('value', opt.value).attr('id', opt.id).attr('data-type', typeof opt.value);
          html.text(opt.label);
          this.input.append(html);
        }
      }

      var editorOptions = column.editorOptions || {};

      function hasEditingClass() {
        return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
      }
      // Add the class to both the options being passed, as well as the column's original options
      if (!hasEditingClass()) {
        editorOptions.cssClass = editorOptions.cssClass || '';
        editorOptions.cssClass += ' is-editing';
      }

      // Append the Dropdown's sourceArguments with some row/col meta-data
      editorOptions.sourceArguments = $.extend({}, editorOptions.sourceArguments, {
        column: column,
        container: container,
        grid: grid,
        cell: cell,
        event: event,
        row: row,
        rowData: rowData,
        value: value
      });

      this.input.dropdown(editorOptions);
    };

    this.val = function (value) {

      if (value !== undefined) {
        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;
        this.input.val(value);

        this.input.find('option').each(function () {
          var opt = $(this), valueAttr = opt.attr('value'), type = opt.attr('data-type');
          var optionValue = valueAttr;

          // Get option value in proper type before checking equality
          if (type === 'number') {
            optionValue = parseFloat(valueAttr);
          } else if (type === 'boolean') {
            optionValue = valueAttr === 'true';
          } else if (type === 'string' && column.caseInsensitive) {
            optionValue = valueAttr.toLowerCase();
          }

          if (optionValue === compareValue) {
            opt.attr('selected', 'true');
          }
        });
      }

      var selected = this.input.find(':selected'),
        val = selected.attr('value'), dataType = selected.attr('data-type');

      // For non-string option values (number, boolean, etc.), convert string attr value to proper type
      if (dataType === 'number') {
        val = parseFloat(val);
      } else if (dataType === 'boolean') {
        val = val === 'true';
      }

      if (val === undefined) {
        val = selected.text();
      }

      return val;
    };

    this.focus = function () {
      var self = this;

      //Check if isClick or cell touch and just open the list
      this.input.trigger('openlist');
      this.input.parent().find('div.dropdown').focus();

      this.input.off('listclosed').on('listclosed', function (e, type) {
        grid.commitCellEdit(self.input);

        if (type === 'select') {
          container.parent('td').focus();
          return;
        }

        if (type === 'tab') {
          setTimeout(function () {
            container.parent('td').focus();
          }, 100);
        }
      });

    };

    this.destroy = function () {
      //We dont need to destroy since it will when the list is closed
    };

    this.init();
  },

  Date: function(row, cell, value, container, column, event, grid) {

    this.name = 'date';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="datepicker"/>').appendTo(container);
      this.input.datepicker(column.editorOptions || { dateFormat: column.dateFormat });
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }
      return window.Formatters.Date(row, cell, this.input.val(), column, true);
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.input.on('listclosed', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Time: function(row, cell, value, container, column, event, grid) {
    this.name = 'time';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="timepicker"/>').appendTo(container);
      this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }

      return this.input.val();
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.api.trigger.on('hide.editortime', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      if (self.api && self.api.trigger) {
        self.api.trigger.off('hide.editortime');
      }

      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Lookup: function(row, cell, value, container, column, event, grid) {
    this.name = 'lookup';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="lookup" data-init="false" />').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      this.input.lookup(column.editorOptions);
    };

    this.val = function (value) {
      var fieldValue = this.input.val();
      if (fieldValue && fieldValue.indexOf('|') > -1) {
        fieldValue = fieldValue.substr(0, fieldValue.indexOf('|'));
      }
      return value ? this.input.val(value) : fieldValue;
    };

    this.focus = function () {
      var self = this,
        api = self.input.data('lookup'),
        td = self.input.closest('td');

      // Using keyboard
      if (event.type === 'keydown') {
        self.input.select().focus();
        td.on('keydown.editorlookup', function (e) {
          if (e.keyCode === 40 && grid.quickEditMode) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click') {
        if ($(event.target).is('svg')) {
          api.openDialog(event);
        } else {
          self.input.select().focus();
          td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function() {
            api.openDialog();
          });
        }
      }

      // Update on change from lookup
      self.input.on('change', function () {
        setTimeout(function () {
          container.parent().focus();
          grid.setNextActiveCell(event);
          grid.quickEditMode = false;
        }, 1);
      });

    };

    this.destroy = function () {
      var self = this,
        td = this.input.closest('td');
      setTimeout(function() {
        grid.quickEditMode = false;
        td.off('keydown.editorlookup')
          .find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Autocomplete: function(ow, cell, value, container, column, event, grid) {
    this.name = 'autocomplete';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="autocomplete datagrid-autocomplete" data-autocomplete="source" />').appendTo(container);

      if (!column.editorOptions) {
        column.editorOptions = {};
      }
      column.editorOptions.width = container.parent().width();
      column.editorOptions.offset = {left: -1, top: (grid.settings.rowHeight ==='medium' ? 1 : 5)};

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      this.input.autocomplete(column.editorOptions);
    };

    this.val = function (value) {
      return value ? this.input.val(value) : this.input.val();
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Spinbox: function(ow, cell, value, container, column, event, grid) {
    this.name = 'spinbox';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
        return;
      }

      var markup = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';

      container.append(markup);
      this.input = container.find('input');

      if (!column.editorOptions) {
        column.editorOptions = {};
      }

      this.input.spinbox(column.editorOptions);
    };

    this.val = function (value) {
      return value ? parseInt(this.input.val(value)) : parseInt(this.input.val());
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Favorite: function(row, cell, value, container, column, event, grid) {
    this.name = 'favorite';
    this.useValue = true;
    this.originalValue = value;

    this.init = function () {
      this.input = $('<span class="icon-favorite">' +
            $.createIcon({ icon: value ? 'star-filled' : 'star-outlined' }) + '<input type="checkbox"></span>').appendTo(container);

      this.input = this.input.find('input');
    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it when clicked
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && (!$(event.target).is('.datagrid-cell-wrapper'))) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
      this.input.find('use').attr('xlink:href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
    };

    this.focus = function () {
      this.input.trigger('focusout').focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.parent().remove();
      }, 0);
    };

    this.init();
  }
};

window.GroupBy = (function() {

  //Can also use in isEquals: function(obj1, obj2)  in datagrid.js
  var equals = window.Soho.utils.equals;

  //See if the object has these proprties or not
  var has = function(obj, target) {
    return obj.some(function(value) {
        return equals(value, target);
    });
  };

  //Return just the object properties matching the names
  var pick = function(obj, names) {
    var chosen = {};
    for (var i = 0; i < names.length; i++) {
      chosen[names[i]] = obj[names[i]];
    }
    return chosen;
  };

  //Return the specific keys from the object
  var keys = function(data, names) {
    return data.reduce(function(memo, item) {
      var key = pick(item, names);

      if (!has(memo, key)) {
        memo.push(key);
      }
      return memo;
    }, []);
  };

  //Look through each value in the list and return an array of all the values
  //that contain all of the key-value pairs listed in properties.
  var where = function (data, names) {
    var chosen = [];

    data.map(function(item) {
      var match = true;
      for (var prop in names) {
        if (names[prop] !== item[prop]) {
          match = false;
          return;
        }
      }
      chosen.push(item);
      return;
    });

    return chosen;
  };

  //Grouping Function with Plugins/Aggregator
  var group = function(data, names) {
    var stems = keys(data, names);

    return stems.map(function(stem) {
      return {
        key: stem,
        values: where(data, stem).map(function(item) {
          return item;
        })
      };
    });
  };

  //Register an aggregator
  group.register = function(name, converter) {
    return group[name] = function(data, names, extra) { // jshint ignore:line
      var that = this;
      that.extra = extra;
      return group(data, names).map(converter, that);
    };
  };

  return group;
}());

//Register built in aggregators
GroupBy.register('sum', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {sum: item.values.reduce(function(memo, node) {
      return memo + Number(node[extra]);
  }, 0)});
});

GroupBy.register('max', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {max: item.values.reduce(function(memo, node) {
      return Math.max(memo, Number(node[extra]));
  }, Number.NEGATIVE_INFINITY)});
});

GroupBy.register('list', function(item) {
  var extra = this.extra;

  return $.extend({}, item.key, {values: item.values}, {list: item.values.map(function(item) {
    var list = [];

    for (var i = 0; i < extra.list.length; i++) {
      var exclude = extra.exclude ? item[extra.exclude] : false;
      if (item[extra.list[i]] && !exclude) {
        list.push({value: item[extra.list[i]], key: extra.list[i]});
      }
    }
    return list;
  })});
});

//Simple Summary Row Accumlator
window.Aggregators = {};
window.Aggregators.aggregate = function (items, columns) {
    var totals = {}, self = this;

    for (var i = 0; i < columns.length; i++) {
        if (columns[i].aggregator) {
            var field = columns[i].field;

            self.sum = function (sum, node) {
                var value;
                if (field.indexOf('.') > -1) {
                    value = field.split('.').reduce(function (o, x) {
                        return (o ? o[x] : '');
                    }, node);
                }
                else {
                    value = node[field];
                }
                return sum + Number(value);
            };

            var total = items.reduce(self[columns[i].aggregator], 0);

            if (field.indexOf('.') > -1) {
                var currentObj = totals;
                for (var j = 0; j < field.split('.').length; j++) {
                    if (j === field.split('.').length - 1) {
                        currentObj[field.split('.')[j]] = total;
                    }
                    else {
                        if (!(field.split('.')[j] in currentObj)) {
                            currentObj[field.split('.')[j]] = {};
                        }

                        currentObj = currentObj[field.split('.')[j]];
                    }
                }
            }
            else {
                totals[field] = total;
            }
        }
    }

    return totals;
};

$.fn.datagrid = function(options) {

  // Settings and Options
  var pluginName = 'datagrid',
      defaults = {
        // F2 - toggles actionableMode "true" and "false"
        // If actionableMode is "true”, tab and shift tab behave like left and right arrow key,
        // if the cell is editable it goes in and out of edit mode
        actionableMode: false,
        cellNavigation: true, // If cellNavigation is "false”, will show border around whole row on focus
        rowNavigation: true, // If rowNavigation is "false”, will NOT show border around the row
        alternateRowShading: false, //Sets shading for readonly grids
        columns: [],
        dataset: [],
        columnReorder: false, // Allow Column reorder
        saveColumns: false, //Save Column Reorder and resize
        saveUserSettings: {}, //Save one or all of the following to local storage : columns: true, rowHeight: true, sortOrder: true, pagesize: true, activePage: true, filter: true
        editable: false,
        isList: false, // Makes a readonly "list"
        menuId: null,  //Id to the right click context menu
        uniqueId: null, //Unique ID for local storage reference and variable names
        rowHeight: 'normal', //(short, medium or normal)
        selectable: false, //false, 'single' or 'multiple'
        groupable: null, //Use Data grouping fx. {fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}
        clickToSelect: true,
        toolbar: false, // or features fx.. {title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}
        initializeToolbar: true, // can set to false if you will initialize the toolbar yourself
        //Paging Options
        paging: false,
        pagesize: 25,
        pagesizes: [10, 25, 50, 75],
        showPageSizeSelector: true, // Will show page size selector
        indeterminate: false, //removed ability to go to a specific page.
        source: null, //callback for paging
        hidePagerOnOnePage: false, //If true, hides the pager if there's only one page worth of results.
        //Filtering Options
        filterable: false,
        disableClientFilter: false, //Disable Filter Logic client side and let your server do it
        disableClientSort: false, //Disable Sort Logic client side and let your server do it
        resultsText: null,  // Can provide a custom function to adjust results text
        virtualized: false, // Prevent Unused rows from being added to the DOM
        virtualRowBuffer: 10, //how many extra rows top and bottom to allow as a buffer
        rowReorder: false, //Allows you to reorder rows. Requires rowReorder formatter
        showDirty: false,
        allowOneExpandedRow: true, //Only allows one expandable row at a time
        enableTooltips: false,  //Process tooltip logic at a cost of performance
        disableRowDeactivation: false, // If a row is activated the user should not be able to deactivate it by clicking on the activated row
        sizeColumnsEqually: false, //If true make all the columns equal width
        expandableRow: false, // Supply an empty expandable row template
        redrawOnResize: true //Run column redraw logic on resize
      },
      settings = $.extend({}, defaults, options);

  /**
  * The Datagrid Component displays and process data in tabular format.
  *
  * @class Datagrid
  * @param {Boolean} actionableMode &nbsp;-&nbsp If actionableMode is "true”, tab and shift tab behave like left and right arrow key, if the cell is editable it goes in and out of edit mode. F2 - toggles actionableMode "true" and "false"
  * @param {Boolean} cellNavigation &nbsp;-&nbsp If cellNavigation is "false”, will show border around whole row on focus
  * @param {Boolean} rowNavigation  &nbsp;-&nbsp If rowNavigation is "false”, will NOT show border around the row
  * @param {Boolean} alternateRowShading  &nbsp;-&nbsp Sets shading for readonly grids
  * @param {Array} columns  &nbsp;-&nbsp an array of columns (see column options)
  * @param {Array} dataset  &nbsp;-&nbsp an array of data objects
  * @param {Boolean} columnReorder  &nbsp;-&nbsp Allow Column reorder
  * @param {Boolean} saveColumns  &nbsp;-&nbsp Save Column Reorder and resize
  * @param {Object} saveUserSettings  &nbsp;-&nbsp Save one or all of the following to local storage : columns: true, rowHeight: true, sortOrder: true, pagesize: true, activePage: true, filter: true
  * @param {Boolean} editable &nbsp;-&nbsp Enable editing in the grid, requires column editors.
  * @param {Boolean} isList  &nbsp;-&nbsp Makes the grid have readonly "list" styling
  * @param {String} menuId  &nbsp;-&nbsp Id to link a right click context menu element
  * @param {String} uniqueId &nbsp;-&nbsp Unique ID to use as local storage reference and internal variable names
  * @param {String} rowHeight &nbsp;-&nbsp Controls the height of the rows / number visible rows. May be (short, medium or normal)
  * @param {String} selectable &nbsp;-&nbsp Controls the selection Mode this may be: false, 'single' or 'multiple' or 'mixed'
  * @param {Object} groupable &nbsp;-&nbsp  Controls fields to use for data grouping Use Data grouping fx. {fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}
  * @param {Boolean} clickToSelect &nbsp;-&nbsp Controls if using a selection mode if you can click the rows to select
  * @param {Object} toolbar  &nbsp;-&nbsp Toggles and appends toolbar features fx.. {title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}
  * @param {Boolean} initializeToolbar &nbsp;-&nbsp Set to false if you will initialize the toolbar yourself
  * @param {Boolean} paging &nbsp;-&nbsp Enable paging mode
  * @param {Number} pagesize &nbsp;-&nbsp Number of rows per page
  * @param {Array} pagesizes &nbsp;-&nbsp Array of page sizes to show in the page size dropdown.
  * @param {Boolean} indeterminate &nbsp;-&nbsp Disable the ability to go to a specific page when paging.
  * @param {Function} source  &nbsp;-&nbsp Callback function for paging
  * @param {Boolean} hidePagerOnOnePage  &nbsp;-&nbsp If true, hides the pager if there's only one page worth of results.
  * @param {Boolean} filterable &nbsp;-&nbsp Enable Column Filtering, This will require column filterTypes as well.
  * @param {Boolean} disableClientFilter &nbsp;-&nbsp Disable Filter Logic client side and let your server do it
  * @param {Boolean} disableClientSort &nbsp;-&nbsp Disable Sort Logic client side and let your server do it
  * @param {String} resultsText &nbsp;-&nbsp Can provide a custom function to adjust results text on the toolbar
  * @param {Boolean} rowReorder &nbsp;-&nbsp If set you can reorder rows. Requires rowReorder formatter
  * @param {Boolean} showDirty &nbsp;-&nbsp  If true the dirty indicator will be shown on the rows
  * @param {Boolean} allowOneExpandedRow  &nbsp;-&nbsp Controls if you cna expand more than one expandable row.
  * @param {Boolean} enableTooltips &nbsp;-&nbsp Process tooltip logic at a cost of performance
  * @param {Boolean} disableRowDeactivation &nbsp;-&nbsp if a row is activated the user should not be able to deactivate it by clicking on the activated row
  * @param {Boolean} sizeColumnsEqually &nbsp;-&nbsp If true make all the columns equal width
  * @param {Boolean} expandableRow &nbsp;-&nbsp If true we append an expandable row area without the rowTemplate feature being needed.
  * @param {Boolean} redrawOnResize &nbsp;-&nbsp If set to false we skip redraw logic on the resize of the page.
  */
  function Datagrid(element) {
    this.element = $(element);
    Soho.logTimeStart(pluginName);
    this.init();
    Soho.logTimeEnd(pluginName);
  }

  // Actual Plugin Code
  Datagrid.prototype = {

    init: function() {
      var self = this, html = $('html');

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isFirefoxMac = (navigator.platform.indexOf('Mac') !== -1 && navigator.userAgent.indexOf(') Gecko') !== -1);
      this.isIe = html.is('.ie');
      this.isIe9 = html.is('.ie9');
      this.isSafari = html.is('.is-safari');
      this.isWindows = (navigator.userAgent.indexOf('Windows') !== -1);
      this.settings = settings;
      this.initSettings();
      this.originalColumns = self.columnsFromString(JSON.stringify(this.settings.columns));
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];

      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handlePaging();
      this.handleEvents();
      this.handleKeys();

      setTimeout(function () {
        self.element.trigger('rendered', [self.element, self.headerRow, self.pagerBar]);
      }, 0);
    },

    initSettings: function () {

      this.sortColumn = {sortField: null, sortAsc: true};
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0;// Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },

    //Re render both header and rows
    render: function () {
      this.loadData(this.settings.dataset);
    },

    //Run First Render the Header and Rows
    firstRender: function () {
      var self = this;

      self.contentContainer = $('<div class="datagrid-body"></div>');

      if (this.settings.dataset === 'table') {
        self.table = $(this.element).addClass('datagrid');

        var wrapper = $(this.element).closest('.datagrid-container');
        if (wrapper.length === 0) {
          self.table.wrap('<div class="datagrid-container"></div>');
          this.element = self.table.closest('.datagrid-container');
        }

        self.settings.dataset = self.htmlToDataset();
        self.table.remove();
        self.table = $('<table></table>').addClass('datagrid').attr('role', 'grid').appendTo(self.contentContainer);

      } else {
        self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.contentContainer);
        this.element.addClass('datagrid-container');
      }

      if (this.isWindows) {
        this.element.addClass('is-windows'); //need since scrollbars are visible
      }

      //initialize row height by a setting
      if (settings.rowHeight !== 'normal') {
        self.table.addClass(settings.rowHeight + '-rowheight');
        this.element.addClass(settings.rowHeight + '-rowheight');
      }

      //A treegrid is considered not editable unless otherwise specified.
      if (this.settings.treeGrid && !this.settings.editable) {
        self.table.attr('aria-readonly', 'true');
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      self.table.empty();
      self.renderRows();
      self.element.append(self.contentContainer);

      self.clearHeaderCache();
      self.renderHeader();
      self.container = self.element.closest('.datagrid-container');

      self.settings.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.settings.buttonSelector, self.table).button();
    },

    htmlToDataset: function () {
      var rows = $(this.element).find('tbody tr'),
        self = this,
        specifiedCols = (self.settings.columns.length > 0),
        dataset = [];

      //Geneate the columns if not supplier
      if (!specifiedCols) {
        var headers = $(this.element).find('thead th'),
          firstRow = self.element.find('tbody tr:first()');

        headers.each(function (i, col) {
          var colSpecs = {},
            column = $(col),
            colName = 'column'+i;

          colSpecs.id  = column.text().toLowerCase();
          colSpecs.name = column.text();
          colSpecs.field = colName;

          var link = firstRow.find('td').eq(i).find('a');
          if (link.length > 0) {
            colSpecs.formatter = Formatters.Hyperlink;
            colSpecs.href = link.attr('href');
          }

          self.settings.columns.push(colSpecs);
        });
      }

      rows.each(function () {
        var cols = $(this).find('td'),
          newRow = {};

        cols.each(function (i, col) {
          var column = $(col),
            colName = 'column'+i;

          if (self.settings.columns[i].formatter) {
            newRow[colName] = column.text();
          } else {
            newRow[colName] = column.html();
          }

          if (specifiedCols) {
            self.settings.columns[i].field = colName;
          }

        });

        dataset.push(newRow);
      });

      return dataset;
    },

    /**
    * Add a row of data to the grid and dataset.
    * @param {Object} data &nbsp;-&nbsp An data row object
    * @param {String} location &nbsp;-&nbsp Where to add the row. This can be 'top' or leave off for 'bottom'
    */
    addRow: function (data, location) {
      var self = this,
        isTop = false,
        row = 0,
        cell = 0,
        args,
        rowNode;

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      }
      //Add row status
      data.rowStatus = {icon: 'new', text: 'New', tooltip: 'New'};

      // Add to array
      if (typeof location === 'string') {
        self.settings.dataset[isTop ? 'unshift' : 'push'](data);
      }
      else {
        self.settings.dataset.splice(location, 0, data);
      }

      // Add to ui
      self.renderRows();

      // Sync with others
      self.syncSelectedUI();
      self.updateSelected();

      // Set active and fire handler
      setTimeout(function () {
        row = isTop ? row : self.settings.dataset.length - 1;
        self.setActiveCell(row, cell);

        rowNode = self.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]');
        args = {row: row, cell: cell, target: rowNode, value: data, oldValue: []};

        self.pagerRefresh(location);
        self.element.triggerHandler('addrow', args);
      }, 10);
    },

    pagerRefresh: function (location) {
      if (this.pager) {
        var activePage = this.pager.activePage;
        if (typeof location === 'string') {
          activePage = location === 'top' ? 1 : this.pager._pageCount;
        }
        else if (typeof location === 'number') {
          activePage = Math.floor(location / this.pager.settings.pagesize + 1);
        }

        this.pager.pagingInfo = $.extend({}, this.pager.pagingInfo, {
          activePage: activePage,
          total: this.settings.dataset.length,
          pagesize: this.settings.pagesize
        });

        this.renderPager(this.pager.pagingInfo);
      }
    },

    /**
    * Remove a row of data to the grid and dataset.
    * @param {Number} row &nbsp;-&nbsp The row index
    * @param {Boolean} nosync &nbsp;-&nbsp Dont sync the selected rows.
    */
    removeRow: function (row, nosync) {
      var rowNode = this.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]'),
        rowData = this.settings.dataset[row];

      this.unselectRow(row, nosync);
      this.settings.dataset.splice(row, 1);
      this.renderRows();
      this.element.trigger('rowremove', {row: row, cell: null, target: rowNode, value: [], oldValue: rowData});
    },

    /**
    * Remove all selected rows from the grid and dataset.
    */
    removeSelected: function () {

      var self = this,
        selectedRows = this.selectedRows();

      for (var i = selectedRows.length-1; i >= 0; i--) {
        self.removeRow(selectedRows[i].idx, true);
        this.updateSelected();
      }
      this.pagerRefresh();
      this.syncSelectedUI();
    },

    updateDataset: function (dataset, pagerInfo) {
      this.loadData(dataset, pagerInfo);
    },

    triggerSource: function(pagerType) {

      this.pager.pagerInfo = this.pager.pagerInfo || {};
      this.pager.pagerInfo.type = pagerType;

      if (pagerType !== 'refresh') {
        this.pager.pagerInfo.activePage = 1;
      }
      this.renderPager(this.pager.pagerInfo);
    },

    loadData: function (dataset, pagerInfo, isResponse) {
      this.settings.dataset = dataset;

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;
        pagerInfo.type = 'initial';
      }

      if (this.pager) {
        if (pagerInfo.activePage > -1) {
          this.pager.activePage = pagerInfo.activePage;
        }
        this.pager.settings.dataset = dataset;
      }

      //Update Paging and Clear Rows
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();

      //Resize and re-render if have a new dataset (since automatic column sizing depends on the dataset)
      if (pagerInfo.type === 'initial') {
        this.clearHeaderCache();
        this.renderRows();
        this.renderHeader();
      } else {
        this.renderRows();
      }

      this.renderPager(pagerInfo, isResponse);

      if (pagerInfo && pagerInfo.preserveSelected) {
        this.updateSelected();
        this.syncSelectedUI();
      } else {
        this.unSelectAllRows();
      }
    },

    uniqueId: function (suffix) {
      var uniqueid = this.settings.uniqueId ?
        this.settings.uniqueId + '-' + suffix :
        (window.location.pathname.split('/').pop()
          .replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '')
          .replace(/[^-\w]+/g, '')
          .replace(/\./g, '-')
          .replace(/ /g, '-')
          .replace(/%20/g, '-') +'-'+
            (this.element.attr('id') || 'datagrid') +'-'+ this.gridCount + suffix);

      return uniqueid.replace(/--/g, '-');
    },

    visibleColumns: function (skipBuiltIn) {
      var visible = [];
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }
        visible.push(column);
      }
      return visible;
    },

    lastColumnIdx: function () {
      var last = 0;
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        last = j;
      }
      return last;
    },

    getColumnGroup: function(idx) {
      var total = 0,
        colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId('-header-group-' + l);
        }
      }
    },

    headerText: function (col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return '<span class="audible">'+ text + '</span>';
      }

      return text;
    },

    //Render the Header
    renderHeader: function() {
      var self = this,
        headerRow = '',
        headerColGroup = '<colgroup>',
        cols= '',
        uniqueId;

      var colGroups = this.settings.columnGroups;

      if (colGroups) {

        var total = 0;

        headerRow += '<tr role="row" class="datagrid-header-groups">';

        for (var k = 0; k < colGroups.length; k++) {

          total += parseInt(colGroups[k].colspan);
          uniqueId = self.uniqueId('-header-group-' + k);

          headerRow += '<th colspan="' + colGroups[k].colspan + '" id="' + uniqueId + '"' + '><div class="datagrid-column-wrapper "><span class="datagrid-header-text">'+ colGroups[k].name +'</span></div></th>';
        }

        if (total < this.visibleColumns().length) {
          headerRow += '<th colspan="' + (this.visibleColumns().length - total) + '"></th>';
        }
        headerRow += '</tr><tr>';
      } else {
        headerRow += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j],
          id = self.uniqueId('-header-' + j),
          isSortable = (column.sortable === undefined ? true : column.sortable),
          isResizable = (column.resizable === undefined ? true : column.resizable),
          isSelection = column.id === 'selectionCheckbox',
          alignmentClass = (column.align === 'center' ? ' l-'+ column.align +'-text' : '');// Disable right align for now as this was acting wierd

        headerRow += '<th scope="col" role="columnheader" class="' + (isSortable ? 'is-sortable' : '') + (isResizable ? ' is-resizable' : '') + (column.hidden ? ' is-hidden' : '') + (column.filterType ? ' is-filterable' : '') + (alignmentClass ? alignmentClass : '') + '"' +
         ' id="' + id + '" data-column-id="'+ column.id + '"' + (column.field ? ' data-field="'+ column.field +'"' : '') +
         (column.headerTooltip ? 'title="' + column.headerTooltip + '"' : '') +
         (column.reorderable === false ? ' data-reorder="false"' : '') +
         (colGroups ? ' headers="' + self.getColumnGroup(j) + '"' : '') + '>';

        headerRow += '<div class="' + (isSelection ? 'datagrid-checkbox-wrapper ': 'datagrid-column-wrapper') + (column.align === undefined ? '' : ' l-'+ column.align +'-text') + '"><span class="datagrid-header-text'+ (column.required ? ' required': '') + '">' + self.headerText(settings.columns[j]) + '</span>';
        cols += '<col' + this.calculateColumnWidth(column, j) + (column.hidden ? ' class="is-hidden"' : '') + '>';

        if (isSelection) {
          headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox"></span>';
        }

        if (isSortable) {
          headerRow += '<div class="sort-indicator">' +
            '<span class="sort-asc">' + $.createIcon({ icon: 'dropdown' }) + '</span>' +
            '<span class="sort-desc">' + $.createIcon({ icon: 'dropdown' }) + '</div>';
        }

        headerRow += '</div></th>';
      }
      headerRow += '</tr>';

      headerColGroup += cols + '</colgroup>';

      if (self.headerRow === undefined) {
        self.headerContainer = $('<div class="datagrid-header"><table role="grid" '+ this.headerTableWidth() + '></table></div>');
        self.headerTable = self.headerContainer.find('table');
        self.headerColGroup = $(headerColGroup).appendTo(self.headerTable);
        self.headerRow = $('<thead>' + headerRow + '</thead>').appendTo(self.headerContainer.find('table'));
        self.element.prepend(self.headerContainer);
      } else {
        self.headerContainer.find('table').css('width', this.totalWidth);
        self.headerRow.html(headerRow);
        self.headerColGroup.html(cols);
      }

      if (this.settings.enableTooltips) {
        self.headerRow.find('th[title]').tooltip();
      }

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.renderFilterRow();

      if (this.restoreSortOrder) {
        this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);
        this.restoreSortOrder = false;
      }

      if (this.restoreFilter) {
        this.applyFilter(this.savedFilter);
        this.restoreFilter = false;
        this.savedFilter = null;
      }
    },

    filterRowRendered: false,

    //Render the Filter Row
    renderFilterRow: function () {
      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');
      this.headerRow.find('.datagrid-filter-wrapper').remove();

      //Loop the columns looking at the filter types and generate the markup for the various Types
      //Supported Filter Types: text, integer, date, select, decimal, lookup, percent, checkbox, contents
      for (var j = 0; j < this.settings.columns.length; j++) {
        if (this.settings.columns[j].filterType) {
          var col = this.settings.columns[j],
            id = self.uniqueId('-header-' + j),
            header = this.headerRow.find('#'+id),
            filterId = self.uniqueId('-header-filter-' + j),
            filterMarkup = '<div class="datagrid-filter-wrapper">'+ this.renderFilterButton(col) +'<label class="audible" for="'+ filterId +'">' +
              col.name + '</label>';

          switch (col.filterType) {
            case 'checkbox':
              //just the button
              break;
            case 'date':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="datepicker" id="'+ filterId +'"/>';
              break;
            case 'decimal':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" data-mask-mode="number" data-mask="'+ (col.mask ? col.mask : '####.00') + '">';
              break;
            case 'percent':
              col.maskOptions = {
                showSymbol: 'percent',
                pattern: col.mask || (((col.name + '').toLowerCase() === 'decimal') ? '####.00' : '')
              };
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" data-mask-mode="number" data-mask="'+ col.maskOptions.pattern +'"/>';
              break;
            case 'contents':
            case 'select':
              filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType ==='select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="'+ filterId +'">';
              if (col.options) {
                if (col.filterType ==='select') {
                  filterMarkup += '<option></option>';
                }

                for (var i = 0; i < col.options.length; i++) {
                  var option = col.options[i],
                  optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;
                  filterMarkup += '<option value = "' +optionValue + '">' + option.label + '</option>';
                }
              }
              filterMarkup += '</select>';

              break;
			      case 'time':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="timepicker" id="'+ filterId +'"/>';
              break;
            default:
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'"/>';
              break;
          }

          filterMarkup += '</div>';
          header.find('.datagrid-column-wrapper').after(filterMarkup);
          header.find('.datepicker').datepicker(col.editorOptions ? col.editorOptions : {dateFormat: col.dateFormat});
          header.find('select.dropdown').dropdown(col.editorOptions);
          header.find('.multiselect').multiselect(col.editorOptions);
          header.find('[data-mask]').mask(col.maskOptions);
		      header.find('.timepicker').timepicker(col.editorOptions ? col.editorOptions : {timeFormat: col.timeFormat});
        }
      }

      //Attach Keyboard support
      var popupOpts = {attachToBody: $('html').hasClass('ios'), offset: {y: 15}, placementOpts: {strategies: ['flip', 'nudge']}};

      this.headerRow.addClass('is-filterable');
      this.headerRow.find('.btn-filter').popupmenu(popupOpts).on('selected.datagrid', function () {
        self.applyFilter();
      });

      this.headerRow.off('keydown.datagrid').on('keydown.datagrid', '.datagrid-filter-wrapper input', function (e) {
        e.stopPropagation();

        if (e.which === 13) {
          e.preventDefault();
          $(this).trigger('change');
        }

      }).off('change.datagrid').on('change.datagrid', '.datagrid-filter-wrapper input', function () {
        self.applyFilter();
      });

      this.headerRow.find('.dropdown, .multiselect').on('selected.datagrid', function () {
        self.applyFilter();
      });

      self.filterRowRendered = true;
    },

    //Render one filter item as used in renderFilterButton
    renderFilterItem: function (icon, text, checked) {
      var iconMarkup = $.createIcon({ classes: 'icon icon-filter', icon: 'filter-' + icon });
      return '<li '+ (checked ? 'class="is-checked"' : '') +'><a href="#">'+ iconMarkup +'<span>'+ Locale.translate(text) +'</span></a></li>';
    },

    //Render the Filter Button and Menu based on filterType - which determines the options
    renderFilterButton: function (col) {
      var self = this,
        filterType = col.filterType,
        isDisabled = col.filterDisabled,
        filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [],
        inArray = function (s, array) {
          array = array || filterConditions;
          return ($.inArray(s, array) > -1);
        },
        render = function (icon, text, checked) {
          return filterConditions.length && !inArray(icon) ?
            '' : self.renderFilterItem(icon, text, checked);
        },
        btnMarkup = '<button type="button" class="btn-menu btn-filter" data-init="false" ' + (isDisabled ? ' disabled' : '') + ' type="button"><span class="audible">Filter</span>' + $.createIcon({icon: 'dropdown' , classes: 'icon-dropdown'}) +'</button>' +
        '<ul class="popupmenu has-icons is-translatable is-selectable">';

      //Just the dropdown
      if (filterType === 'contents' || filterType === 'select') {
        return '';
      }

      if (filterType === 'text') {
        btnMarkup += ''+
          render('contains', 'Contains', true) +
          render('does-not-contain', 'DoesNotContain', false);
      }

      if (filterType === 'checkbox') {
        btnMarkup += ''+
          render('selected-notselected', 'All', true) +
          render('selected', 'Selected') +
          render('not-selected', 'NotSelected');
      }

      if (filterType !== 'checkbox') {
        btnMarkup += ''+
          render('equals', 'Equals', (filterType === 'integer' || filterType === 'date' || filterType === 'time')) +
          render('does-not-equal', 'DoesNotEqual') +
          render('is-empty', 'IsEmpty') +
          render('is-not-empty', 'IsNotEmpty');
      }

      if (/\b(integer|decimal|date|time|percent)\b/g.test(filterType)) {
        btnMarkup += ''+
          render('less-than', 'LessThan') +
          render('less-equals', 'LessOrEquals') +
          render('greater-than', 'GreaterThan') +
          render('greater-equals', 'GreaterOrEquals');
      }

      if (filterType === 'text') {
        btnMarkup += ''+
          render('end-with', 'EndsWith') +
          render('does-not-end-with', 'DoesNotEndWith') +
          render('start-with', 'StartsWith') +
          render('does-not-start-with', 'DoesNotStartWith');
      }

      btnMarkup += '</ul>';
      return btnMarkup ;
    },

    toggleFilterRow: function () {

      if (this.settings.filterable) {
        this.headerRow.removeClass('is-filterable');
        this.headerRow.find('.is-filterable').removeClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
        this.filterRowRendered = false;
        this.element.removeClass('has-filterable-columns');
      } else {
        this.settings.filterable = true;

        if (!this.filterRowRendered) {
          this.renderFilterRow();
        }

        this.element.addClass('has-filterable-columns');

        this.headerRow.addClass('is-filterable');
        this.headerRow.find('.is-filterable').addClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').show();
      }
    },


    applyFilter: function (conditions) {
      var self = this;
      this.filteredDataset = null;

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      var checkRow = function (rowData) {
        var isMatch = true;

        for (var i = 0; i < conditions.length; i++) {
          var columnDef = self.columnById(conditions[i].columnId)[0],
            field = columnDef.field,
            rowValue = self.fieldValue(rowData, field),
            rowValueStr = rowValue.toString().toLowerCase(),
            conditionValue = conditions[i].value.toString().toLowerCase();

          //Percent filter type
          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();
            if ((columnDef.name + '').toLowerCase() === 'decimal') {
              rowValue = window.Formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Decimal(false, false, conditionValue, columnDef);
            } else if ((columnDef.name + '').toLowerCase() === 'integer') {
              rowValue = window.Formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Integer(false, false, conditionValue, columnDef);
            }
          }

          //Run Data over the formatter
          if (columnDef.filterType === 'text') {
            rowValue = self.formatValue(columnDef.formatter, i , conditions[i].columnId, rowValue, columnDef, rowData, self);

            //Strip any html markup that might be in the formatters
            var rex = /(<([^>]+)>)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex , '').toLowerCase();

            rowValueStr = rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select') {
            rowValue = rowValue.toLowerCase();
          }

		  if (columnDef.filterType === 'date' || columnDef.filterType === 'time') {
            conditionValue = Locale.parseDate(conditions[i].value, conditions[i].format);
            if (conditionValue) {
              if (columnDef.filterType === 'time') {
                // drop the day, month and year
                conditionValue.setDate(1);
                conditionValue.setMonth(0);
                conditionValue.setYear(0);
              }
              conditionValue = conditionValue.getTime();
		    }

            if (rowValue instanceof Date) {
              rowValue = rowValue.getTime();
            }
            else if (typeof rowValue === 'string' && rowValue) {
              if (!columnDef.sourceFormat) {
                rowValue = Locale.parseDate(rowValue, {pattern: conditions[i].format});
              } else {
                rowValue = Locale.parseDate(rowValue, (typeof columnDef.sourceFormat === 'string' ? {pattern: columnDef.sourceFormat}: columnDef.sourceFormat));
              }

              if (rowValue) {
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  rowValue.setDate(1);
                  rowValue.setMonth(0);
                  rowValue.setYear(0);
                }
                rowValue = rowValue.getTime();
              }
            }
		  }

          if (typeof rowValue === 'number') {
            rowValue =  parseFloat(rowValue);
            conditionValue = parseFloat(conditionValue);
          }

          switch (conditions[i].operator) {
            case 'equals':

              //This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase().indexOf(rowValue) >= 0 && rowValue.toString() !== '';
                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = (rowValue === conditionValue && rowValue !== '');
              }

              break;
            case 'does-not-equal':
              isMatch = (rowValue !== conditionValue);
              break;
            case 'contains':
              isMatch = (rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '');
              break;
            case 'does-not-contain':
              isMatch = (rowValueStr.indexOf(conditionValue) === -1);
              break;
            case 'end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              break;
            case 'start-with':
              isMatch = (rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'does-not-end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              isMatch = !isMatch;
              break;
            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'is-empty':
              isMatch = (rowValue === '');
              break;
            case 'is-not-empty':
              isMatch = (rowValue !== '');
              break;
            case 'less-than':
              isMatch = (rowValue < conditionValue && rowValue !== '');
              break;
            case 'less-equals':
              isMatch = (rowValue <= conditionValue && rowValue !== '');
              break;
            case 'greater-than':
              isMatch = (rowValue > conditionValue && rowValue !== '');
              break;
            case 'greater-equals':
              isMatch = (rowValue >= conditionValue && rowValue !== '');
              break;
            case 'selected':

              if (columnDef && columnDef.isChecked) {
                 isMatch = columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '1' || rowValueStr ==='true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;
           case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                 isMatch = !columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '0' || rowValueStr ==='false' || rowValue === false || rowValue === 0) && rowValueStr !== '';
              break;
            case 'selected-notselected':
              isMatch = true;
              break;
            default:
          }

          if (!isMatch) {
            return false;
          }
        }
        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        var dataset, isFiltered, i, len;

        if (this.settings.treeGrid) {
          dataset = this.settings.treeDepth;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i].node);
            dataset[i].node.isFiltered = isFiltered;
          }
        }
        else {
          dataset = this.settings.dataset;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i]);
            dataset[i].isFiltered = isFiltered;
          }
        }
      }
      this.renderRows();
      this.resetPager('filtered');
      this.setSearchActivePage();
      this.element.trigger('filtered', {op: 'apply', conditions: conditions});
      this.saveUserSettings();
    },

    /**
    * Clear the Filter row Conditions and Reset the Data.
    */
    clearFilter: function () {
      this.renderFilterRow();
      this.applyFilter();
      this.element.trigger('filtered', {op: 'clear', conditions: []});
    },

    setFilterConditions: function (conditions) {
      for (var i = 0; i < conditions.length; i++) {
        //Find the filter row
        var rowElem = this.headerRow.find('th[data-column-id="'+ conditions[i].columnId +'"]'),
          input = rowElem.find('input, select'),
          btn = rowElem.find('.btn-filter');

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value);

        if (input.is('select') && conditions[i].value instanceof Array) {
          for (var j = 0; j < conditions[i].value.length; j++) {
            input.find('option[value="'+ conditions[i].value[j] + '"]').prop('selected', true);
          }
          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + conditions[i].operator);
      }
    },

    //Get filter conditions in array form from the UI
    filterConditions: function () {
      // Do not modify keyword search filter expr
      if (this.filterExpr && this.filterExpr.length === 1 && this.filterExpr[0].keywordSearch) {
        delete this.filterExpr[0].keywordSearch;
        return this.filterExpr;
      }

      var self = this;
      this.filterExpr = [];

      //Create an array of objects with: field, id, filterType, operator, value
      this.headerRow.find('th').each(function () {
        var rowElem = $(this),
          btn = rowElem.find('.btn-filter'),
          input = rowElem.find('input, select'),
          isDropdown = input.is('select'),
          svg = btn.find('.icon-dropdown:first'),
          op,
		      format;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length ===0) {
          return;
        }

        var condition = {columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: input.val() ? input.val() : ''};

        if (input.data('datepicker')) {
          format = input.data('datepicker').settings.dateFormat;
          if (format === 'locale') {
            format = Locale.calendar().dateFormat.short;
          }
          condition.format = format;
        }

		if (input.data('timepicker')) {
          format = input.data('timepicker').settings.timeFormat;
          condition.format = format;
        }

        self.filterExpr.push(condition);

      });

      return self.filterExpr;
    },

    // Create draggable columns
    createDraggableColumns: function () {
      var self = this,
        headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]'),
        showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend('<span class="drag-target-arrows"></span>');
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.not('[data-reorder="false"]').prepend('</span><span class="handle">&#8286;</span>');
      headers.prepend('<span class="is-draggable-target"></span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns');

      // Initialize Drag api
      $('.handle', headers).each(function() {
        var clone, headerPos, offPos,
          handle = $(this),
          header = handle.parent();

        handle.on('mousedown.datagrid', function(e) {
          e.preventDefault();

          header.drag({clone: true, cloneAppendTo: headers.first().parent().parent(), clonePosIsFixed: true})
            .on('dragstart.datagrid', function (e, pos, thisClone) {
              var index;

              clone = thisClone;

              clone.removeAttr('id').addClass('is-dragging-clone')
                .css({left: pos.left, top: pos.top});
              $('.is-draggable-target', clone).remove();

              self.setDraggableColumnTargets();

              headerPos = header.position();
              offPos = {top: (pos.top - headerPos.top), left: (pos.left - headerPos.left)};

              index = self.targetColumn(headerPos);
              self.draggableStatus.startIndex = index;
              e.stopImmediatePropagation();
            })
            .on('drag.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';
              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var i, l, n, target, rect,
                index = self.targetColumn(headerPos);

              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (index !== -1) {
                for (i=0, l=self.draggableColumnTargets.length; i<l; i++) {
                  target = self.draggableColumnTargets[i];
                  n = i + 1;

                  if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                    if (target.index > self.draggableStatus.startIndex && (n < l)) {
                      target = self.draggableColumnTargets[n];
                    }

                    target.el.addClass('is-over');
                    showTarget.addClass('is-over');
                    rect = target.el[0].getBoundingClientRect();
                    showTarget[0].style.left = parseInt(rect.left) + 'px';
                    showTarget[0].style.top =  (parseInt(rect.top) + 1) + 'px';

                  }
                }
              }

              e.stopImmediatePropagation();
            })
            .on('dragend.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';

              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var index = self.targetColumn(headerPos),
               dragApi = header.data('drag'),
               tempArray = [],
               i, l, indexFrom, indexTo, target;

              // Unbind drag from header
              if (dragApi && dragApi.destroy) {
                dragApi.destroy();
              }

              self.draggableStatus.endIndex = index;
              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (self.draggableStatus.endIndex !== -1) {
                if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                  target = self.draggableColumnTargets[index];

                  //Swap columns
                  for (i=0, l=self.settings.columns.length; i < l; i++) {
                      if (!self.settings.columns[i].hidden &&
                          self.settings.columns[i].id !== 'selectionCheckbox') {
                        tempArray.push(i);
                      }
                    }

                    indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                    indexTo = tempArray[self.draggableStatus.endIndex] || 0;

                    self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                    self.updateColumns(self.settings.columns);

                  }
              }

            });
        });
      });
    },

    // Set draggable columns target
    setDraggableColumnTargets: function () {
      var self = this,
        headers = self.headerNodes()
          .not('.is-hidden').not('[data-column-id="selectionCheckbox"]'),
        target, pos, extra;

      self.draggableColumnTargets = [];
      self.draggableStatus = {};

      // Move last target if not found in last header
      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = ($(this).is('.last')) ? index - 1 : index; // Extra target for last header th
        target = headers.eq(idx);
        pos = target.position();
        // Extra space around, if dropped item bit off from drop area
        extra = 20;

        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra, x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra, y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },

    // Get column index
    targetColumn: function (pos) {
      var self = this,
        index = -1,
        target, i, l;

      for (i=0, l=self.draggableColumnTargets.length-1; i<l; i++) {
        target = self.draggableColumnTargets[i];
        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 &&
            pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          index = target.index;
        }
      }
      return index;
    },

    // Move an array element position
    arrayIndexMove: function(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    // Attach Drag Events to Rows
    createDraggableRows: function () {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      // Attach the Drag API
      this.tableBody.arrange({
          placeholder: '<tr class="datagrid-reorder-placeholder"><td colspan="'+ this.visibleColumns().length +'"></td></tr>',
          handle: '.datagrid-reorder-icon'
        })
        .on('beforearrange.datagrid', function(e, status) {
          if (self.isSafari) {
            status.start.css({'display': 'inline-block'});
          }
        })
        .on('arrangeupdate.datagrid', function(e, status) {
          if (self.isSafari) {
            status.end.css({'display': ''});
          }
          // Move the elem in the data set
          self.settings.dataset.splice(status.endIndex, 0, self.settings.dataset.splice(status.startIndex, 1)[0]);
          // Fire an event
          self.element.trigger('rowreorder', [status]);
        });

    },

    //Return Value from the Object handling dotted notation
    fieldValue: function (obj, field) {
      if (!field || !obj) {
        return '';
      }

      if (field.indexOf('.') > -1) {
        return field.split('.').reduce(function(o, x) {
          return (o ? o[x] : '');
        }, obj);
      }

      var rawValue = obj[field],
        value = (rawValue || rawValue === 0 || rawValue === false ? rawValue : '');

      value = $.escapeHTML(value);
      return value;
    },

    // Set tree root nodes
    setTreeRootNodes: function() {
      this.settings.treeRootNodes = this.settings.treeDepth
        .filter(function(node) {
          return node.depth === 1;
        });
    },

    // Set tree depth
    setTreeDepth: function(dataset) {
      var self = this,
        idx = 0,
        iterate = function(node, depth) {
          idx++;
          self.settings.treeDepth.push({idx: idx, depth: depth, node: node});
          var children = node.children || [];
          for (var i = 0, len = children.length; i < len; i++) {
            iterate(children[i], depth + 1);
          }
        };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },

    setRowGrouping: function () {
      var groupSettings = this.settings.groupable;
      if (!groupSettings) {
        return;
      }

      this.originalDataset = this.settings.dataset.slice();

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = GroupBy.sum(this.settings.dataset , groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = GroupBy.max(this.settings.dataset , groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = GroupBy.list(this.settings.dataset , groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = window.GroupBy(this.settings.dataset , groupSettings.fields);
    },

    //Render the Rows
    renderRows: function() {
      var tableHtml = '',
        self = this, i,
        s = self.settings,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = s.pagesize,
        dataset = s.dataset;

      var body = self.table.find('tbody');
      self.bodyColGroupHtml = '<colgroup>';

      if (body.length === 0) {
        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);
      }

      self.recordCount = 0;
      self.filteredCount = 0;

      // Reset recordCount for paging
      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[(pagesize * activePage) - pagesize].idx-1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      for (i = 0; i < dataset.length; i++) {

        //For better performance dont render out of page
        if (s.paging && !s.source) {

          if (activePage === 1 && (i - this.filteredCount) >= pagesize){
            if (!dataset[i].isFiltered) {
              this.recordCount++;
            }
            continue;
          }

          if (activePage > 1 && !((i - this.filteredCount) >= pagesize*(activePage-1) && (i - this.filteredCount) < pagesize*activePage)) {
            if (!dataset[i].isFiltered) {
              if (this.filteredCount) {
                this.recordCount++;
              }
            } else {
              this.filteredCount++;
            }
            continue;
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue;
          }
        }

        //Exclude Filtered Rows
        if ((s.treeGrid ? s.treeRootNodes[i].node : dataset[i]).isFiltered) {
          this.filteredCount++;
          continue;
        }

        //Handle Grouping
        if (this.settings.groupable) {
          //First push group row
          if (!this.settings.groupable.suppressGroupRow) {
            //Show the grouping row
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true);
          }

          if (this.settings.groupable.showOnlyGroupRow && dataset[i].values[0]) {
            var rowData = dataset[i].values[0];

            if (dataset[i].list) {
              rowData.list = dataset[i].list;
            }

            rowData.values = dataset[i].values;

            tableHtml += self.rowHtml(rowData, this.recordCount, i);
            this.recordCount++;
            continue;
          }

          //Now Push Groups
          for (var k = 0; k < dataset[i].values.length; k++) {
            tableHtml += self.rowHtml(dataset[i].values[k], this.recordCount, i);
            this.recordCount++;
          }

          // Now Push summary rowHtml
          if (this.settings.groupable.groupFooterRow) {
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true, true);
          }

          continue;
        }

        tableHtml += self.rowHtml(dataset[i], s.treeGrid ? this.recordCount : i, i);
        this.recordCount++;
      }

      //Append a Summary Row
      if (this.settings.summaryRow) {
        tableHtml += self.rowHtml(self.calculateTotals(), this.recordCount, null, false, true);
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        self.bodyColGroupHtml += '</colgroup>';

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        self.tableBody.before(self.bodyColGroup);
      }

      self.tableBody.html(tableHtml);
      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips();
      self.afterRender();

    },

    afterRender: function() {
      var self = this;

      //Init Inline Elements
      self.tableBody.find('select.dropdown').dropdown();

      //Commit Edits for inline editing
      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select')
        .on('listclosed', function () {
           var elem = $(this),
            newValue = elem.val(),
            row = elem.closest('tr');

            self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
         });

      self.tableBody.find('.spinbox').spinbox();

      //Set UI elements after dataload
      setTimeout(function () {

        if (!self.settings.source) {
          self.displayCounts();
        }

        self.setAlternateRowShading();
        self.createDraggableRows();

        if (!self.activeCell || !self.activeCell.node) {
          self.activeCell = {node: self.cellNode(0, 0, true).attr('tabindex', '0'), isFocused: false, cell: 0, row: 0};
        }

        if (self.activeCell.isFocused) {
          self.setActiveCell(self.activeCell.row, self.activeCell.cell);
        }

        //Update Selected Rows Across Page
        if (self.settings.paging && self.settings.source) {
          self.updateSelected();
          self.syncSelectedUI();
        }

        self.element.trigger('afterrender', {body: self.tableBody, header: self.headerRow, pager: self.pagerBar});
      }, 0);

    },

    cacheVirtualStats: function () {
      var containerHeight = this.element[0].offsetHeight,
        scrollTop = this.contentContainer[0].scrollTop,
        headerHeight = this.settings.rowHeight === 'normal' ? 40 : (this.settings.rowHeight === 'medium' ? 30 : 25),
        bodyHeight = containerHeight-headerHeight,
        rowHeight = this.settings.rowHeight === 'normal' ? 50 : (this.settings.rowHeight === 'medium' ? 40 : 30);

      this.virtualRange = {rowHeight: rowHeight,
                         top: Math.max(scrollTop - ((this.settings.virtualRowBuffer-1) * rowHeight), 0),
                         bottom: scrollTop + bodyHeight + ((this.settings.virtualRowBuffer-1) * rowHeight),
                         totalHeight: rowHeight * this.settings.dataset.length,
                         bodyHeight: bodyHeight};
    },

    // Check if the row is in the visble scroll area + buffer
    // Just call renderRows() on events that change
    isRowVisible: function(rowIndex) {
      if (!this.settings.virtualized) {
        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      }

      //determine if the row is in view
      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },

    // Set the heights on top or bottom based on scroll position
    setVirtualHeight: function () {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom,
        top = this.virtualRange.top;

      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (top > 0 && !this.topSpacer.length) {
        this.topSpacer = $('<tr class="datagrid-virtual-row-top" style="height: '+ top + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.prepend(this.topSpacer);
      }

      if (top > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', top + 'px');
      }

      if (top ===0 && this.topSpacer.length || this.virtualRange.topRow <= 1) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $('<tr class="datagrid-virtual-row-bottom" style="height: '+ bottom + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', bottom + 'px');
      }

      if (bottom <= 0 && this.bottomSpacer.length || (this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },

    // Set the alternate shading for tree
    setAlternateRowShading: function() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody)
          .removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },

    formatValue: function (formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue;
      api = api || this;

      //Use default formatter if undefined
      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter ==='string') {
        formattedValue = window.Formatters[formatter](row, cell, fieldValue, columnDef, rowData, api).toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }
      return formattedValue;
    },

    recordCount: 0,

    rowHtml: function (rowData, dataRowIdx, actualIndex, isGroup, isFooter) {
      var isEven = false,
        self = this,
        isSummaryRow = this.settings.summaryRow && !isGroup && isFooter,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = self.settings.pagesize,
        rowHtml = '',
        d = self.settings.treeDepth[dataRowIdx],
        depth, d2, i, l, isHidden;

      if (!rowData) {
        return '';
      }

      // Default
      d = d ? d.depth : 0;
      depth = d;

      // Setup if this row will be hidden or not
      for (i = dataRowIdx; i >= 0 && d > 1 && !isHidden; i--) {
        d2 = self.settings.treeDepth[i];
        if (d !== d2.depth && d > d2.depth) {
          d = d2.depth;
          isHidden = !d2.node.expanded;
        }
      }

      if (this.settings.groupable) {
        var groupSettings = this.settings.groupable;
        isHidden  = (groupSettings.expanded === undefined ? false : !groupSettings.expanded);

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
        }
      }

      //Group Rows
      if (this.settings.groupable && isGroup && !isFooter) {
        rowHtml = '<tr class="datagrid-rowgroup-header ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="'+ this.visibleColumns().length +'">' +
          Formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this) +
          '</td></tr>';
        return rowHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        rowHtml = '<tr class="datagrid-row datagrid-rowgroup-footer ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup">' +
          Formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this) +
          '</tr>';
        return rowHtml;
      }

      var ariaRowindex = ((dataRowIdx + 1) + (self.settings.source  ? ((activePage-1) * pagesize) : 0));

      isEven = (this.recordCount % 2 === 0);

      rowHtml = '<tr role="row" aria-rowindex="' + ariaRowindex + '"' +
                ' data-index="' + actualIndex + '"' +
                (self.settings.treeGrid && rowData.children ? ' aria-expanded="' + (rowData.expanded ? 'true"' : 'false"') : '') +
                (self.settings.treeGrid ? ' aria-level= "' + depth + '"' : '') +
                ' class="datagrid-row'+
                (isHidden ? ' is-hidden' : '') +
                (self.settings.alternateRowShading && !isEven ? ' alt-shading' : '') +
                (isSummaryRow ? ' datagrid-summary-row' : '') +
                (!self.settings.cellNavigation ? ' is-clickable' : '' ) +
                (self.settings.treeGrid ? (rowData.children ? ' datagrid-tree-parent' : (depth > 1 ? ' datagrid-tree-child' : '')) : '') +
                 '"' + '>';

      for (var j = 0; j < self.settings.columns.length; j++) {
        var col = self.settings.columns[j],
          cssClass = '',
          formatter = isSummaryRow ? col.summaryRowFormatter || col.formatter || self.defaultFormatter : col.formatter || self.defaultFormatter,
          formatted = self.formatValue(
            formatter,
            dataRowIdx,
            j,
            self.fieldValue(rowData, self.settings.columns[j].field),
            self.settings.columns[j],
            rowData,
            self
          );

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 ||
          formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (col.expanded) {
          self.treeExpansionField = col.expanded;
        }

        if (col.align) {
          cssClass += ' l-'+ col.align +'-text';
        }

        if (col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        // Add Column Css Classes

        //Add a readonly class if set on the column
        cssClass += (col.readonly ? ' is-readonly' : '');
        cssClass += (col.hidden ? ' is-hidden' : '');

        //Run a function that helps check if editable
        if (col.isEditable && !col.readonly) {
          var canEdit = col.isEditable(ariaRowindex - 1, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        }

        //Run a function that helps check if readonly
        var ariaReadonly = (col.id !== 'selectionCheckbox' &&
          (col.readonly || col.editor === undefined)) ?
          'aria-readonly="true"': '';

        if (col.isReadonly && !col.readonly && col.id !== 'selectionCheckbox') {
          var isReadonly = col.isReadonly(this.recordCount, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field);

        //Run a function that dynamically adds a class
        if (col.cssClass && typeof col.cssClass === 'function') {
          cssClass += ' ' + col.cssClass(this.recordCount, j, cellValue, col, rowData);
        }

        if (col.cssClass && typeof col.cssClass === 'string') {
          cssClass += ' ' + col.cssClass;
        }

        cssClass += (col.focusable ? ' is-focusable' : '');

        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, col);

        if (rowspan === '') {
          continue;
        }

        //Set Width of table col / col group elements
        var colWidth = '';
        if (this.recordCount === 0 || this.recordCount - ((activePage-1) * pagesize) === 0) {
          colWidth = this.calculateColumnWidth(col, j);
          self.bodyColGroupHtml += '<col' + colWidth + (col.hidden ? ' class="is-hidden"' : '') + '></col>';
        }

        rowHtml += '<td role="gridcell" ' + ariaReadonly + ' aria-colindex="' + (j+1) + '" '+
            ' aria-describedby="' + self.uniqueId('-header-' + j) + '"' +
           (cssClass ? ' class="' + cssClass + '"' : '') +
           (col.tooltip && typeof col.tooltip === 'string' ? ' title="' + col.tooltip.replace('{{value}}', cellValue) + '"' : '') +
           (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip ? ' title="' + rowData.rowStatus.tooltip + '"' : '') +
           (self.settings.columnGroups ? 'headers = "' + self.uniqueId('-header-' + j) + ' ' + self.getColumnGroup(j) + '"' : '') +
           (rowspan ? rowspan : '' ) +
           '><div class="datagrid-cell-wrapper">';

        if (col.contentVisible) {
          var canShow = col.contentVisible(dataRowIdx + 1, j, cellValue, col, rowData);
          if (!canShow) {
            formatted = '';
          }
        }

        rowHtml += formatted + '</div></td>';
      }

      rowHtml += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate,
          item = rowData,
          renderedTmpl = '';

        if (Tmpl && item) {
          var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
          renderedTmpl = compiledTmpl.render({dataset: item});
        }

        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="'+ this.visibleColumns().length +'">' +
          '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding">'+ renderedTmpl + '</div></div>' +
          '</td></tr>';
      }

      if (self.settings.expandableRow) {
        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="'+ this.visibleColumns().length +'">' +
          '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding"></div></div>' +
          '</td></tr>';
      }

      //Render Tree Children
      if (rowData.children) {
        for (i=0, l=rowData.children.length; i<l; i++) {
          this.recordCount++;
          rowHtml += self.rowHtml(rowData.children[i], this.recordCount, i);
        }
      }

      return rowHtml;
    },

    canvas:  null,
    totalWidth: 0,

    //This Function approximates the table auto widthing
    //Except use all column values and compare the text width of the header as max
    calculateTextWidth: function (columnDef) {
      var max = 0,
        self = this,
        field = columnDef.field,
        maxText = '',
        title = columnDef.name || '',
        chooseHeader = false;

      //Get max cell value length for this column
      for (var i = 0; i < this.settings.dataset.length; i++) {
        var val = this.fieldValue(this.settings.dataset[i], field),
           len = 0;

        //Get formatted value (without html) so we have accurate string that will display for this cell
        val = self.formatValue(columnDef.formatter, i, null, val, columnDef, this.settings.dataset[i], self);
        val = val.replace(/<\/?[^>]+(>|$)/g, '');

        len = val.toString().length;

        if (len > max) {
          max = len;
          maxText = val;
        }
      }

      //Use header text length as max if bigger than all data cells
      if (title.length > max) {
        max = title.length;
        maxText = title;
        chooseHeader = true;
      }

      if (maxText === '' || this.settings.dataset.length === 0) {
        maxText = columnDef.name || ' Default ';
        chooseHeader = true;
      }

      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = '14px arial';
      var metrics = context.measureText(maxText);
      return Math.round(metrics.width + (chooseHeader ? 60 : 52));  //Add padding and borders
    },

    headerWidths: [], //Cache

    headerTableWidth: function () {
      var cacheWidths = this.headerWidths[this.settings.columns.length-1];

      if (!cacheWidths) {
        return '';
      }
      this.setScrollClass();

      if (cacheWidths.widthPercent) {
        return 'style = "width: 100%"';
      } else if (!isNaN(this.totalWidth)) {
        return 'style = "width: ' + parseFloat(this.totalWidth) + 'px"';
      }

      return '';
    },

    setScrollClass: function () {
      var height = parseInt(this.contentContainer[0].offsetHeight),
          hasScrollBar = parseInt(this.contentContainer[0].scrollHeight) > height + 2;

      this.element.removeClass('has-vertical-scroll has-less-rows');

      if (hasScrollBar) {
        this.element.addClass('has-vertical-scroll');
      }

      if (!hasScrollBar && this.tableBody[0].offsetHeight <  height) {
        this.element.addClass('has-less-rows');
      }

    },

    clearHeaderCache: function () {
      this.headerWidths = [];
      this.totalWidth = 0;
      this.elemWidth = 0;
    },

    //Calculate the width for a column (upfront with no rendering)
    //https://www.w3.org/TR/CSS21/tables.html#width-layout
    calculateColumnWidth: function (col, index) {
      var visibleColumns, colPercWidth;
      visibleColumns = this.visibleColumns(true);

      var lastColumn = (index === this.lastColumnIdx());
      if (lastColumn && col.isStretched) {
        col.width = null;
      }

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) { // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }
        if (!this.elemWidth || this.elemWidth === 0) { // handle on invisible modal
          this.elemWidth = this.element.closest('.modal-contents').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: '+ cacheWidths.width + (cacheWidths.widthPercent ? '%' :'px') + '"';
      }

      //A column element with a value other than 'auto' for the 'width' property sets the width for that column.
      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col);  //reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      }

      lastColumn = index === this.lastColumnIdx() && this.totalWidth !== colWidth;

      // Simulate Auto Width Algorithm
      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually &&
        (['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1)) {

        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); //borders causing scroll

        //Handle Columns where auto width is bigger than the percent width
        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }

      }

      //Some Built in columns
      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 78;
        col.width = colWidth;
      }

      // cache the header widths
      this.headerWidths[index] = {id: col.id, width: (this.widthPercent ? colPercWidth : colWidth), widthPercent: this.widthPercent};
      this.totalWidth += col.hidden || lastColumn ? 0 : colWidth;

      //For the last column stretch it if it doesnt fit the area
      if (lastColumn) {
        var diff = this.elemWidth - this.totalWidth;

        if ((diff > 0) && (diff  > colWidth) && !this.widthPercent) {
          colWidth = diff - (this.isIe ? 19: 2);

          this.headerWidths[index] = {id: col.id, width: colWidth, widthPercent: this.widthPercent};
          col.width = colWidth;
          col.isStretched = true;
          this.totalWidth =  this.elemWidth - (this.isIe ? 19: 2);
        }

        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidth)) {
          this.table.css('width', this.totalWidth);
        }
      }

      if (!this.widthPercent && !colWidth) {
        return '';
      }

      return ' style="width: '+ (this.widthPercent ? colPercWidth + '%' : colWidth + 'px') + '"';
    },

    widthPercent: false,
    rowSpans: [],

    calculateRowspan: function (value, row, col) {
      var cnt = 0, min = null;

      if (!col.rowspan) {
        return;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          cnt++;
          if (min === null) {
            min = i;
          }
        }
      }

      if (row === min) {
        return ' rowspan ="'+ cnt + '"';
      }
      return '';
    },

    //Summary Row Totals use the aggregators
    calculateTotals: function() {
      this.settings.totals = Aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },

    // Set unit type (pixel or percent)
    setUnit: function(v) {
      return v + (/(px|%)/i.test(v + '') ? '' : 'px');
    },

    // Content tooltip for rich text editor
    setupContentTooltip: function (elem, width, td) {
      if (elem.text().length > 0) {
        var content = elem.clone();

        elem.tooltip({
          content: content,
          extraClass: 'alternate content-tooltip',
          placementOpts: {
            parent: elem,
            parentXAlignment: 'center',
            strategies: ['flip', 'nudge', 'shrink']
          }
        });

        if (width) {
          content[0].style.width = width;
        } else {
          elem.on('beforeshow.datagrid', function () {
            elem.off('beforeshow.datagrid');
            content[0].style.width = td[0].offsetWidth + 'px';
          });
        }
      }
    },

    setupTooltips: function () {
      if (!this.settings.enableTooltips) {
        return;
      }

      var self = this;
      // Implement Tooltip on cells with title attribute
      this.tableBody.find('td[title]').tooltip({placement: 'left', offset: {left: -5, top: 0}});
      this.tableBody.find('a[title]').tooltip();

      // Implement Tooltip on cells with ellipsis
      this.table.find('td.text-ellipsis').tooltip({content: function() {
        var cell = $(this),
          text = cell.text(),
          inner = cell.children('.datagrid-cell-wrapper');

        if (cell[0] && inner[0] && (inner[0].offsetWidth)< inner[0].scrollWidth && cell.data('tooltip')) {
          var w = inner.width();
          cell.data('tooltip').settings.maxWidth = w;
          return text;
        }

        return '';
      }});

      // Rich text editor content tooltip
      this.table.find('td .is-editor.content-tooltip').each(function() {
        var elem = $(this),
          td = elem.closest('td'),
          cell = td.attr('aria-colindex') - 1,
          col = self.columnSettings(cell),
          width = col.editorOptions && col.editorOptions.width ? self.setUnit(col.editorOptions.width) : false;

        self.setupContentTooltip(elem, width, td);
      });
    },

    //Returns all header nodes (not the groups)
    headerNodes: function () {
      return this.headerRow.find('tr:not(.datagrid-header-groups) th');
    },

    //Refresh one row in the grid
    updateRow: function (idx, data) {
      var rowData = (data ? data : this.settings.dataset[idx]);

      for (var j = 0; j < this.settings.columns.length; j++) {
        var col = this.settings.columns[j];

        if (col.hidden) {
          continue;
        }

        if (col.id && ['selectionCheckbox', 'expander'].indexOf(col.id) > -1) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, col.field), true);
      }

    },

    //given a new column set update the rows and reload
    updateColumns: function(columns, columnGroups) {
      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.clearHeaderCache();
      this.renderRows();
      this.renderHeader();
      this.resetPager('updatecolumns');
      this.element.trigger('columnchange', [{type: 'updatecolumns', columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();

    },

    saveColumns: function () {
      if (!this.settings.saveColumns) {
        return;
      }

      //Save to local storage
      if (this.canUseLocalStorage()) {
        localStorage[this.uniqueId('columns')] = JSON.stringify(this.settings.columns);
      }
    },

    // Omit events and save to local storage for supported settings
    saveUserSettings: function () {

      // Emit Event
      this.element.trigger('settingschanged', [{rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.pager ? this.pager.activePage : 1,
        filter: this.filterConditions()}]);

      // Save to Local Storage if the options are set
      var options = this.settings.saveUserSettings;
      if ($.isEmptyObject(options) || !this.canUseLocalStorage()) {
        return;
      }

      // Save Columns
      if (options.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = JSON.stringify(this.settings.columns);
      }

      // Save Row Height
      if (options.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      }

      // Save Sort Order
      if (options.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      }

      // Save Page Size
      if (options.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      }

      // Save Show Page Size Selector
      if (options.showPageSizeSelector) {
        localStorage[this.uniqueId('usersettings-show-pagesize-selector')] = this.settings.showPageSizeSelector;
      }

      // Save Page Num
      if (options.activePage && this.pager) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pager.activePage;
      }

      // Filter Conditions
      if (options.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }

    },

    canUseLocalStorage: function () {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }
    },

    columnsFromString: function(columnStr) {
      if (!columnStr) {
        return;
      }

      var self = this,
        columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      }

      //Map back the missing functions/objects
      for (var i = 0; i < columns.length; i++) {
        var isHidden,
          orgCol = self.columnById(columns[i].id);

        if (orgCol) {
          orgCol = orgCol[0];
          isHidden = columns[i].hidden;

          $.extend(columns[i], orgCol);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          }
        }
      }

      return columns;
    },

    // Restore the columns from a saved list or local storage
    restoreColumns: function (cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      }

      //Done on load as apposed to passed in
      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = this.settings.columns;
        this.settings.columns = this.columnsFromString(lsCols);
        return;
      }

    },

    restoreUserSettings: function (settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      }

      // Restore The data thats passed in
      if (settings) {

        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize);
          this.pager.settings.pagesize = parseInt(settings.pagesize);
          this.pager.setActivePage(1, true);
        }

        if (settings.showPageSizeSelector) {
          this.settings.showPageSizeSelector = settings.showPageSizeSelector;
          this.pager.showPageSizeSelector(settings.showPageSizeSelector);
        }

        if (settings.activePage) {
          this.pager.setActivePage(parseInt(settings.activePage), true);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter);
        }
        return;
      }

      // Restore Column Width and Order
      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];
        this.originalColumns = this.settings.columns;

        if (savedColumns) {
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      }

      // Restore Row Height
      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      }

      // Restore Sort Order
      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];
        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      }

      // Restore Page Size
      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];
        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize);
        }
      }

      // Restore Show Page Size Selector
      if (options.showPageSizeSelector) {
        var savedShowPageSizeSelector = localStorage[this.uniqueId('usersettings-show-pagesize-selector')];
        savedShowPageSizeSelector = (savedShowPageSizeSelector + '').toLowerCase() === 'true';
        if (savedShowPageSizeSelector) {
          this.settings.showPageSizeSelector = savedShowPageSizeSelector;
        }
      }

      // Restore Active Page
      if (options.activePage) {
        var savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];
        if (savedActivePage) {
          this.savedActivePage = parseInt(savedActivePage);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];
        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }

    },

    // Reset Columns from the Menu Option
    resetColumns: function () {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
        localStorage[this.uniqueId('columns')] = '';
      }

      if (this.originalColumns) {
        this.updateColumns(this.originalColumns);
        this.originalColumns = this.columnsFromString(JSON.stringify(this.settings.columns));
      }
    },

    /**
    * Hide a column.
    * @param {String} id &nbsp;-&nbsp The id of the column to hide.
    */
    hideColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerRow.find('th').eq(idx).addClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').addClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).addClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).addClass('is-hidden');
      }

      this.element.trigger('columnchange', [{type: 'hidecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    //Show a hidden column
    showColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerRow.find('th').eq(idx).removeClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').removeClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).removeClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).removeClass('is-hidden');
      }

      this.element.trigger('columnchange', [{type: 'showcolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    // Export To Excel
    exportToExcel: function (fileName, worksheetName, customDs) {
      var self = this,
        template = ''+
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">'+
            '<head>'+
              '<!--[if gte mso 9]>'+
                '<xml>'+
                  '<x:ExcelWorkbook>'+
                    '<x:ExcelWorksheets>'+
                      '<x:ExcelWorksheet>'+
                        '<x:Name>{worksheet}</x:Name>'+
                        '<x:WorksheetOptions>'+
                          '<x:Panes></x:Panes>'+
                          '<x:DisplayGridlines></x:DisplayGridlines>'+
                        '</x:WorksheetOptions>'+
                      '</x:ExcelWorksheet>'+
                    '</x:ExcelWorksheets>'+
                  '</x:ExcelWorkbook>'+
                '</xml>'+
              '<![endif]-->'+
              '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>'+
            '</head>'+
            '<body>'+
              '<table border="1px solid #999999">{table}</table>'+
            '</body>'+
          '</html>',

        cleanExtra = function(table) {
          $('tr, th, td, div, span', table).each(function () {
            var el = this,
              elm = $(this);

            if (elm.is('.is-hidden')) {
              elm.remove();
              return;
            }

            $('.is-hidden, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper', el).remove();
            while(el.attributes.length > 0) {
              el.removeAttribute(el.attributes[0].name);
            }

            // White Hat Security Violation. Remove Excel formulas
            // Excel Formulas Start with =SOMETHING
            var text = elm.text();
            if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
              elm.text('\'' + elm.text());
            }
          });
          return table;
        },

        base64 = function(s) {
          if (window.btoa) {
            return 'data:application/vnd.ms-excel;base64,' + window.btoa(unescape(encodeURIComponent(s)));
          } else {
            return 'data:application/vnd.ms-excel;,' + unescape(encodeURIComponent(s));
          }
        },

        format = function(s, c) {
          return s.replace(/{(\w+)}/g, function(m, p) {
            return c[p];
          });
        },

        appendRows = function(dataset, table) {
          var tableHtml,
            body = table.find('tbody').empty();

          for (var i = 0; i < dataset.length; i++) {
            if (!dataset[i].isFiltered) {
              tableHtml += self.rowHtml(dataset[i], i, i);
            }
          }

          body.append(tableHtml);
          return table;
        };

      var table = self.table.clone();
      table = appendRows(customDs || this.settings.dataset, table);

      if (!table.find('thead').length) {
        self.headerRow.clone().insertBefore(table.find('tbody'));
      }

      table = cleanExtra(table);
      var ctx = { worksheet: (worksheetName || 'Worksheet'), table: table.html() };

      fileName = (fileName ||
        self.element.closest('.datagrid-container').attr('id') ||
        'datagrid') +'.xls';

      if (this.isIe) {
        if (this.isIe9) {
          var IEwindow = window.open();
          IEwindow.document.write('sep=,\r\n' + format(template, ctx));
          IEwindow.document.close();
          IEwindow.document.execCommand('SaveAs', true, fileName);
          IEwindow.close();
        }
        else if (window.navigator.msSaveBlob) {
          var blob = new Blob([format(template, ctx)], {
            type: 'application/csv;charset=utf-8;'
          });
          navigator.msSaveBlob(blob, fileName);
        }
      }
      else {
        var link = document.createElement('a');
        link.href = base64(format(template, ctx));
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    },

    //Open Column Personalization Dialog
    personalizeColumns: function () {
      var self = this,
        markup = '<div class="listview-search alternate-bg"><label class="audible" for="gridfilter">Search</label><input class="searchfield" placeholder="'+ Locale.translate('SearchColumnName') +'" name="searchfield" id="gridfilter"></div>';

        markup += '<div class="listview alternate-bg" id="search-listview"><ul>';

        for (var i = 0; i < this.settings.columns.length; i++) {
          var col = this.settings.columns[i],
            name = col.name;

          if (name) {
            name = name.replace('<br>', ' ').replace('<br/>', ' ').replace('<br />', ' ');
            markup += '<li><a href="#" target="_self" tabindex="-1"> <label class="inline"><input tabindex="-1" ' + (col.hideable ===false ? 'disabled' : '') + ' type="checkbox" class="checkbox" '+ (col.hidden ? '' : ' checked') +' data-column-id="'+ (col.id || i) +'"><span class="label-text">' + name + '</span></label></a></li>';
          }
        }
        markup += '</ul></div>';

        $('body').modal({
          title: Locale.translate('PersonalizeColumns'),
          content: markup,
          cssClass: 'full-width datagrid-columns-dialog',
          buttons: [{
              text: Locale.translate('Close'),
              click: function(e, modal) {
                modal.close();
                $('body').off('open.datagrid');
              }
            }]
        }).on('beforeopen.datagrid', function () {
          self.isColumnsChanged = false;
        }).on('open.datagrid', function (e, modal) {
          modal.element.find('.searchfield').searchfield({clearable: true});
          modal.element.find('.listview').listview({searchable: true, selectOnFocus: false})
            .on('selected', function (e, args) {
              var chk = args.elem.find('.checkbox'),
                  id = chk.attr('data-column-id'),
                  isChecked = chk.prop('checked');

              args.elem.removeClass('is-selected hide-selected-color');

              if (chk.is(':disabled')) {
                return;
              }
              self.isColumnsChanged = true;

              if (!isChecked) {
                self.showColumn(id);
                chk.prop('checked', true);
              } else {
                self.hideColumn(id);
                chk.prop('checked', false);
              }
            });

          modal.element.on('close.datagrid', function () {
            self.isColumnsChanged = false;
          });

      });
    },

    // Explicitly Set the Width of a column
    setColumnWidth: function(idOrNode, width, diff) {
      var self = this,
        percent = parseFloat(width),
        columnNode = idOrNode,
        columnSettings = this.columnById(typeof idOrNode === 'string' ? idOrNode : idOrNode.attr('data-column-id'));

      if (!percent) {
        return;
      }

      if (typeof idOrNode === 'string') {
        self.headerNodes().each(function () {
          var col = $(this);

          if (col.attr('data-column-id') === idOrNode) {
            columnNode = col;
          }

        });
      }

      //Handles min width on some browsers
      if ((columnSettings.minWidth && width > parseInt(columnSettings.minWidth))) {
        return;
      }

      //calculate percentage
      if (typeof width !=='number') {
        width = percent / 100 * self.element.width();
      }

      //Prevent Sub Pixel Thrashing
      if (Math.abs(width - columnSettings[0].width) < 2) {
        return;
      }

      // Save the column back in settings for later
      if (columnSettings[0]) {
        columnSettings[0].width = width;
      }

      var idx = columnNode.index();
      self.headerColGroup.find('col').eq(idx)[0].style.width = (width + 'px');

      if (self.settings.dataset.length > 0) {
        self.bodyColGroup.find('col').eq(idx)[0].style.width = (width + 'px');
      }

      if (self.tableWidth && diff) {
        self.headerTable.css('width', parseInt(self.tableWidth) + diff);
        self.table.css('width', parseInt(self.tableWidth) + diff);
      }

      this.element.trigger('columnchange', [{type: 'resizecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
      this.clearHeaderCache();
    },

    //Generate Resize Handles
    createResizeHandle: function() {
      var self = this;
      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');
      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.headerContainer.find('table').before(this.resizeHandle);

      var columnId, startingLeft, columnStartWidth, columnDef;

      this.resizeHandle.drag({axis: 'x', containment: 'parent'})
        .on('dragstart.datagrid', function () {
          if (!self.currentHeader) {
            return;
          }

          self.dragging = true;

          columnId = self.currentHeader.attr('data-column-id');
          columnDef = self.columnById(columnId)[0];

          startingLeft = self.currentHeader.position().left + self.table.scrollLeft() - 10;
          self.tableWidth = self.table[0].offsetWidth;
          columnStartWidth = self.currentHeader[0].offsetWidth;

        })
        .on('drag.datagrid', function (e, ui) {
          if (!self.currentHeader) {
            return;
          }

          var width = (ui.left - startingLeft -1),
            minWidth = columnDef.minWidth || 12,
            maxWidth = columnDef.maxWidth || 1000;

          if (width < minWidth || width> maxWidth) {
            self.resizeHandle.css('cursor', 'inherit');
            return;
          }

          width = Math.round(width);
          self.setColumnWidth(self.currentHeader, width, width - columnStartWidth);
        })
        .on('dragend.datagrid', function () {
          self.dragging = false;
        });
    },

    //Show Summary and any other count info
    displayCounts: function(totals) {
      var self = this,
        count = self.tableBody.find('tr:visible').length,
        isClientSide = self.settings.paging && !(self.settings.source);

      if (isClientSide || (!totals && !self.settings.paging)) {
        count = self.recordCount;
      }

      //Update Selected
      if (self.contextualToolbar && self.contextualToolbar.length) {
        self.contextualToolbar.find('.selection-count').text(self._selectedRows.length + ' ' + Locale.translate('Selected'));
      }

      if (self.settings.source && !totals) {
        return;
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      var countText = '(' + count + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          countText = self.settings.resultsText(self, count);
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        self.toolbar.find('.datagrid-result-count').html(countText);
        self.toolbar.attr('aria-label',  self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count);
      }
      self.element.closest('.modal').find('.datagrid-result-count').html(countText);

    },

    //Trigger event on parent and compose the args
    triggerRowEvent: function (eventName, e, stopPropagation) {
      var self = this,
          cell = $(e.target).closest('td').index(),
          row = $(e.target).closest('tr').index(),
          item = self.settings.dataset[row];

      if ($(e.target).is('a')) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      self.element.trigger(eventName, [{row: row, cell: cell, item: item, originalEvent: e}]);
      return false;
    },

    //Returns a cell node
    cellNode: function (row, cell, includeGroups) {
      var cells,
        rowNode = this.tableBody.find('tr:not(.datagrid-expandable-row)[aria-rowindex="'+ (row + 1) +'"]');

      if (row instanceof jQuery) {
        rowNode = row;
      }

      if (includeGroups && this.settings.groupable) {
        rowNode = this.tableBody.prevAll('.datagrid-rowgroup-header').eq(row);
        if (rowNode) {
          rowNode = this.tableBody.find('.datagrid-rowgroup-header').eq(row);
        }
      }

      if (cell === -1) {
        return $();
      }

      cells = rowNode.find('td');
      return cells.eq(cell >= cells.length ? cells.length-1 : cell);
    },

    scrollLeft: 0,
    scrollTop: 0,
    handleScroll: function() {
      var left = this.contentContainer[0].scrollLeft;

      if (left !== this.scrollLeft && this.headerContainer) {
        this.scrollLeft = left;
        this.headerContainer[0].scrollLeft = this.scrollLeft;
      }

    },

    handleResize: function () {
      var self = this;
      self.clearHeaderCache();
      self.renderRows();
      self.renderHeader();
    },

    // Attach All relevant events
    handleEvents: function() {
      var self = this,
        isMultiple = this.settings.selectable === 'multiple',
        isMixed = this.settings.selectable === 'mixed';

      // Set Focus on rows
      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.table
        .on('focus.datagrid', 'tbody > tr', function () {
            $(this).addClass('is-active-row');
        })
        .on('blur.datagrid', 'tbody > tr', function () {
          $('tbody > tr', self.table).removeClass('is-active-row');
        });
      }

      //Sync Header and Body During scrolling
      self.contentContainer
        .on('scroll.table',function () {
          self.handleScroll();
        });

      if (this.settings.virtualized) {
        var oldScroll = 0, oldHeight = 0;

        self.contentContainer
          .on('scroll.vtable', Soho.utils.debounce(function () {

            var scrollTop = this.scrollTop,
              buffer = 25,
              hitBottom = scrollTop > (self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer),
              hitTop = scrollTop < (self.virtualRange.top + buffer);

            if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
              oldScroll = this.scrollTop;
              self.renderRows();
              return;
            }
          }, 0));

        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.renderRows();
          }

        });
      }

      // Handle Resize - Re do the columns
      if (self.settings.redrawOnResize) {
        var oldWidth = 0;

        $('body').on('resize.datagrid', function () {
          var width = this.offsetWidth;
          if (width !== oldWidth) {
            oldWidth = width;
            self.handleResize();
          }
        });
      }

      //Handle Sorting
      this.element
        .off('click.datagrid')
        .on('click.datagrid', 'th.is-sortable', function (e) {
          if ($(e.target).parent().is('.datagrid-filter-wrapper')) {
            return;
          }

          self.setSortColumn($(this).attr('data-column-id'));
        });

      //Prevent redirects
      this.table
        .off('mouseup.datagrid touchstart.datagrid')
        .on('mouseup.datagrid touchstart.datagrid', 'a', function (e) {
        e.preventDefault();
      });

      //Handle Row Clicking
      var tbody = this.table.find('tbody');
      tbody.off('click.datagrid').on('click.datagrid', 'td', function (e) {
        var rowNode, dataRowIdx,
          target = $(e.target);

        if (target.closest('.datagrid-row-detail').length === 1) {
          return;
        }

        self.triggerRowEvent('click', e, true);
        self.setActiveCell(target.closest('td'));

        //Dont Expand rows or make cell editable when clicking expand button
        if (target.is('.datagrid-expand-btn') || (target.is('.datagrid-cell-wrapper') && target.find('.datagrid-expand-btn').length)) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.dataRowIndex(rowNode);

          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false;
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') ||
                                  target.find('.datagrid-selection-checkbox').length === 1,
          canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (isMixed) {
          canSelect = isSelectionCheckbox;

          //Then Activate
          if (!canSelect) {
            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && isMultiple && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').index()]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        }

        self.lastClicked = target;
        var isEditable = self.makeCellEditable(self.activeCell.dataRow, self.activeCell.cell, e);

        //Handle Cell Click Event
        var elem = $(this).closest('td'),
          cell = elem.parent().children(':visible').index(elem),
          col = self.columnSettings(cell, true);

        if (col.click && typeof col.click === 'function' && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {

          var rowElem = $(this).closest('tr'),
            rowIdx = self.dataRowIndex(rowElem),
            item = self.settings.treeGrid ?
              self.settings.treeDepth[rowIdx].node :
              self.settings.dataset[self.pager && self.settings.source ? rowElem.index() : rowIdx];

          if (elem.hasClass('is-focusable')) {
            if (!target.is(self.settings.buttonSelector)) {
              if (!target.parent('button').is(self.settings.buttonSelector)) {
                return;
              }
            }
          }

          if (!elem.hasClass('is-cell-readonly') && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {
            col.click(e, [{row: rowIdx, cell: self.activeCell.cell, item: item, originalEvent: e}]);
          }
        }

        //Handle Context Menu on Some
        if (col.menuId) {
          var btn = $(this).find('button');
          btn.popupmenu({attachToBody: true, autoFocus: false, mouseFocus: true,  menuId: col.menuId, trigger: 'immediate', offset: { y: 5 }});

          if (col.selected) {
            btn.on('selected.datagrid', col.selected);
          }
        }

        // Apply Quick Edit Mode
        if (isEditable) {
          setTimeout(function() {
            if ($('textarea, input', elem).length &&
                (!$('.dropdown,' +
                '[type=image],' +
                '[type=button],' +
                '[type=submit],' +
                '[type=reset],' +
                '[type=checkbox],' +
                '[type=radio]', elem).length)) {
              self.quickEditMode = true;
            }
          }, 0);
        }

      });

      tbody.off('dblclick.datagrid').on('dblclick.datagrid', 'tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });

      //Handle Context Menu Option
      tbody.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tr', function (e) {

        if (!self.isSubscribedTo(e, 'contextmenu')) {
          return;
        }

        self.triggerRowEvent('contextmenu', e, (self.settings.menuId ? true : false));
        e.preventDefault();

        if (self.settings.menuId) {
          $(e.currentTarget).popupmenu({menuId: self.settings.menuId, eventObj: e, trigger: 'immediate'});
        }

        return false;
      });

      // Move the drag handle to the end or start of the column
      this.headerRow
        .off('mousemove.datagrid')
        .on('mousemove.datagrid', 'th', function (e) {
          if (self.dragging) {
            return;
          }

          self.currentHeader = $(e.target).closest('th');

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          var headerDetail = self.currentHeader.closest('.header-detail'),
            extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0,
            leftEdge = parseInt(self.currentHeader.position().left) - (extraMargin || 0) + self.element.scrollLeft(),
            rightEdge = leftEdge + self.currentHeader.outerWidth(),
            alignToLeft = (e.pageX - leftEdge > rightEdge - e.pageX),
            leftPos = 0;

          //TODO: Test Touch support - may need handles on each column
          leftPos = (alignToLeft ? (rightEdge - 6): (leftEdge - 6));

          //Ignore First Column
          if (self.currentHeader.index() === 0 && !alignToLeft) {
            leftPos = '-999';
          }

          if (!alignToLeft) {
            self.currentHeader = self.currentHeader.prevAll().not('.is-hidden').first();
          }

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          self.createResizeHandle();
          self.resizeHandle[0].style.left = leftPos +'px';
          self.resizeHandle[0].style.cursor = '';
        });

      // Handle Clicking Header Checkbox
      this
        .headerRow
        .off('click.datagrid')
        .on('click.datagrid', 'th .datagrid-checkbox', function () {
          var checkbox = $(this);

          if (!checkbox.hasClass('is-checked')) {
            checkbox.addClass('is-checked').attr('aria-checked', 'true');

            self.selectAllRows();

          } else {
            checkbox.removeClass('is-checked').attr('aria-checked', 'true');
            self.unSelectAllRows();
          }
        });

      // Implement Editing Auto Commit Functionality
      tbody.off('focusout.datagrid').on('focusout.datagrid', 'td input, td textarea, div.dropdown', function (e) {

        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function() {
            if (!$('.lookup-modal.is-visible, #timepicker-popup, #calendar-popup').length &&
                !!self.editor && self.editor.input.is(target)) {

              if ($('*:focus').is('.spinbox')) {
                return;
              }
              self.commitCellEdit(self.editor.input);
            }

          }, 150);

          return;
        }

        //Popups are open
        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.lastClicked = null;
          self.commitCellEdit(self.editor.input);
        }

      });

    },

    //Check if the event is subscribed to
    isSubscribedTo: function (e, eventName) {
      var self = this;

      for (var event in $._data(self.element[0]).events) {
        if (event === eventName) {
          return true;
        }
      }

      return false;
    },

    // Adjust to set a changed row height
    refreshSelectedRowHeight: function () {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)'),
        short = toolbar.find('[data-option="row-short"]'),
        med = toolbar.find('[data-option="row-medium"]'),
        normal = toolbar.find('[data-option="row-normal"]');

        if (this.settings.rowHeight === 'short') {
          short.parent().addClass('is-checked');
          med.parent().removeClass('is-checked');
          normal.parent().removeClass('is-checked');
        }

        if (this.settings.rowHeight === 'medium') {
          short.parent().removeClass('is-checked');
          med.parent().addClass('is-checked');
          normal.parent().removeClass('is-checked');
        }

        if (this.settings.rowHeight === 'normal') {
          short.parent().removeClass('is-checked');
          med.parent().removeClass('is-checked');
          normal.parent().addClass('is-checked');
        }

    },

     appendToolbar: function () {
      var toolbar, title = '', more, self = this;

      if (!settings.toolbar) {
        return;
      }

      //Allow menu to be added manually
      if (this.element.parent().find('.toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (settings.toolbar.title) {
          title = $('<div class="title">' + settings.toolbar.title + '  </div>');
        }

        if (!title) {
          title = toolbar.find('.title');
        }
        toolbar.append(title);

        if (settings.toolbar.results) {
          //Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (settings.toolbar.keywordFilter) {
          var labelMarkup = $('<label class="audible" for="gridfilter">'+ Locale.translate('Keyword') +'</label>'),
            searchfieldMarkup = $('<input class="searchfield" name="searchfield" placeholder="' + Locale.translate('Keyword') + '" id="gridfilter">');

          buttonSet.append(labelMarkup);

          if (!settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ collapsible: false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (settings.toolbar.dateFilter) {
          buttonSet.append('<button class="btn" type="button">' + $.createIcon({ icon: 'calendar' }) + '<span>' + Locale.translate('Date') + '</span></button>');
        }

        if (settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append('<button class="btn-actions" title="More" type="button">' + $.createIcon({ icon: 'more' }) + '<span class="audible">Grid Features</span></button>');
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (settings.toolbar.personalize) {
          menu.append('<li><a href="#" data-option="personalize-columns">' + Locale.translate('PersonalizeColumns') + '</a></li>');
        }

        if (settings.toolbar.resetLayout) {
          menu.append('<li><a href="#" data-option="reset-layout">' + Locale.translate('ResetDefault') + '</a></li>');
        }

        if (settings.toolbar.exportToExcel) {
          menu.append('<li><a href="#" data-option="export-to-excel">' + Locale.translate('ExportToExcel') + '</a></li>');
        }

        if (settings.toolbar.advancedFilter) {
          menu.append('<li><a href="#">' + Locale.translate('AdvancedFilter') + '</a></li>');
        }

        if (settings.toolbar.views) {
          menu.append('<li><a href="#">' + Locale.translate('SaveCurrentView') + '</a></li> ' +
            '<li class="separator"></li> ' +
            '<li class="heading">' + Locale.translate('SavedViews') + '</li>' +
            '<li><a href="#">View One</a></li>');
        }

        if (settings.toolbar.rowHeight) {
          menu.append('<li class="separator single-selectable-section"></li>' +
            '<li class="heading">' + Locale.translate('RowHeight') + '</li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'short' ? ' is-checked' : '') + '"><a data-option="row-short">' + Locale.translate('Short') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'medium' ? ' is-checked' : '') + '"><a data-option="row-medium">' + Locale.translate('Medium') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'normal' ? ' is-checked' : '') + '"><a data-option="row-normal">' + Locale.translate('Normal') + '</a></li>');
        }

        if (settings.toolbar.filterRow) {
          menu.append('<li class="separator"></li>' +
            '<li class="heading">' + Locale.translate('Filter') + '</li>' +
            '<li class="' + (settings.filterable ? 'is-checked ' : '') + 'is-toggleable"><a data-option="show-filter-row">' + Locale.translate('ShowFilterRow') + '</a></li>' +
            '<li class="is-indented"><a data-option="run-filter">' + Locale.translate('RunFilter') + '</a></li>' +
            '<li class="is-indented"><a data-option="clear-filter">' + Locale.translate('ClearFilter') + '</a></li>');
        }

        if (settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      toolbar.find('.btn-actions').popupmenu().on('selected', function(e, args) {
        var action = args.attr('data-option');
        if (action === 'row-short' || action === 'row-medium' || action === 'row-normal') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          self.exportToExcel();
        }

        //Filter actions
        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }
        if (action === 'run-filter') {
          self.applyFilter();
        }
        if (action === 'clear-filter') {
          self.clearFilter();
        }
      });

      if (settings.initializeToolbar && !toolbar.data('toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      if (settings.toolbar && settings.toolbar.keywordFilter) {

        var thisSearch = toolbar.find('.searchfield'),
          xIcon = thisSearch.parent().find('.close.icon');

        thisSearch.off('keypress.datagrid').on('keypress.datagrid', function (e) {
          if (e.keyCode === 13 || e.type==='change') {
            e.preventDefault();
            self.keywordSearch(thisSearch.val());
          }
        });

        xIcon.off('click.datagrid').on('click.datagrid', function () {
          self.keywordSearch(thisSearch.val());
        });

      }

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },

    //Get or Set the Row Height
    rowHeight: function(height) {
      if (height) {
        settings.rowHeight = height;
      }

      this.element.add(this.table)
        .removeClass('short-rowheight medium-rowheight normal-rowheight')
        .addClass(settings.rowHeight + '-rowheight');

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = (height === 'normal' ? 40 : (height === 'medium' ? 30 : 25));
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      return settings.rowHeight;
    },

    //Search a Term across all columns
    keywordSearch: function(term) {
      this.tableBody.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];

        this.tableBody.find('.datagrid-expandable-row').each(function () {
          var row = $(this);
          //Collapse All rows
          row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
          row.prev().find('.plus-minus').removeClass('active');
          row.removeClass('is-expanded').css('display', '');
          row.find('.datagrid-row-detail').css('height', '');
        });

      this.tableBody.find('.search-mode').each(function () {
        var cell = $(this),
          text = cell.text();
        cell.text(text.replace('<i>','').replace('</i>',''));
      });

      term = (term || '').toLowerCase();
      this.filterExpr.push({column: 'all', operator: 'contains', value: term, keywordSearch: true});

      this.filterKeywordSearch();
      this.renderRows();
      this.resetPager('searched');
      this.setSearchActivePage();

      if (!this.settings.paging) {
        this.highlightSearchRows(term);
      }
    },

    // Set search active page
    setSearchActivePage: function () {
      if (this.pager && this.filterExpr.length === 1) {
        if (this.filterExpr[0].value !== '') {
          if (this.pager.searchActivePage === undefined) {
            this.pager.searchActivePage = this.pager.activePage;
          }
          this.pager.setActivePage(1, true);
        }
        else if (this.filterExpr[0].value === '' && this.pager.searchActivePage > -1) {
          this.pager.setActivePage(this.pager.searchActivePage, true);
          delete this.pager.searchActivePage;
        }
      }
      else if (this.pager && this.pager.searchActivePage > -1) {
        this.pager.setActivePage(this.pager.searchActivePage, true);
        delete this.pager.searchActivePage;
      }
    },

    // Filter to keyword search
    filterKeywordSearch: function () {
      var self = this,
        dataset, isFiltered, i, len,
        filterExpr = self.filterExpr,

        checkRow = function (data, row) {
          var isMatch = false,

            checkColumn = function (columnId) {
              var column = self.columnById(columnId)[0],
                fieldValue = self.fieldValue(data, column.field),
                value, cell = self.settings.columns.indexOf(column);

              // Use the formatted value (what the user sees in the cells) since it's a more reliable match
              value = self.formatValue(column.formatter, row, cell, fieldValue, column, data, self).toLowerCase();

              // Strip any html markup that might be in the formatted value
              value = value.replace(/(<([^>]+)>)|(&lt;([^>]+)&gt;)/ig, '');

              return value.indexOf(filterExpr.value) > -1;
            };

          // Check in all visible columns
          if (filterExpr.column === 'all') {
            self.headerRow.find('th:visible').each(function () {
              var th = $(this),
                columnId = th.attr('data-column-id');

              isMatch = checkColumn(columnId);
              if (isMatch) {
                return false;
              }
            });
          }
          // Check in only one column, given by columnId
          else if (filterExpr.columnId) {
            isMatch = checkColumn(filterExpr.columnId);
          }
          return isMatch;
        };

      // Make sure not more/less than one filter expr
      if (!filterExpr || filterExpr.length !== 1) {
        return;
      } else {
        filterExpr = filterExpr[0];
      }

      // Check in dataset
      if (self.settings.treeGrid) {
        dataset = self.settings.treeDepth;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i].node, i);
          dataset[i].node.isFiltered = isFiltered;
        }
      }
      else {
        dataset = self.settings.dataset;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i], i);
          dataset[i].isFiltered = isFiltered;
        }
      }
    },

    highlightSearchRows: function (term) {
      // Move across all visible cells and rows, highlighting
      this.tableBody.find('tr').each(function () {
        var found = false,
          row = $(this);

          row.find('td').each(function () {
            var cell =  $(this),
              cellText = cell.text().toLowerCase();

            if (cellText.indexOf(term) > -1) {
              found = true;
              cell.find('*').each(function () {
                if (this.innerHTML === this.textContent) {
                  var contents = this.textContent,
                    node = $(this),
                    exp = new RegExp('(' + term + ')', 'i');

                  node.addClass('search-mode').html(contents.replace(exp, '<i>$1</i>'));
                }
              });
            }

          });

          // Hide non matching rows
          if (!found) {
            row.addClass('is-filtered').hide();
          } else if (found && row.is('.datagrid-expandable-row')) {
            row.prev().show();
            row.prev().find('.datagrid-expand-btn').addClass('is-expanded');
            row.prev().find('.plus-minus').addClass('active');
            row.addClass('is-expanded').css('display', 'table-row');
            row.find('.datagrid-row-detail').css('height', 'auto');
          }

      });

    },

    //Get or Set Selected Rows
    _selectedRows: [],

    selectAllRows: function () {
      var rows = [],
        self = this,
        dataset = this.settings.treeGrid ?
          this.settings.treeDepth : this.settings.dataset;

      for (var i = 0, l = dataset.length; i < l; i++) {
        if (this.filterRowRendered) {
          if (!dataset[i].isFiltered) {
            rows.push(self.settings.paging && self.settings.source ? i  : i);
          }
        } else {
          rows.push(i);
        }
      }

      this.dontSyncUi = true;
      this.selectedRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows , 'selectall']);
    },

    unSelectAllRows: function () {
      this.dontSyncUi = true;
      this.selectedRows([], true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows, 'deselectall']);
    },

    //Check if exists in array of objects with callback
    inArrayObjects: function (arr, fn) {
      for(var i = 0, l = arr.length; i < l; i++) {
        if (fn(arr[i])) {
          return i;
        }
      }
      return -1;
    },

    //Check if node index is exists in selected nodes
    isNodeSelected: function (index) {
      var isSelection = this.inArrayObjects(this._selectedRows, function (v) {
        return v.idx === index;
      });
      return isSelection !== -1;
    },

    //Toggle selection on a single row
    selectRow: function (idx, selectAll) {
      var rowNode, dataRowIndex,
        self = this,
        checkbox = null,
        s = this.settings;

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      rowNode = this.visualRowNode(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode) {
        return;
      }

      if (s.selectable === 'single' && this._selectedRows.length > 0) {
        this.unselectRow(this._selectedRows[0].idx);
      }

      if (!rowNode.hasClass('is-selected')) {
        var rowData,
          // Select it
          selectNode = function(elem, index, data) {
            // do not add if already exists in selected
            if (self.isNodeSelected(index)) {
              return;
            }
            checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
            elem.addClass('is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true')
              .find('td').attr('aria-selected', 'true');
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');
            self._selectedRows.push({idx: index, data: data, elem: elem});
          };

        if (s.treeGrid) {
          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
              var elem = $(this),
                index = elem.attr('aria-rowindex') -1,
                data = s.treeDepth[index].node;
              selectNode(elem, index, data);
            });
          }
          // Single element selection
          else {
            rowData = s.treeDepth[self.pager && s.source ? rowNode.index() : dataRowIndex].node;
            selectNode(rowNode, dataRowIndex, rowData);
          }
          self.setNodeStatus(rowNode);
        }
        else {
          dataRowIndex = self.pager && s.source ? rowNode.index() : dataRowIndex;
          rowData = s.dataset[dataRowIndex];
          selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx;// Rememeber index to use shift key
        }
      }

      this.syncSelectedUI();

      if (!selectAll) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }
    },

    dontSyncUi: false,

    // Select rows between indexes
    selectRowsBetweenIndexes: function(indexes) {
      indexes.sort(function(a, b) { return a-b; });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }
    },

    //Set ui elements based on selected rows
    syncSelectedUI: function () {
      var s = this.settings,
        dataset = s.treeGrid ? s.treeDepth : s.dataset,
        headerCheckbox = this.headerRow.find('.datagrid-checkbox'),
        rows = dataset;

      if (this.filterRowRendered) {
        rows = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (!dataset[i].isFiltered) {
            rows.push(i);
          }
        }
      }

      //Sync the header checkbox
      if (this._selectedRows.length > 0) {
        headerCheckbox.addClass('is-checked is-partial');
      }

      if (this._selectedRows.length === rows.length) {
        headerCheckbox.addClass('is-checked').removeClass('is-partial');
      }

      if (this._selectedRows.length === 0) {
        headerCheckbox.removeClass('is-checked is-partial');
      }

      //Open or Close the Contextual Toolbar.
      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      if (this._selectedRows.length === 0) {
        this.contextualToolbar.animateClosed();
      }

      if (this._selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function() {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }

    },

    // activate a row when in mixed selection mode
    activateRow: function(idx) {
      if (this.activatedRow().length === 0 || this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },

    // deactivate the currently activated row
    deactivateRow: function() {
      this.toggleRowActivation(this.activatedRow()[0].row);
    },

    // Gets the currently activated row
    activatedRow: function() {
      var activatedRow = this.tableBody.find('tr.is-rowactivated');

      if (activatedRow.length) {
        var rowIndex = this.dataRowIndex(activatedRow);
        return [{ row: rowIndex, item: this.settings.dataset[rowIndex], elem: activatedRow }];
      } else {
        return [{ row: -1, item: undefined, elem: activatedRow }];
      }
    },

    toggleRowActivation: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        rowIndex = (typeof idx === 'number' ? idx : ((this.pager && this.settings.source) ? this.actualArrayIndex(row) : this.dataRowIndex(row))),
        isActivated = row.hasClass('is-rowactivated');

      if (isActivated) {
        if (!this.settings.disableRowDeactivation) {
          row.removeClass('is-rowactivated');
          this.element.triggerHandler('rowdeactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
        }
      } else {
        //Deselect old row
        var oldActivated = this.tableBody.find('tr.is-rowactivated');
        if (oldActivated.length) {
          oldActivated.removeClass('is-rowactivated');

          var oldIdx = this.dataRowIndex(oldActivated);
          this.element.triggerHandler('rowdeactivated', [{row: oldIdx, item: this.settings.dataset[oldIdx]}]);
        }
        row.addClass('is-rowactivated');
        this.element.triggerHandler('rowactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
      }

    },

    toggleRowSelection: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        isSingle = this.settings.selectable === 'single',
        rowIndex = (typeof idx === 'number' ? idx : this.settings.treeGrid ? this.dataRowIndex(row) : this.actualArrayIndex(row));

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (isSingle && row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
        this._selectedRows = [];
        this.displayCounts();
        return this._selectedRows;
      }

      if (row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();

      return this._selectedRows;
    },

    unselectRow: function (idx, nosync, selectAll) {
      var self = this,
        s = self.settings,
        rowNode = self.visualRowNode(idx),
        checkbox = null,
        selIdx;

      if (!rowNode || idx === undefined) {
        return;
      }

      selIdx = undefined;
      for (var i = 0; i < self._selectedRows.length; i++) {
        if (self._selectedRows[i].idx === idx) {
          selIdx = idx;
        }
      }

      // Unselect it
      var unselectNode = function(elem, index) {
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass('is-selected hide-selected-color').removeAttr('aria-selected')
          .find('td').removeAttr('aria-selected');
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked').attr('aria-checked', 'false');

        var selIdx;
        for (var i = 0; i < self._selectedRows.length; i++) {
          if (self._selectedRows[i].idx === index) {
            selIdx = i;
          }
        }
        if (selIdx !== undefined) {
          self._selectedRows.splice(selIdx, 1);
        }
      };

      if (s.treeGrid) {
        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
            var elem = $(this),
              index = elem.attr('aria-rowindex') -1;
            unselectNode(elem, index);
          });
        }
        // Single element unselection
        else {
          unselectNode(rowNode, selIdx);
        }
        self.setNodeStatus(rowNode);
      }
      else {
        unselectNode(rowNode, selIdx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!selectAll) {
        self.element.triggerHandler('selected', [self._selectedRows, 'deselect']);
      }
    },

    setNodeStatus: function(node) {
      var self = this,
        isMultiselect = self.settings.selectable === 'multiple',
        checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
        nodes;

      // Not multiselect
      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .addClass('is-checked').attr('aria-checked', 'true');
        }
        return;
      }

      var setStatus = function (nodes, isFirstSkipped) {
        nodes.each(function() {
          var node = $(this),
            checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
            status = self.getSelectedStatus(node, isFirstSkipped);

          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          }
          else if (status) {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      };

      // Multiselect
      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent');
      setStatus(nodes);

      nodes = node;
      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]'))
        .add(node.prevAll('[aria-level="1"]:first'));
      }
      nodes = nodes.filter('.datagrid-tree-parent');
      setStatus(nodes);
    },

    getSelectedStatus: function(node) {
      var status,
        total = 0,
        selected = 0,
        unselected = 0;

      node.add(node.nextUntil('[aria-level="1"]')).each(function() {
        total++;
        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });

      status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
      return status;
    },

    //Set the selected rows by passing the row index or an array of row indexes
    selectedRows: function (row, nosync, selectAll) {
      var idx = -1,
          isSingle = this.settings.selectable === 'single',
          isMultiple = this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed',
          dataset = this.settings.treeGrid ?
            this.settings.treeDepth : this.settings.dataset;

      if (!row) {
        return this._selectedRows;
      }

      if (row.length === 0 && this._selectedRows.length === 0) {
        return;
      }

      if (isSingle) {
        //Unselect
        if (this._selectedRows[0]) {
          this.unselectRow(this._selectedRows[0].idx, nosync, selectAll);
        }

        //Select - may be passed array or int
        idx = ((Object.prototype.toString.call(row) === '[object Array]' ) ? row[0] : row.index());
        this.selectRow(idx, selectAll);
      }

      if (isMultiple) {
        if (Object.prototype.toString.call(row) === '[object Array]' ) {
          for (var i = 0; i < row.length; i++) {
            this.selectRow(row[i], selectAll);
          }

          if (row.length === 0) {
            for (var j=0, l=dataset.length; j < l; j++) {
              this.unselectRow(j, nosync, selectAll);
            }
            this._selectedRows = [];
          }

        } else {
          this.selectRow(row.index(), selectAll);
        }
      }

      this.displayCounts();

      return this._selectedRows;
    },

    //Set the row status
    rowStatus: function(idx, status, tooltip) {
      var rowStatus;

      if (!status) {
        delete this.settings.dataset[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (!this.settings.dataset[idx]) {
        return;
      }

      this.settings.dataset[idx].rowStatus = {};
      rowStatus = this.settings.dataset[idx].rowStatus;

      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);

      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;

      this.updateRow(idx);
    },

    //Get the column object by id
    columnById: function(id) {
      return $.grep(this.settings.columns, function(e) { return e.id === id; });
    },

    //Get the column index from the col's id
    columnIdxById: function(id) {
      var cols = this.settings.columns,
        idx = -1;

      for (var i = 0; i < cols.length; i++) {
       if (cols[i].id === id) {
        idx = i;
       }
      }
      return idx;
    },

    // Current Active Cell
    activeCell: {node: null, cell: null, row: null},

    // Handle all keyboard behavior
    handleKeys: function () {
      var self = this,
        isMultiple = self.settings.selectable === 'multiple',
        checkbox = $('th .datagrid-checkbox', self.headerRow);

      // Handle header navigation
      self.headerTable.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          th = $(this),
          index = th.siblings(':visible').addBack().index(th),
          last = self.visibleColumns().length -1,
          triggerEl, move;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        }

        // Enter or Space
        if (key === 13 || key === 32) {
          triggerEl = (isMultiple && index === 0) ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();

          if (key === 32) { // Prevent scrolling with space
            e.preventDefault();
          }
        }

        //Press Home, End, Left and Right arrow to move to first, last, previous or next
        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index;

          //Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last
          if (/35|36/i.test(key) || ((e.ctrlKey || e.metaKey) && /37|39/i.test(key))) {
            if (Locale.isRTL()) {
              move = (key === 36 || ((e.ctrlKey || e.metaKey) && key === 37)) ? last : 0;
            } else {
              move = (key === 35 || ((e.ctrlKey || e.metaKey) && key === 39)) ? last : 0;
            }
          }

          // Left and Right arrow
          else {
            if (Locale.isRTL()) {
              move = key === 39 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            } else {
              move = key === 37 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            }
          }
          // Update active cell
          self.activeCell.cell = move;

          // Making move
          th.removeAttr('tabindex').removeClass('is-active');
          $('th:not(.is-hidden)', this.header).eq(move).attr('tabindex', '0').addClass('is-active').focus();
          e.preventDefault();
        }

        // Down arrow
        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell, true).attr('tabindex', '0').focus();
          e.preventDefault();
        }

      });

      //Handle Editing / Keyboard
      self.table.on('keydown.datagrid', 'td, input', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false;

        // F2 - toggles actionableMode "true" and "false"
        if (key === 113) {
          self.settings.actionableMode = self.settings.actionableMode ? false : true;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });

      //Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      //Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      //Press Alt+PageUp or Alt+PageDown to open the first or last page and set focus to the first row.

      //Handle rest of the keyboard
      self.table.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false,
          isRTL = Locale.isRTL(),
          node = self.activeCell.node,
          rowNode = $(this).parent(),
          prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          row = self.activeCell.row,
          cell = self.activeCell.cell,
          col = self.columnSettings(cell),
          isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer'),
          item = self.settings.dataset[self.dataRowIndex(node)],
          visibleRows = self.tableBody.find('tr:visible'),
          getVisibleRows = function(index) {
            var row = visibleRows.filter('[aria-rowindex="'+ (index + 1) +'"]');
            if (row.is('.datagrid-rowgroup-header')) {
              return row.index();
            }
            return self.dataRowIndex(row);
          },
          getGroupCell = function(currentCell, lastCell, prev) {
            var n = self.activeCell.groupNode || node;
            var nextCell = currentCell + (prev ? -1 : +1);

            if (nextCell > lastCell) {
              nextCell = prev ?
                n.prevAll(':visible').last() : n.nextAll(':visible').last();
            } else {
              nextCell = prev ?
                n.prevAll(':visible').first() : n.nextAll(':visible').first();
            }
            return nextCell;
          },
          getNextVisibleCell = function(currentCell, lastCell, prev) {
            if (isGroupRow) {
              return getGroupCell(currentCell, lastCell, prev);
            }
            var nextCell = currentCell + (prev ? -1 : +1);
            if (nextCell > lastCell) {
             return lastCell;
            }
            while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
              nextCell = prev ? nextCell-1 : nextCell+1;
            }
            return nextCell;
          },
          isSelectionCheckbox = !!($('.datagrid-selection-checkbox', node).length),
          lastRow, lastCell;

        lastCell = self.settings.columns.length-1;
        lastRow = visibleRows.last();

        //Tab, Left and Right arrow keys.
        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            //[Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = ((key === 37 && !isRTL) || (key === 39 && isRTL)) ? 0 : lastCell;
            self.setActiveCell(row, cell);
          }
          //Tab, Shift-tab, Left and Right arrow keys to navigate by cell.
          else if (!self.quickEditMode || (key === 9)) {
            if ((!isRTL && (key === 37 || key === 9 && e.shiftKey)) ||
                (isRTL && (key === 39 || key === 9))) {
              cell = getNextVisibleCell(cell, lastCell, true);
            } else {
              cell = getNextVisibleCell(cell, lastCell);
            }
            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }
            self.quickEditMode = false;
            handled = true;
          }
        }

        //Up arrow key
        if (key === 38 && !self.quickEditMode) {
          //Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(getVisibleRows(0), cell);
            handled = true;
          } else { //Up arrow key to navigate by row.

            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.headerRow.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }
            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        }

        //Down arrow key
        if (key === 40 && !self.quickEditMode) {
          //Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey|| e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else { //Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        }

        //Press Control+Spacebar to announce the current row when using a screen reader.
        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');

          row.children().each(function () {
            var cell = $(this);
            //Read Header
            //string += $('#' + cell.attr('aria-describedby')).text() + ' ' + cell.text() + ' ';
            string += cell.text() + ' ';
          });

          $('body').toast({title: '', audibleOnly: true, message: string});
          handled = true;
        }

        //Press Home or End to move to the first or last cell on the current row.
        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        }

        //Home to Move to the end of the current row
        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        }

        //End to Move to last row of current cell
        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        }

        //End to Move to first row of current cell
        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        }

        // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.
        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if ($(e.target).closest('.datagrid-row-detail').length === 1) {
            return;
          }
          e.preventDefault();

          // Toggle datagrid-expand with Space press
          var btn = $(e.target).find('.datagrid-expand-btn, .datagrid-drilldown');
          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (isMultiple && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.index()]);
          } else {
            self.toggleRowSelection(row);
          }

        }

        // For Editable mode - press Enter or Space to edit or toggle a cell, or click to activate using a mouse.
        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // if column have click function to fire [ie. action button]
        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{row: row, cell: cell, item: item, originalEvent: e}]);
          }
        }

        if (self.settings.editable && key === 13) {
          //Allow shift to add a new line
          if ($(e.target).is('textarea') && e.shiftKey) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit(self.editor.input);
            self.setNextActiveCell(e);
          }
          else {
            self.makeCellEditable(row, cell, e);
            if (self.isContainTextfield(node) && self.notContainTextfield(node)) {
              self.quickEditMode = true;
            }
          }
          handled = true;
        }

        //Any printable character - well make it editable
        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 &&
          !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all rows
        if (isMultiple && !self.editor && ((e.ctrlKey || e.metaKey) && key === 65)) {
          checkbox
            .addClass('is-checked')
            .removeClass('is-partial')
            .attr('aria-checked', 'true');
          self.selectAllRows();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

      });
    },

    isContainTextfield: function(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'],
        selector = 'textarea, input',
        l = noTextTypes.length, i;

      selector += l ? ':not(' : '';
      for(i = 0; i < l; i++) {
        selector += '[type='+ noTextTypes[i] +'],';
      }
      selector = l ? (selector.slice(0, -1) + ')') : '';

      return !!($(selector, container).length);
    },

    notContainTextfield: function(container) {
      var selector = '.dropdown, .datepicker';
      return !($(selector, container).length);
    },

    //Current Cell Editor thats in Use
    editor: null,

    isCellEditable: function(row, cell) {

      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);
      if (col.readonly) {
        return false;
      }

      //Check if cell is editable via hook function
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellValue = (cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field));

      if (col.isEditable) {
        var canEdit = col.isEditable(row, cell, cellValue, col, this.settings.dataset[row]);

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },

    // Invoked in three cases: 1) a row click, 2) keyboard and enter, 3) In actionable mode and tabbing
    makeCellEditable: function(row, cell, event) {
      if (this.editor && this.editor.input) {
        if (this.editor.input.is('.timepicker, .datepicker, .lookup, .spinbox') && !$(event.target).prev().is(this.editor.input)) {
          this.commitCellEdit(this.editor.input);
        }
      }

      //Locate the Editor
      var col = this.columnSettings(cell);

      //Select the Rows if the cell is editable
      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }
        return false;
      }

      var dataRowIndex = this.dataRowIndex(this.dataRowNode(row)),
        rowData = this.settings.treeGrid ?
          this.settings.treeDepth[dataRowIndex].node :
          this.settings.dataset[dataRowIndex],
        cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellParent = cellNode.parent('td'),
        cellWidth = cellParent.outerWidth(),
        isEditor = $('.is-editor', cellParent).length > 0,
        cellValue = (cellNode.text() ?
          cellNode.text() : this.fieldValue(rowData, col.field));

      if (isEditor) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(dataRowIndex, cell)) {
        return false;
      }

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        //Already in edit mode
        cellNode.find('input').focus();
        return false;
      }

      // In Show Ediitor mode the editor is on form already
      if (!col.inlineEditor) {

        if (isEditor) {
          cellNode.css({'position': 'static', 'height': cellNode.outerHeight()});
        }
        //Editor.init
        cellParent
          .addClass('is-editing')
          .css({'max-width': cellWidth, 'min-width': cellWidth, 'width': cellWidth});

        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      this.editor = new col.editor(dataRowIndex, cell, cellValue, cellNode, col, event, this, rowData);

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }
      this.editor.val(cellValue);
      this.editor.focus();
      this.element.triggerHandler('entereditmode', [{row: dataRowIndex, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor}]);

      return true;
    },

    commitCellEdit: function(input) {
      var newValue, cellNode,
        isEditor = input.is('.editor'),
        isUseActiveRow = !(input.is('.timepicker, .datepicker, .lookup, .spinbox'));

      if (!this.editor) {
        return;
      }

      //Editor.getValue
      newValue = this.editor.val();

      if (isEditor) {
        cellNode = this.editor.td;
      } else {
        cellNode = input.closest('td');
        newValue = $.escapeHTML(newValue);
      }

      //Format Cell again
      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline');

      //Editor.destroy
      this.editor.destroy();
      this.editor = null;

      var rowIndex;
      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.row;
      } else {
        rowIndex = this.dataRowIndex(cellNode.parent());
      }

      var cell = cellNode.index();
      var col = this.columnSettings(cell);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[rowIndex].node : this.settings.dataset[rowIndex];
      var oldValue = this.fieldValue(rowData, col.field);

      //Save the Cell Edit back to the data set
      this.updateCellNode(rowIndex, cell, newValue, false, isInline);
      var value = this.fieldValue(rowData, col.field);
      this.element.triggerHandler('exiteditmode', [{row: rowIndex, cell: cell, item: rowData, target: cellNode, value: value, oldValue: oldValue, column: col, editor: this.editor}]);
    },

    //Validate a particular cell if it has validation on the column and its visible
    validateCell: function (row, cell) {
      var self = this,
        column = this.columnSettings(cell),
        validate = column.validate;

      if (!validate) {
        return;
      }

      var rules = column.validate.split(' '),
        validator = $.fn.validation,
        cellValue = this.fieldValue(this.settings.dataset[row], column.field),
        isValid = true,
        messages = '';

      for (var i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]],
          gridInfo = {row: row, cell: cell, item: this.settings.dataset[row], column: column, grid: self},
          ruleValid = rule.check(cellValue, $('<input>').val(cellValue), gridInfo);

        if (!ruleValid) {
          if (messages) {
            messages = ((/^\u2022/.test(messages)) ? '' : '\u2022 ') + messages;
            messages += '<br>' + '\u2022 ' + rule.message;
          } else {
            messages = rule.message;
          }
          isValid = false;
        }
      }

      if (!isValid) {
		self.showCellError(row, cell, messages);
        self.element.trigger('cellerror', {row: row, cell: cell, message: messages, target: this.cellNode(row, cell), value: cellValue, column: column});
      } else {
        self.clearCellError(row, cell);
      }

    },

    showCellError: function (row, cell, errorMessage) {
      var node = this.cellNode(row, cell);

	  // clear the table nonVisibleCellErrors for the row and cell
	  this.clearNonVisibleCellErrors(row, cell);

      if (!node.length) {
		// Store the nonVisibleCellError
	    this.nonVisibleCellErrors.push({ row: row, cell: cell, errorMessage: errorMessage });
		this.showNonVisibleCellErrors();
        return;
      }

      //Add icon and classes
      node.addClass('error').attr('data-errormessage', errorMessage);
      var icon = $($.createIcon({ classes: ['icon-error'], icon: 'error' }));

      //Add and show tooltip
      if (node.find('.icon-error').length === 0) {
        node.find('.datagrid-cell-wrapper').append(icon);
        icon.tooltip({placement: 'bottom', isErrorColor: true, content: errorMessage});
        icon.data('tooltip').show();
      }

    },

	showNonVisibleCellErrors: function () {
      var messages, tableerrors, icon;

	  // Create empty toolbar
	  if (!this.toolbar) {
		settings.toolbar = { title: '' };
		this.appendToolbar();
	  }

	  if (this.toolbar.parent().find('.tableerrors').length === 1) {
        tableerrors = this.element.parent().find('.tableerrors');
      }

	  if (!this.nonVisibleCellErrors.length) {
		// clear the displayed error
		if (tableerrors && tableerrors.length) {
		  icon = tableerrors.find('.icon-error');
          var tooltip = icon.data('tooltip');
          if (tooltip) {
            tooltip.hide();
          }
          tableerrors.find('.icon-error').remove();
		}
		return;
	  }

	  for (var i = 0; i < this.nonVisibleCellErrors.length; i++) {
		   messages = (messages ? messages + '<br>' : '') + this.nonVisibleCellErrors[i].errorMessage;
	  }

	  if (this.element.parent().find('.tableerrors').length === 0) {
        tableerrors = $('<div class="tableerrors"></div>');
	  }
	  icon = tableerrors.find('.icon-error');
	  if (!icon.length) {
		icon = $($.createIcon({ classes: ['icon-error'], icon: 'error' }));
		tableerrors.append(icon);
	  }
	  if (this.element.hasClass('has-toolbar')) {
		//Add Error to the Toolbar
		this.toolbar.append(tableerrors);
	  }
      icon.tooltip({placement: 'bottom', isErrorColor: true, content: messages});
      icon.data('tooltip').show();

    },

    clearCellError: function (row, cell) {
	  this.clearNonVisibleCellErrors(row, cell);
      var node = this.cellNode(row, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node);
    },

	clearNonVisibleCellErrors: function (row, cell) {

	  if (!this.nonVisibleCellErrors.length) {
        return;
	  }

	  this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell)) {
          return error;
        }
      });

	  if (!this.nonVisibleCellErrors.length) {
		this.showNonVisibleCellErrors();
	  }
    },

    clearRowError: function (row) {
      var rowNode = this.dataRowNode(row);

      rowNode.removeClass('error alert');
      this.rowStatus(row, '', '');
    },

    clearAllErrors: function () {
      var self = this;

      this.tableBody.find('td.error').each(function () {
        var node = $(this);
        self.clearNodeErrors(node);
      });
    },

    clearNodeErrors: function (node) {
      node.removeClass('error').removeAttr('data-errormessage');

      var icon = node.find('.icon-error');
      var tooltip = icon.data('tooltip');
      if (tooltip) {
        tooltip.hide();
      }
      node.find('.icon-error').remove();
    },

    resetRowStatus: function () {
      for (var i = 0; i < this.settings.dataset.length; i++) {
        this.rowStatus(i, '');
      }
    },

    dirtyRows: function () {
      var rows = [],
        data = this.settings.dataset;

      for (var i = 0; i < data.length; i++) {
        if (data[i].rowStatus && data[i].rowStatus.icon === 'dirty') {
          rows.push(data[i]);
        }
      }
      return rows;
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    showRowError: function (row, message, type) {
      var messageType = type || 'error',
        rowNode = this.dataRowNode(row);

      rowNode.addClass('error');
      this.rowStatus(row, messageType, message);
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    validateRow: function (row) {
      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },

    //Validate all rows and cells with validation on them
    validateAll: function () {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },

    columnSettings: function (cell, onlyVisible) {
      var column = settings.columns[cell];

      if (onlyVisible) {
        column = this.visibleColumns()[cell];
      }

      return column || {};
    },

    //Attempt to serialize the value back into the dataset
    coerceValue: function (value, oldVal, col, row, cell) {
      var newVal;

      if (col.serialize) {
        newVal = col.serialize(value, oldVal, col, row, cell, this.settings.dataset[row]);
        return newVal;
      }

      return newVal;
    },

    updateCell: function(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },

    updateCellNode: function (row, cell, value, fromApiCall, isInline) {
      var coercedVal, escapedVal,
        rowNode = this.visualRowNode(row),
        cellNode = rowNode.find('td').eq(cell),
        col = this.settings.columns[cell] || {},
        formatted = '',
        formatter = (col.formatter ? col.formatter : this.defaultFormatter),
        isEditor = $('.editor', cellNode).length > 0,
        isTreeGrid = this.settings.treeGrid,
        rowData = isTreeGrid ?
          this.settings.treeDepth[row].node :
          this.settings.dataset[row];

      var oldVal = (col.field ? rowData[col.field] : '');

      //Coerce/Serialize value if from cell edit
      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell);

        //coerced value may be coerced to empty string, null, or 0
        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      }

      //Setup/Sync tooltip
      if (cellNode.data('tooltip')){
        cellNode.data('tooltip').destroy();
      }

      //Update the value in the dataset
      if (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip) {
        cellNode.attr('title', rowData.rowStatus.tooltip);
        cellNode.tooltip({placement: 'right',
          isErrorColor: rowData.rowStatus.icon === 'error'
        });
      }

      coercedVal = $.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1 ) {
          var parts = col.field.split('.');
          if (parts.length === 2) {
            rowData[parts[0]][parts[1]] = coercedVal;
          }

          if (parts.length === 3) {
            rowData[parts[0]][parts[1]][parts[2]] = coercedVal;
          }

        } else {
          rowData[col.field] = coercedVal;
        }
      }

      //update cell value
      escapedVal = $.escapeHTML(coercedVal);
      formatted = this.formatValue(formatter, (isTreeGrid ? row+1 : row), cell, (isEditor ? coercedVal : escapedVal), col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);
        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

	  if (!fromApiCall) {
	    //Validate the cell
        this.validateCell(row, cell);
	  }

      if (coercedVal !== oldVal && !fromApiCall) {
        var args = {row: row, cell: cell, target: cellNode, value: coercedVal, oldValue: oldVal, column: col};
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ?
          this.settings.treeDepth[row].node : rowData;

        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;

        if (this.settings.showDirty) {
          this.rowStatus(row, 'dirty');
        }
      }

    },

    //For the row node get the index - adjust for paging / invisible rowsCache
    visualRowIndex: function (row) {
      return this.tableBody.find('tr:visible').index(row);
    },

    visualRowNode: function (idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx = rowIdx + ((this.pager.activePage -1) * this.settings.pagesize);
      }

      return this.tableBody.find('tr[aria-rowindex="'+ (rowIdx + 1) +'"]');
    },

    dataRowNode: function (idx) {
      return this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]');
    },

    dataRowIndex: function (row) {
     return row.attr('aria-rowindex') - 1;
    },

    actualArrayIndex: function (rowElem) {
     return parseInt(rowElem.attr('data-index'));
    },

    // Update a specific Cell
    setActiveCell: function (row, cell) {
      var self = this,
        prevCell = self.activeCell,
        rowElem = row, rowNum, dataRowNum,
        isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        dataRowNum = this.dataRowIndex(rowElem);
      }

      //Support passing the td in
      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        if (isGroupRow) {
          rowElem = row.parent();
        }
        cell = row.index();
        rowNum = this.visualRowIndex(row.parent());
		    dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
		    dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      }

      //Remove previous tab index
      if (prevCell.node && prevCell.node.length ===1) {
        self.activeCell.node.removeAttr('tabindex');
      }

      //Hide any cell tooltips (Primarily for validation)
      if (prevCell.cell !== cell || prevCell.row !== row) {
        $('#tooltip').hide();
      }

      //Find the cell if it exists
      self.activeCell.node = self.cellNode((isGroupRow ? rowElem : (dataRowNum > -1 ? dataRowNum : rowNum)), (cell)).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
		    dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length) {
        self.activeCell.node.focus();
        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }
      if (self.activeCell.node.hasClass('is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }
      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        }
        else if (cell >= colSpan) {
          rowElem.find('td').eq(cell-colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell-colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = (colSpan - 1) + cell;
        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes();
        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }
      this.activeCell.isFocused = true;

      self.element.trigger('activecellchange', [{node: this.activeCell.node, row: this.activeCell.row, cell: this.activeCell.cell}]);
    },

    setNextActiveCell: function (e) {
      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          var evt = $.Event('keydown.datagrid');
          evt.keyCode = 40; // move down
          this.activeCell.node.trigger(evt);
        }
        else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },

    // Add children to treegrid dataset
    addChildren: function(parent, data) {
      if (!data || (data && !data.length) || parent < 0) {
        return;
      }
      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || [];

      // Make sure it's not reference pointer to data object, make copy of data
      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }
      this.updateDataset(this.settings.dataset);
    },

    // Set expanded property in Dataset
    setExpandedInDataset: function(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },

    //expand the tree rows
    toggleChildren: function(e, dataRowIndex) {
      var self = this,
        rowElement = this.visualRowNode(dataRowIndex),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        level = parseInt(rowElement.attr('aria-level'), 10),
        children = rowElement.nextUntil('[aria-level="'+ level +'"]'),
        isExpanded = expandButton.hasClass('is-expanded'),
        args = [{grid: self, row: dataRowIndex, item: rowElement, children: children}];

      if (self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') ||
          (!$(e.target).is(expandButton) &&
            (self.settings.editable || self.settings.selectable))) {
        return;
      }

      var toggleExpanded = function() {
        rowElement = self.visualRowNode(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        children = rowElement.nextUntil('[aria-level="'+ level +'"]');

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded')
            .find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded')
            .find('.plus-minus').addClass('active');
        }
        self.setExpandedInDataset(dataRowIndex, !isExpanded);

        var setChildren = function (rowElement, level, isExpanded) {
          var nodes = rowElement.nextUntil('[aria-level="'+ level +'"]');

          if (isExpanded) {
            nodes.each(function () {
              var node = $(this),
              nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel > level) {
                node.addClass('is-hidden');
              }
            });
          }
          else {
            nodes.each(function () {
              var node = $(this),
                nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel === (level + 1)) {
                node.removeClass('is-hidden');

                if (node.is('.datagrid-tree-parent')) {
                  var nodeIsExpanded = node.find('.datagrid-expand-btn.is-expanded').length > 0;
                  if (nodeIsExpanded) {
                    setChildren(node, nodeLevel, !nodeIsExpanded);
                  }
                }
              }
            });
          }
        };
        setChildren(rowElement, level, isExpanded);
        self.setAlternateRowShading();
      };

      $.when(self.element.triggerHandler(isExpanded ? 'collapserow' : 'expandrow', args)).done(function() {
        toggleExpanded();
      });
    },

    //Expand Detail Row Or Tree Row
    toggleRowDetail: function(dataRowIndex) {

      var self = this,
        rowElement = self.visualRowNode(dataRowIndex),
        expandRow = rowElement.next(),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        detail = expandRow.find('.datagrid-row-detail'),
        item = self.settings.dataset[self.actualArrayIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        //collapse any other expandable rows
        var prevExpandRow = self.tableBody.find('tr.is-expanded'),
          parentRow = prevExpandRow.prev(),
          parentRowIdx = parentRow.attr('aria-rowindex');

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');

          prevExpandRow.removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.css('display', 'none').removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{grid: self, row: parentRowIdx, detail: prevDetail, item: self.settings.dataset[parentRowIdx] }]);
          });

          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');
          if (prevActionBtn.length) {
            prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary','btn-secondary'));
          }
        }

        //Toggle the button to make it primary
        var isExpanded = !expandRow.hasClass('is-expanded'),
          actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (actionButton.length > 0 && parentRow && actionButton) {
          var currentClass = actionButton.attr('class') || '';

          actionButton.attr('class', currentClass.replace(isExpanded ? 'btn-secondary' : 'btn-primary',
              isExpanded ? 'btn-primary' : 'btn-secondary') );
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        expandRow.removeClass('is-expanded');
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        }

        detail.animateClosed().on('animateclosedcomplete', function () {
          expandRow.css('display', 'none');
          self.element.triggerHandler('collapserow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
        });

      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded')
          .find('.plus-minus').addClass('active');

        expandRow.css('display', 'table-row');

        //Optionally Contstrain the width
        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());

        if (self.settings.allowOneExpandedRow) {
          rowElement.addClass('is-rowactivated');
        }

        detail.animateOpen();
        self.element.triggerHandler('expandrow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
      }
    },

    toggleGroupChildren: function(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this,
        children = rowElement.nextUntil('.datagrid-rowgroup-header'),
        expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        children.hide();
        children.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.removeClass('is-expanded');
      } else {
      expandButton.addClass('is-expanded')
        .find('.plus-minus').addClass('active');

        children.show();
        children.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.addClass('is-expanded');
      }

    },

    //Api Event to set the sort Column
    setSortColumn: function(id, ascending) {
      //Set Direction based on if passed in or toggling existing field
      if (ascending !== undefined) {
        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
           this.sortColumn.sortAsc = true;
        }
        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = (this.columnById(id)[0] ? this.columnById(id)[0].field : id);
      this.sortColumn.sortAsc = ascending;

      //Do Sort on Data Set
      this.setSortIndicator(id, ascending);
      this.sortDataset();

      var wasFocused = this.activeCell.isFocused;
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.renderRows();
      // Update selected and Sync header checkbox
      this.updateSelected();
      this.syncSelectedUI();

      if (wasFocused && this.activeCell.node.length === 1) {
        this.setActiveCell(this.activeCell.row, this.activeCell.cell);
      }

      this.resetPager('sorted');
      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.element.trigger('sorted', [this.sortColumn]);
    },

    sortDataset: function() {
      if (this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }
      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);

      if (!this.settings.disableClientSort) {
        settings.dataset.sort(sort);
      }
    },

    setSortIndicator: function(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      //Set Visual Indicator
      this.headerRow.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc').attr('aria-sort', 'none');
      this.headerRow.find('[data-column-id="' +id + '"]')
        .addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc')
        .attr('aria-sort', ascending ? 'ascending' : 'descending');
    },

    //Overridable function to conduct sorting
    sortFunction: function(id, ascending) {
      var column = this.columnById(id),
        field = column.length === 0 ? id : column[0].field; //Assume the field and id match if no column found

      var key, self = this,
      primer = function(a) {
        a = (a === undefined || a === null ? '' : a);

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }

        }
        return a;
      };

      key = function(x) { return primer(self.fieldValue(x, field)); };

      ascending = !ascending ? -1 : 1;

      return function (a, b) {
        a = key(a);
        b = key(b);

        if (typeof a !== typeof b) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },

    // Update Selection
    updateSelected: function() {
      var self = this,
        s = self.settings;

      $('tr[role="row"]', self.tableBody).each(function() {
        var row = $(this),
          newIdx = self.dataRowIndex(row),
          checkbox = self.cellNode(row, self.columnIdxById('selectionCheckbox'));

        if (s.paging && s.source && self.pager) {
          newIdx = (newIdx - ((self.pager.activePage - 1) * s.pagesize));
        }

        $.each(self._selectedRows, function(index, val) {
          if (self.isEquals(val.data, s.dataset[newIdx])) {
            val.idx = newIdx;
            val.elem = row;
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
            row.addClass('is-selected' + (s.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true').find('td').attr('aria-selected', 'true');
            return false;
          }
        });
      });
    },

    // Determine equality for two JavaScript objects
    isEquals: function(obj1, obj2) {
      function _equals(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify($.extend(true, {}, obj1, obj2));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    },

    //Default formatter just plain text style
    defaultFormatter: function(row, cell, value) {
      return ((value === null || value === undefined || value === '') ? '' : value.toString());
    },

    //Handle Adding Paging
    handlePaging: function () {
      var self = this;

      if (!this.settings.paging) {
        return;
      }

      var pagerElem = this.tableBody;
      this.element.addClass('paginated');
      pagerElem.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }

      this.pager = pagerElem.data('pager');

      pagerElem
      .on('beforepaging', function () {
        // Selection support only for current page
        if (self.pager && self.settings.source) {
          self._selectedRows = [];
        }
      })
      .on('afterpaging', function (e, args) {

        self.displayCounts(args.total);

        //Handle row selection across pages
        self.updateSelected();
        self.syncSelectedUI();

        if (self.filterExpr && self.filterExpr[0] && self.filterExpr[0].column === 'all') {
          self.highlightSearchRows(self.filterExpr[0].value);
        }
      });

    },

    renderPager: function (pagingInfo, isResponse) {
      var api = this.pager;

      if (!api) {
        return;
      }

      api.updatePagingInfo(pagingInfo);

      if (!isResponse) {
        api.renderPages(pagingInfo.type);
      }

      // Update selected and Sync header checkbox
      this.updateSelected();
      this.syncSelectedUI();
    },

    //Reset the pager to page 1
    resetPager: function(type) {
      if (!this.pager) {
        return;
      }

      if (!this.pager.pagingInfo) {
        this.pager.pagingInfo = {};
      }

      this.pager.pagingInfo.type = type;
      this.pager.pagingInfo.activePage = 1;
      this.renderPager(this.pager.pagingInfo);
    },

    destroy: function() {
      //Remove the toolbar, clean the div out and remove the pager
      this.element.off().empty().removeClass('datagrid-container');
      var toolbar = this.element.prev('.toolbar');

      if (this.removeToolbarOnDestroy && settings.toolbar && settings.toolbar.keywordFilter) {
        var searchfield = toolbar.find('.searchfield');
        if (searchfield.data('searchfield')) {
          searchfield.data('searchfield').destroy();
        }
        if (searchfield.data('toolbarsearchfield')) {
          searchfield.data('toolbarsearchfield').destroy();
        }
        searchfield.removeData('options');
      }

      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        if (toolbar.data('toolbar')) {
          toolbar.data('toolbar').destroy();
        }
        toolbar.remove();
      }
      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], pluginName);

      //TODO Test Memory Leaks in Chrome - null out fx this.table
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      this.contentContainer.off().remove();
      $('body').off('resize.vtable resize.datagrid');
    }

  };

  // Initialize the plugin (Once) or set settings
  return this.each(function() {
    var instance = $.data(this, pluginName);
    if (instance) {
      instance.settings = $.extend({}, defaults, options);
    } else {
      instance = $.data(this, pluginName, new Datagrid(this, settings));
    }
  });

};

  $.fn.dropdown = function(options) {

    'use strict';

    // Dropdown Settings and Options
    var pluginName = 'dropdown',
        defaults = {
          closeOnSelect: true,
          cssClass: null,
          filterMode: 'contains',
          maxSelected: undefined, //If in multiple mode, sets a limit on the number of items that can be selected
          moveSelected: 'none',
          moveSelectedToTop: undefined,
          multiple: false, //Turns the dropdown into a multiple selection box
          noSearch: false,
          showEmptyGroupHeaders: false,
          showSelectAll: false, // If true, on Multiselect dropdowns, will show an additional option at the top of the list labeled "select all".
          source: undefined,
          sourceArguments: {},
          reloadSourceOnOpen: false,
          empty: false,
          delay: 300
        },
        moveSelectedOpts = ['none', 'all', 'group'],
        settings = $.extend({}, defaults, options);

    /**
    * The Dropdown allows users to select from a list. Like an Html Select.
    *
    * @class Dropdown
    * @param {Boolean} closeOnSelect  &nbsp;-&nbsp; When an option is selected, the list will close if set to "true".  List stays open if "false".
    * @param {String} cssClass  &nbsp;-&nbsp; Append an optional css class to dropdown-list
    * @param {String} filterMode  &nbsp;-&nbsp; Search mode to use between 'startsWith' and 'contains', false will not allow client side filter
    * @param {Boolean} noSearch  &nbsp;-&nbsp; If true, disables the ability of the user to enter text in the Search Input field in the open combo box
    * @param {Boolean} showEmptyGroupHeaders  &nbsp;-&nbsp; If true, displays <optgroup> headers in the list even if no selectable options are present underneath.
    * @param {Boolean} source  &nbsp;-&nbsp; A function that can do an ajax call.
    * @param {Boolean} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} reloadSourceOnOpen  &nbsp;-&nbsp; If set to true, will always perform an ajax call whenever the list is opened.  If false, the first AJAX call's results are cached.
    * @param {Boolean} empty  &nbsp;-&nbsp; Initialize Empty Value
    * @param {Boolean} delay  &nbsp;-&nbsp; Typing Buffer Delay in ms
    *
    */
    function Dropdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual DropDown Code
    Dropdown.prototype = {
      init: function() {
        var orgId = this.element.attr('id');

        this.isIe10 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '10');
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');

        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        if (orgId === undefined) {
          orgId = this.element.uniqueId('dropdown');
          this.element.attr('id', orgId);
          this.element.parent().find('label').first().attr('for', orgId);
        }

        // convert <select> tag's size css classes for the pseudo element
        var elemClassList = this.element[0].classList;
        if (elemClassList.length === 0) {
          this.element[0].classList = 'dropdown';
        }
        var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' :
            elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' :
            elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown';

        //Detect Inline Styles
        var style = this.element.attr('style');
        this.isHidden = style && style.indexOf('display: none') >= 0;

        // Build the wrapper if it doesn't exist
        var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
        this.wrapper = baseElement.next('.dropdown-wrapper');
        this.isWrapped = this.wrapper.length > 0;

        if (!this.isWrapped) {
          this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
        }

        if (this.isWrapped) {
          this.pseudoElem = this.wrapper.find('.' + pseudoClassString);
          this.trigger = this.wrapper.find('.trigger');
        } else {
          this.pseudoElem = $('div#'+ orgId + '-shdo');
        }

        if(elemClassList.contains('text-align-reverse')) {
          pseudoClassString += ' text-align-reverse';
        } else if (elemClassList.contains('text-align-center')){
          pseudoClassString += ' text-align-center';
        }

        // Build sub-elements if they don't exist
        this.label = $('label[for="'+ orgId +'"]');

        if (!this.pseudoElem.length) {
          this.pseudoElem = $('<div class="'+ pseudoClassString + '">');
        } else {
          this.pseudoElem[0].setAttribute('class', pseudoClassString);
        }

        if (!this.isWrapped) {
          this.pseudoElem.append($('<span></span>'));
        }

        this.pseudoElem.attr({'role': 'combobox',
          'aria-autocomplete': 'list',
          'aria-controls': 'dropdown-list',
          'aria-readonly': 'true',
          'aria-expanded': 'false',
          'aria-label': this.label.text()});

        // Pass disabled/readonly from the original element, if applicable
        // "disabled" is a stronger setting than "readonly" - should take precedent.
        function handleStates(self) {
          var disabled = self.element.prop('disabled'),
            readonly = self.element.prop('readonly');

          if (disabled) {
            return self.disable();
          }

          if (readonly) {
            return self.readonly();
          }

          return self.enable();
        }
        handleStates(this);

        if (!this.isWrapped) {
          this.wrapper.append(this.pseudoElem, this.trigger);
        }

        // Check for and add the icon
        this.icon = this.wrapper.find('.icon');
        if (!this.icon.length) {
          this.icon = $.createIconElement('dropdown');
          this.wrapper.append(this.icon);
        }

        // Setup the incoming options that can be set as properties/attributes
        if (this.element.prop('multiple') && !this.settings.multiple) {
          this.settings.multiple = true;
        }
        var dataSource = this.element.attr('data-source');
        if (dataSource && dataSource !== 'source') {
          this.settings.source = dataSource;
        }
        var dataMaxselected = this.element.attr('data-maxselected');
        if (dataMaxselected && !isNaN(dataMaxselected)) {
          this.settings.maxSelected = parseInt(dataMaxselected, 10);
        }

        // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
        // _getMoveSelectedSetting()_ converts the old setting to the new text type.
        function getMoveSelectedSetting(incomingSetting, useText) {
          switch (incomingSetting) {
            case (useText ? 'true' : true):
              return 'all';
            case (useText ? 'false' : false):
              return 'none';
            default:
              if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
                return incomingSetting;
              }
              return 'none';
          }
        }

        // Backwards compatibility for deprecated "moveSelectedToTop" setting.
        if (this.settings.moveSelectedToTop !== undefined) {
          this.settings.moveSelected = this.settings.moveSelectedToTop;
        }

        var dataMoveSelected = this.element.attr('data-move-selected');
        if (dataMoveSelected) {
          this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
        } else {
          this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
        }

        var dataCloseOnSelect = this.element.attr('data-close-on-select');
        if (dataCloseOnSelect && !this.settings.closeOnSelect) {
          this.settings.closeOnSelect = dataCloseOnSelect === 'true';
        }
        var dataNoSearch = this.element.attr('data-no-search');
        if (dataNoSearch && !this.settings.noSearch) {
          this.settings.noSearch = dataNoSearch === 'true';
        }

        // Persist sizing defintions
        var sizingStrings = ['-xs', '-sm', '-md', '-lg'],
          classString = this.element.attr('class'),
          s;

        for (var i = 0; i < sizingStrings.length; i++) {
          s = sizingStrings[i];
          if (classString.match(s)) {
            this.pseudoElem.addClass('dropdown' + s);
          }
        }

        // Cached dataset (from AJAX, if applicable)
        this.dataset = [];

        this.listfilter = new ListFilter({
          filterMode: this.settings.filterMode
        });

        this.setValue();
        this.setInitial();
        this.setWidth();

        this.element.triggerHandler('rendered');

        return this.handleEvents();
      },

      // Used for preventing menus from popping open/closed when they shouldn't.
      // Gets around the need for timeouts everywhere
      inputTimer: function() {
        if (this.inputTimeout) {
          return false;
        }

        var self = this;

        this.inputTimeout = setTimeout(function inputTimeout(){
          clearTimeout(self.inputTimeout);
          self.inputTimeout = null;
        }, 100);

        return true;
      },

      // Set Field Width
      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.pseudoElem[0].style.width = style.width;
        }
        if (style.position === 'absolute') {
          this.pseudoElem[0].style.position = 'absolute';
          this.pseudoElem[0].style.left = style.left;
          this.pseudoElem[0].style.top = style.top;
          this.pseudoElem[0].style.bottom = style.bottom;
          this.pseudoElem[0].style.right = style.right;
        }
      },

      // Keep a generated list of items and update as needed
      updateList: function() {
        var self = this,
          isMobile = self.isMobile(),
          listExists = self.list !== undefined && self.list !== null && self.list.length > 0,
          listContents = '',
          ulContents = '',
          upTopOpts = 0,
          hasOptGroups = this.element.find('optgroup').length,
          reverseText = '',
          isMultiselect = this.settings.multiple === true,
          moveSelected = '' + this.settings.moveSelected,
          showSelectAll = this.settings.showSelectAll === true;

        if(this.element[0].classList.contains('text-align-reverse')){
          reverseText = ' text-align-reverse';
        } else if (this.element[0].classList.contains('text-align-center')){
          reverseText = ' text-align-center';
        }

        if (!listExists) {
          listContents = '<div class="dropdown-list' + reverseText +
            (isMobile ? ' mobile' : '') +
            (this.settings.multiple ? ' multiple' : '') + '" id="dropdown-list" role="application" ' + (this.settings.multiple ? 'aria-multiselectable="true"' : '') + '>' +
            '<label for="dropdown-search" class="audible">' + Locale.translate('Search') + '</label>' +
            '<input type="text" class="dropdown-search' + reverseText +
            '" role="combobox" aria-expanded="true" id="dropdown-search" aria-autocomplete="list">' +
            '<span class="trigger">' +
              (isMobile ? $.createIcon({ icon: 'close', classes: ['close'] }) : $.createIcon('dropdown')) +
              '<span class="audible">' + (isMobile ? Locale.translate('Close') : Locale.translate('Collapse')) + '</span>' +
            '</span>' +
            '<ul role="listbox">';
        }

        // Get a current list of <option> elements
        // If none are available, simply return out
        var opts = this.element.find('option');
        var groups = this.element.find('optgroup');
        var selectedOpts = opts.filter(':selected');
        var groupsSelectedOpts = [];

        function buildLiHeader(textContent) {
          return '<li role="presentation" class="group-label" focusable="false">' +
              textContent +
            '</li>';
        }

        function buildLiOption(option, index) {
          var liMarkup = '',
            attributes = Soho.DOM.getAttributes(option),
            text = option.innerHTML,
            value = attributes.getNamedItem('value'),
            title = attributes.getNamedItem('title'),
            badge = attributes.getNamedItem('data-badge'),
            badgeColor = attributes.getNamedItem('data-badge-color'),
            isSelected = option.selected,
            isDisabled = option.disabled,
            cssClasses = option.className;

          var trueValue = value && value.value ? value.value : text;
          if (cssClasses.indexOf('clear') > -1) {
            if (text === '') {
              text = Locale.translate('ClearSelection');
            }
          }

          // Set attributes need to be copy over
          var attrToCopy = {
            str: '',
            isExclude: function(attr) {
              var toExclude = ['data-badge', 'data-badge-color', 'data-val'];
              return $.inArray(attr, toExclude) > -1;
            }
          };
          for (var key in attributes) {
            if (!attributes.hasOwnProperty(key)) {
              continue;
            }
            attrToCopy.name = attributes[key].name + '';
            attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';
            if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
              attrToCopy.str += ' '+
                attrToCopy.name +'="'+ attributes[key].value +'"';
            }
          }

          liMarkup += '<li role="presentation" class="dropdown-option'+ (isSelected ? ' is-selected' : '') +
                        (isDisabled ? ' is-disabled' : '') +
                        (cssClasses ? ' ' + cssClasses.value : '' ) + '"' +
                        attrToCopy.str +
                        ' data-val="' + trueValue.replace('"', '/quot/') + '"' +
                        ' tabindex="' + (index && index === 0 ? 0 : -1) + '">' +
                        (title ? '" title="' + title.value + '"' : '') +
                        '<a role="option" href="#" class="' +
                        (cssClasses.indexOf('clear') > -1 ? ' clear-selection' : '' ) + '"' +
                        'id="list-option'+ index +'">' +
                          text +
                        '</a>' +
                        (badge ? '<span class="badge "' + (badgeColor ? badgeColor.value : 'azure07') + '"> '+ badge.value + '</span>' : '') +
                      '</li>';

          return liMarkup;
        }

        // In multiselect scenarios, shows an option at the top of the list that will
        // select all available options if checked.
        if (isMultiselect && showSelectAll) {
          var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;

          ulContents += '<li role="presentation" class="dropdown-select-all-list-item'+ (allSelected ? ' is-selected' : '') + '">' +
            '<a role="option" href="#" id="dropdown-select-all-anchor" class="dropdown-select-all-anchor">' +
              Locale.translate('SelectAll') +
            '</a>' +
          '</li>';
        }

        // Move selected options in each group to just underneath their corresponding group headers.
        if (moveSelected === 'group') {
          // If no optgroups exist, change to "all" and skip this part.
          if (!groups || !groups.length) {
            moveSelected = 'all';
          } else {

            // Break apart selectedOpts into groups.
            // These selected items are applied when the header is generated.
            groups.each(function(i, g) {
              var els = selectedOpts.filter(function() {
                return $.contains(g, this);
              });
              groupsSelectedOpts.push(els);
            });

          }
        }

        // Move all selected options to the top of the list if the setting is true.
        // Also adds a group heading if other option groups are found in the <select> element.
        if (moveSelected === 'all') {
          opts = opts.not(selectedOpts);

          // Show a "selected" header if there are selected options
          if (selectedOpts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('Selected') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }

          selectedOpts.each(function(i) {
            ulContents += buildLiOption(this, i);
            upTopOpts++;
          });

          // Only show the "all" header beneath the selected options if there are no other optgroups present
          if (!hasOptGroups && opts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('All') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }
        }

        opts.each(function(i) {
          var count = i + upTopOpts,
            option = $(this),
            parent = option.parent(),
            optgroupIsNotDrawn,
            optgroupIndex;

          // Add Group Header if this is an <optgroup>
          // Remove the group header from the queue.
          if (parent.is('optgroup') && groups.length) {
            optgroupIndex = parent.index();
            optgroupIsNotDrawn = groups.index(parent) > -1;

            if (optgroupIsNotDrawn) {
              groups = groups.not(parent);
              ulContents += buildLiHeader('' + parent.attr('label'));

              // Add all selected items for this group
              if (moveSelected === 'group') {
                groupsSelectedOpts[optgroupIndex].each(function(i) {
                  ulContents += buildLiOption(this, i);
                  upTopOpts++;
                });
              }
            }
          }

          if (moveSelected !== 'none' && option.is(':selected')) {
            return;
          }

          ulContents += buildLiOption(this, count);
        });

        // Render the new list contents to the page.
        // Build the entire thing and set references if this is the first opening.
        // Otherwise, simply replace the elements inside the <ul>.
        if (!listExists) {
          listContents += ulContents + '</ul>' +
            '</div>';

          // Append markup to the DOM
          this.list = $(listContents);

          // Get references
          this.listUl = this.list.find('ul');
          this.searchInput = this.list.find('#dropdown-search');
        } else {
          this.listUl.html(ulContents);
        }
      },

      // Set the value based on selected options
      setValue: function () {
        var opts = this.element.find('option:selected'),
          text = this.getOptionText(opts);

        if (opts.hasClass('clear')) {
          text = '';
        }

        if (this.settings.empty && opts.length === 0) {
          this.pseudoElem.find('span').text('');
          return;
        }

        //Set initial values for the edit box
        this.setPseudoElemDisplayText(text);
        if (this.element.attr('maxlength')) {
           this.setPseudoElemDisplayText(text.substr(0, this.element.attr('maxlength')));
        }

        //Set the "previousActiveDescendant" to the first of the items
        this.previousActiveDescendant = opts.first().val();

        this.setBadge(opts);
      },

      // Sets only the display text of the Dropdown/Mutliselect
      // Can be used for setting a pre-populated value when working with an AJAX call.
      setPseudoElemDisplayText: function(text) {
        this.pseudoElem.find('span').text(text);
      },

      copyClass: function(from, to, prop) {
        if (from.hasClass(prop)) {
          to.addClass(prop);
        }
      },

      // Copy initial stuff from the drop down.
      setInitial: function() {

        if (this.element.is(':disabled')) {
          this.disable();
        }
        if (this.element.is('[readonly]')) {
          this.readonly();
        }
        if (this.isHidden) {
          this.pseudoElem.hide().prev('label').hide();
          this.pseudoElem.next('svg').hide();
        }

        if (this.element.attr('placeholder')) {
          this.pseudoElem.attr('placeholder', this.element.attr('placeholder'));
          this.element.removeAttr('placeholder');
        }
      },

      ignoreKeys: function (input, e) {
        var charCode = e.which;

        //Needed for browsers that use keypress events to manipulate the window.
        if (e.altKey && (charCode === 38 || charCode === 40)) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (charCode === 8 && input.hasClass('dropdown')) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (input.is(':disabled') || input.hasClass('is-readonly')) {
          return;
        }

        return true;
      },

      //handle events while search is focus'd
      handleSearchEvents: function () {
        var self = this, timer;

        if (this.settings.noSearch) {
          this.searchInput.prop('readonly', true);
        }

        // Used to determine how spacebar should function.  False means space will select/deselect.  True means
        // Space will add a space inside the search input.
        this.searchKeyMode = false;

        this.searchInput.on('keydown.dropdown', function(e) {
          var searchInput = $(this);

          if (!self.ignoreKeys(searchInput, e)) {
            return;
          }

          if (!self.handleKeyDown(searchInput, e)) {
            return;
          }

          if (self.settings.noSearch === false && !self.settings.source) {
            clearTimeout(timer);
            timer = setTimeout(function () {
              if (searchInput.val() === '') {
                self.resetList();
              } else {
                self.filterList(searchInput.val().toLowerCase());
              }
            }, 100);
          }
        }).on('keypress.dropdown', function (e) {
          self.isFiltering = true;
          self.handleAutoComplete(e);
        });

      },

      filterList: function(term) {
        var self = this,
          selected = false,
          list = $('.dropdown-option', this.listUl),
          headers = $('.group-label', this.listUl),
          results;

        if (!list.length || !this.list || this.list && !this.list.length) {
          return;
        }

        if (!term) {
          term = '';
        }

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        this.list.addClass('search-mode');
        this.list.find('.icon').attr('class', 'icon search').changeIcon('search');
        this.searchInput.removeAttr('aria-activedescendant');

        this.unhighlightOptions();

        if (!results || !results.length && !term) {
          this.resetList();
          return;
        }

        list.not(results).add(headers).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');

          if (!selected) {
            self.highlightOption(li);
            selected = true;
          }

          //Highlight Term
          var exp = new RegExp('(' + term + ')', 'i');
          var text = li.text().replace(exp, '<i>$1</i>');
          li.removeClass('hidden').children('a').html(text);
        });

        headers.each(function() {
          var children = $(this).nextUntil('.group-label, .selector').not('.hidden');
          if (self.settings.showEmptyGroupHeaders || children.length) {
            $(this).removeClass('hidden');
          }
        });

        term = '';
        this.position();
      },

      // Removes filtering from an open Dropdown list and turns off "search mode"
      resetList: function() {
        if (!this.list || this.list && !this.list.length) {
          return;
        }
        var isMobile = this.isMobile(),
          cssClass = 'icon' + (isMobile ? ' close' : ''),
          icon = $.getBaseURL(isMobile ? 'close' : 'dropdown');

        this.list.removeClass('search-mode');
        this.list.find('.icon').attr('class', cssClass) // needs to be 'attr' here because .addClass() doesn't work with SVG
          .changeIcon(icon);

        function stripHtml(obj) {
          if (!obj[0]) {
            return '';
          }

          return obj[0].textContent || obj[0].innerText;
        }

        var lis = this.listUl.find('li');
        lis.removeAttr('style').each(function() {
          var a = $(this).children('a');
          a.text(stripHtml(a));
        });

        //Adjust height / top position
        if (this.list.hasClass('is-ontop')) {
          this.list[0].style.top = (this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2) +'px';
        }

        if (this.settings.multiple) {
          this.updateList();
        }
      },

      selectBlank: function() {
        var blank = this.element.find('option').filter(function() {
          return !this.value || $.trim(this.value).length === 0;
        });

        if (blank.length > 0) {
          blank[0].selected = true;
          this.element.triggerHandler('updated').triggerHandler('change');
        }

      },

      handleKeyDown: function(input, e) {
        var selectedIndex = this.element[0].selectedIndex || -1,
            options = this.element[0].options,
            key = e.which,
            self = this,
            excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)',
            next;

        if (this.isLoading()) {
          return;
        }

        //Down arrow, Up arrow, or Spacebar to open
        if (!self.isOpen() && (key === 38 || key === 40 || key === 32)) {
          self.toggleList();
          return;
        }

        if (self.isOpen()) {
          options = this.listUl.find(excludes);
          selectedIndex = -1;
          $(options).each(function(index) {
            if ($(this).is('.is-focused')) {
              selectedIndex = index;
            }
          });
        }

        switch (key) {
          case 37: //backspace
          case 8: //del & backspace
          case 46: { //del

            if (!self.isOpen()) {
              self.selectBlank();
              // Prevent Backspace from returning to the previous page.
              e.stopPropagation();
              e.preventDefault();
              return false;
            }
            break;
          }
          case 9: {  //tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.  If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              self.selectOption($(options[selectedIndex])); // store the current selection
              self.closeList('tab');
              this.activate();
            }
            // allow tab to propagate otherwise
            return true;
          }
          case 27: { //Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.closeList('cancel');
              self.activate();
              e.stopPropagation();
              return false;
            }
            // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.
            break;
          }
          case 32: // spacebar // TODO: Figure Out what to do about using Spacebar.
          case 13: { //enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              self.selectOption($(options[selectedIndex])); // store the current selection
              if (self.settings.closeOnSelect) {
                self.closeList('select');  // Close the option list
                self.activate();
              }
            }
            e.stopPropagation();
            return false;
          }
          case 38: {  //up
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find
              ('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 40: {  //down
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 35: { //end
            this.searchKeyMode = false;

            var last = $(options[options.length - 1]);
            this.highlightOption(last);

            e.stopPropagation();
            return false;
          }
          case 36: {  //home
            this.searchKeyMode = false;

            var first = $(options[0]);
            this.highlightOption(first);

            e.stopPropagation();
            return false;
          }
        }

        if (self.isOpen() && self.isControl(key) && key !== 8) {
          return false;
        }

        var isSearchInput = self.searchInput && self.searchInput.length;

        self.initialFilter = false;

        if (!self.isOpen() && !self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
          //Make this into Auto Complete
          self.initialFilter = true;
          self.isFiltering = true;
          self.filterTerm = $.actualChar(e);
          if (isSearchInput) {
            self.searchInput.val($.actualChar(e));
          }
          self.toggleList();
        }

        this.searchKeyMode = true;
        if (self.searchInput) {
          self.searchInput.attr('aria-activedescendant', '');
        }
        return true;
      },

      timer: null,
      filterTerm: '',

      handleAutoComplete: function(e) {
        if (this.isLoading()) {
          return;
        }

        var self = this;
        clearTimeout(this.timer);

        if (!self.settings.source) {
          return;
        }

        self.initialFilter = true;
        self.filterTerm += $.actualChar(e);

        this.timer = setTimeout(function () {
          if (!self.isOpen()) {
            self.searchInput.val(self.filterTerm);
            self.toggleList();
          } else {
            self.filterList(self.searchInput.val().toLowerCase());
          }
        }, self.settings.delay);
      },

      isControl: function(keycode) {
        var valid =
          (keycode > 7 && keycode < 48)   || // control chars
          (keycode > 90 && keycode < 94)   || // windows keys
          (keycode > 111 && keycode < 146);  // function keys

          return valid;
      },

      /**
      * Focus the input Element
      */
      activate: function (useSearchInput) {
        var self = this,
          input = this.pseudoElem;

        if (useSearchInput || self.isMobile()) {
          input = this.searchInput;
        }

        if (useSearchInput && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
          return;
        }

        function selectText() {
          if (self.isMobile()) {
            return;
          }

          if (input[0].setSelectionRange) {
            input[0].setSelectionRange(0, input[0].value.length);  //scroll to left
          } else {
            if (input[0].tagName === 'INPUT') { // using Search Input instead of Pseudo Div
              input[0].select();
            }
          }
        }

        selectText();

        if (document.activeElement !== input[0] &&
          $(document.activeElement).is('body, .dropdown.is-open')) {
          input[0].focus();
        }

        if (self.isIe10 || self.isIe11) {
          setTimeout(function() {
            input[0].focus();
          }, 0);
        }
      },

      // Retrieves a string containing all text for currently selected options delimited by commas
      getOptionText: function(opts) {
        var text = '';

        if (!opts) {
          opts = this.element.find('option:selected');
        }

        opts.each(function() {
          if (text.length > 0) {
            text += ', ';
          }
          text += $(this).text();
        });

        return text;
      },

      // Prep for opening list,make ajax call ect...
      open: function() {
        var self = this;

        if (!this.inputTimer()) {
          return;
        }

        if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
          return;
        }

        if (!self.callSource(function () {
          self.updateList();
          self.openList();
        })) {
          self.updateList();
          this.openList();
        }
      },

      // Actually Show The List
      openList: function () {
        var current = this.previousActiveDescendant ? this.list.find('.dropdown-option[data-val="'+ this.previousActiveDescendant.replace('"', '/quot/') +'"]') : this.list.find('.is-selected'),
          self =  this,
          touchPrevented = false,
          threshold = 10,
          isEmpty = true,
          pos;

        if (current.length > 0) {
          isEmpty = true;
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }

        // Persist the "short" input field
        var isShort = (this.element.closest('.field-short').length === 1);

        this.pseudoElem
          .attr('aria-expanded', 'true')
          .addClass('is-open');

        this.pseudoElem.attr('aria-label', this.label.text());
        this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

        //Close any other drop downs.
        $('select').each(function () {
          var data = $(this).data();
          if (data.dropdown) {
            data.dropdown.closeList('cancel');
          }
        });

        this.list.appendTo('body').show();

        //In a grid cell
        this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;
        if (this.pseudoElem.parent().hasClass('is-inline')) {
          this.isInGrid = false;
        }

        if (this.isInGrid) {
          var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
          this.list.addClass('datagrid-dropdown-list ' + rowHeight);
        }

        if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
          this.list.addClass('datagrid-filter-dropdown');
        }

        var cssClass = this.settings.cssClass;
        if (cssClass && typeof cssClass === 'string') {
          this.list.addClass(cssClass);
        }

        this.position();

        if (!this.settings.multiple && this.initialFilter) {
          setTimeout(function () {
            self.searchInput.val(self.filterTerm);
            self.filterList(self.searchInput.val());
          }, 0);
          this.initialFilter = false;
        } else {
          // Change the values of both inputs and swap out the active descendant
          this.searchInput.val(this.pseudoElem.find('span').text());
        }

        var noScroll = this.settings.multiple;
        this.highlightOption(current, noScroll);
        if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
          this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
          setTimeout(function() {
            self.listUl.scrollTop(0);
          }, 0);
        }

        if (!this.settings.multiple && !isEmpty) {
          this.searchInput.val(current.find('a').text());
        }

        this.handleSearchEvents();
        this.activate(true); // Focus the Search Input
        this.element.trigger('listopened');

        if (this.isMobile()) {
          // iOS-specific keypress event that listens for when you click the "done" button
          self.searchInput.on('keypress.dropdown', function(e) {
            if (e.which === 13) {
              self.closeList('select');
            }
          });
        }

        function listItemClickHandler(e) {
          var target = $(e.target),
            ddOption = target.closest('li');

          if (ddOption.length) {
            // Do nothing for group labels or separators
            if (ddOption.is('.separator, .group-label')) {
              return;
            }

            target = ddOption;
          }

          if (target.is('.dropdown-select-all-anchor')) {
            target = target.parent();
          }

          // If this is the Select All option, select/deselect all.
          if (self.settings.multiple && target.is('.dropdown-select-all-list-item')) {
            var doSelectAll = !(target.is('.is-selected'));
            if (doSelectAll) {
              target.addClass('is-selected');
              self.selectOptions(self.element.find('option:not(:selected)'), true);
            } else {
              target.removeClass('is-selected');
              self.selectOptions(self.element.find('option:selected'), true);
            }

            return true;
          }

          e.preventDefault();
          e.stopPropagation();

          var val = target.attr('data-val').replace('"','/quot/'),
            cur = self.element.find('option[value="'+ val +'"]');
          //Try matching the option's text if 'cur' comes back empty or overpopulated.
          //Supports options that don't have a 'value' attribute
          //And also some special &quote handling
          if (cur.length === 0 || cur.length > 1) {
            cur = self.element.find('option').filter(function() {
              var elem = $(this),
                attr = elem.attr('value');
              return elem.text() === val || (attr && attr.replace('"','/quot/') === val);
            });
          }

          //Select the clicked item
          if (cur.is(':disabled')) {
            return false;
          }

          self.selectOption(cur);

          if (self.settings.closeOnSelect) {
            self.closeList('select');
          }

          if (self.isMobile()) {
            return true;
          }

          self.activate(!self.settings.closeOnSelect);
          return true;
        }

        self.list
          .removeClass('dropdown-tall')
          .addClass(isShort ? 'dropdown-short' : '')
          .onTouchClick('list', 'li')
          .on('click.list', 'li', listItemClickHandler)
          .on('mouseenter.list', 'li', function() {
            var target = $(this);

            if (target.is('.separator, .group-label')) {
              return;
            }

            self.list.find('li').removeClass('is-focused');
            target.addClass('is-focused');
          });

        // Some list-closing events are on a timer to prevent immediate list close
        // There would be several things to check with a setTimeout, so this is done with a CSS
        // class to keep things a bit cleaner
        setTimeout(function delayedListCloseEvents() {
          self.list.addClass('is-closable');
        }, 100);

        // Is the jQuery Element a component of the current Dropdown list?
        function isDropdownElement(target) {
          return target.closest('.dropdown, .multiselect').length > 0 ||
            target.closest('.dropdown-list').length > 0 ||
            self.touchmove === true;
        }

        // Triggered when the user scrolls the page.
        // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list
        function scrollDocument(e) {
          if (touchPrevented || isDropdownElement($(e.target))) {
            return;
          }
          self.closeList('cancel');
        }

        // Triggered when the user clicks anywhere in the document
        // Will not close the list if the clicked target is anywhere inside the dropdown list.

        function clickDocument(e) {
          var target = $(e.target);
          if (touchPrevented || (isDropdownElement(target) && !target.is('.icon'))) {
            e.preventDefault();

            touchPrevented = false;
            return;
          }

          self.closeList('cancel');
        }

        function touchStartCallback(e) {
          touchPrevented = false;

          pos = {
            x: e.originalEvent.touches[0].pageX,
            y: e.originalEvent.touches[0].pageY
          };

          $(document).on('touchmove.dropdown', function touchMoveCallback(e) {
            var newPos = {
              x: e.originalEvent.touches[0].pageX,
              y: e.originalEvent.touches[0].pageY
            };

            if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
                (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
              touchPrevented = true;
            }
          });
        }

        function touchEndCallback(e) {
          $(document).off('touchmove.dropdown');
          e.preventDefault();

          if (touchPrevented) {
            return false;
          }

          clickDocument(e);
        }

        // Need to detect whether or not scrolling is happening on a touch-capable device
        // The dropdown list should not close on mobile if scrolling is occuring, but should close
        // if the user is simply tapping outside the list.
        $(document)
          .on('touchstart.dropdown', touchStartCallback)
          .on('touchend.dropdown touchcancel.dropdown', touchEndCallback)
          .on('click.dropdown', clickDocument);

        var parentScroll = self.element.closest('.scrollable').length ? self.element.closest('.scrollable') : $(document);
        parentScroll = self.element.closest('.scrollable-y').length ? self.element.closest('.scrollable-y') : parentScroll;
        parentScroll.on('scroll.dropdown', scrollDocument);

        $('body').on('resize.dropdown', function() {
          self.position();

          // in desktop environments, close the list on viewport resize
          if (window.orientation === undefined) {
            self.closeList('cancel');
          }
        });

        // In mobile environments, close the list on an orientation change.
        // Don't do this on mobile against a resize because of the software keyboard's potential
        // to cause a "resize" event to fire.
        if (window.orientation !== undefined) {
          $(window).on('orientationchange.dropdown', function() {
            self.closeList('cancel');
          });
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }
      },

      /**
       * Set size and positioning of the list
       * @private
       */
      position: function() {
        var self = this,
          positionOpts = {
            parentXAlignment: 'left',
            placement: 'bottom',
            strategies: ['flip', 'shrink-y']
          };

        function dropdownAfterPlaceCallback(e, placementObj) {
          // Turn upside-down if flipped to the top of the pseudoElem
          if (placementObj.wasFlipped === true) {
            self.list.addClass('is-ontop');
            self.listUl.prependTo(self.list);
          }

          // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input
          var ulHeight = parseInt(window.getComputedStyle(self.listUl[0]).height),
            listHeight = parseInt(window.getComputedStyle(self.list[0]).height),
            searchInputHeight = 34;
          if (ulHeight + searchInputHeight > listHeight) {
            self.listUl[0].style.height = (listHeight - searchInputHeight) + 'px';
          }

          return placementObj;
        }

        // Reset styles that may have been appended to the list
        this.list[0].removeAttribute('style');
        this.listUl[0].removeAttribute('style');

        var parentElement = this.pseudoElem;
        if (this.isInGrid) {
          parentElement = this.element.closest('.datagrid-cell-wrapper');
        }

        // If the list would end up being wider parent,
        // use the list's width instead of the parent's width
        var parentElementStyle = window.getComputedStyle(parentElement[0]),
          parentElementBorderWidth = parseInt(parentElementStyle.borderLeftWidth) * 2,
          parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth) + parentElementBorderWidth),
          listDefaultWidth, useParentWidth;

        // Temporarily shrink the value of the search input, and compare the size of the list to
        // the parent element.
        this.searchInput[0].style.cssText = 'width: '+ parentElementWidth +'px !important';
        listDefaultWidth = Math.round(this.list.width());
        useParentWidth = listDefaultWidth <= parentElementWidth;
        this.searchInput[0].style.width = '';

        // Add parent info to positionOpts
        positionOpts.parent = parentElement;
        positionOpts.useParentWidth = useParentWidth;

        // use negative height of the pseudoElem to get the Dropdown list to overlap the input.
        positionOpts.y = parseInt(parentElementStyle.height + parentElementStyle.borderTopWidth + parentElementStyle.borderBottomWidth) * -1;
        if (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11') {
          positionOpts.y = (positionOpts.y * 2);
        }

        this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
        this.list.data('place').place(positionOpts);
      },

      // Alias that works with the global "closeChildren" method.  See "js/lifecycle.js"
      close: function() {
        return this.closeList('cancel');
      },

      //Close list and detach events
      closeList: function(action) {
        if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
          return;
        }

        if (!this.inputTimer()) {
          return;
        }

        if (this.touchmove) {
          this.touchmove = false;
        }

        this.filterTerm = '';
        this.searchInput.off('keydown.dropdown keypress.dropdown keypress.dropdown');

        this.list
          .off('click.list touchmove.list touchend.list touchcancel.list mousewheel.list mouseenter.list')
          .remove();

        this.pseudoElem
          .removeClass('is-open')
          .attr('aria-expanded', 'false');

        this.searchInput
          .removeAttr('aria-activedescendant');

        $(document)
          .off('click.dropdown scroll.dropdown touchmove.dropdown touchend.dropdown touchcancel.dropdown');

        $('body').off('resize.dropdown');
        $(window).off('orientationchange.dropdown');
        this.element.trigger('listclosed', action);
        this.activate();
        this.list = null;
        this.searchInput = null;
        this.listUl = null;
      },

      //Set option into view
      scrollToOption: function(current) {
        var self = this;
        if (!current) {
          return;
        }
        if (current.length === 0) {
          return;
        }
        // scroll to the currently selected option
        self.listUl.scrollTop(0);
        self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
      },

      //Blur and Close List
      handleBlur: function() {
        var self = this;

        if (this.isOpen()) {
          this.timer = setTimeout(function() {
            self.closeList('cancel');
          }, 40);
        }

        return true;
      },

      // returns true if the field is attempting to load via AJAX.
      isLoading: function() {
        return this.element.is('.is-loading') &&  this.element.is('.is-blocked') ;
      },

      // Return true/false if the list is open
      isOpen: function() {
        return (this.list && this.list.is(':visible')) ? true : false;
      },

      // Hide or Show list
      toggleList: function() {
        if (this.isOpen() || this.isLoading()) {
          this.closeList('cancel');
          return;
        }
        this.open();
      },

      highlightOption: function(listOption, noScroll) {
        if (!listOption) {
          return listOption;
        }

        if (listOption.length === 0) {
          listOption = this.list.find('.dropdown-option').eq(0);
        }

        // Get corresponding option from the list
        var option = this.element.find('option[value="' + listOption.attr('data-val') + '"]');

        if (option.hasClass('.is-disabled') || option.is(':disabled')) {
          return;
        }

        if (this.isOpen()) {
          this.list.find('.is-focused').removeClass('is-focused').attr({'tabindex':'-1'});
          if (!option.hasClass('clear')) {
            listOption.addClass('is-focused').attr({'tabindex': '0'});
          }

          // Set activedescendent for new option
          //this.pseudoElem.attr('aria-activedescendant', listOption.attr('id'));
          this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));

          if (!noScroll || noScroll === false || noScroll === undefined) {
            this.scrollToOption(listOption);
          }
        }

        return;
      },

      unhighlightOptions: function(listOptions, noScroll) {
        if (!listOptions || !listOptions.length) {
          listOptions = this.list.find('.is-selected');
        }

        listOptions.removeClass('is-focused').attr({'tabindex': '-1'});

        this.searchInput.removeAttr('aria-activedescendant');

        if (!noScroll || noScroll === false || noScroll === undefined) {
          this.scrollToOption(listOptions.first());
        }
      },

      /**
       * Convenience method for running _selectOption()_ on a set of list options.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @param {Array / jQuery[]} options - incoming options
       * @param {Boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on each list item.
       */
      selectOptions: function(options, noTrigger) {
        // Use a jQuery selector if the incoming options are inside an array
        if (Array.isArray(options)) {
          options = $(options);
        }

        var self = this;
        options.each(function() {
          self.selectOption($(this), noTrigger);
        });
      },

      /**
       * Select an option and conditionally trigger events.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @param {jQuery} option - the incoming option
       * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on the list item.
       */
      selectOption: function(option, noTrigger) {
        if (!option) {
          return option;
        }
        var li;
        if (option.is('li')) {
          li = option;
          option = this.element.find('option[value="' + option.attr('data-val') + '"]');

          //Try matching the option's text if 'cur' comes back empty.
          //Supports options that don't have a 'value' attribute.
          if (option.length === 0) {
            option = this.element.find('option').filter(function() {
              return $(this).text() === li.attr('data-val');
            });
          }
        }

        var value = option.val();
        if (!option) {
          return;
        }

        if (!li && value) {
          li = this.listUl.find('li[data-val="'+ value.replace('"', '/quot/') +'"]');
        }

        if (option.hasClass('is-disabled') || option.is(':disabled')) {
          return;
        }

        var code = option.val(),
          val = this.element.val(),
          oldText = this.pseudoElem.text(),
          text = '',
          trimmed = '',
          clearSelection = false,
          isAdded = true; // Sets to false if the option is being removed from a multi-select instead of added

        if (option.hasClass('clear') || code === '') {
          clearSelection = true;
        }

        if (this.settings.multiple) {
          // Working with a select multiple allows for the "de-selection" of items in the list
          if (!val) {
            val = [];
          }
          if ($.inArray(code, val) !== -1) {
            val = $.grep(val, function(optionValue) {
              return optionValue !== code;
            });
            li.removeClass('is-selected');
            this.previousActiveDescendant = undefined;
            isAdded = false;
          } else {
            if (!isNaN(this.settings.maxSelected) && this.element.find('option:selected').length >= this.settings.maxSelected) {
              return;
            }

            val = typeof val === 'string' ? [val] : val;
            val.push(code);
            li.addClass('is-selected');
            this.previousActiveDescendant = option.val();
          }

          var newOptions = this.element.find('option').filter(function() {
            return $.inArray($(this)[0].value, val) !== -1;
          });
          text = this.getOptionText(newOptions);
        } else {
          // Working with a single select
          val = code;
          this.listUl.find('li.is-selected').removeClass('is-selected');
          if (!clearSelection) {
            li.addClass('is-selected');
          }
          this.previousActiveDescendant = option.val();
          text = option.text();
        }
        if (!clearSelection) {
          this.element.find('option').each(function () {
            if (this.value === code) {
              this.selected = true;
              return false;
            }
          });
        }
        // If we're working with a single select and the value hasn't changed, just return without
        // firing a change event
        if (text === oldText) {
          return;
        }

        // Change the values of both inputs and swap out the active descendant
        if (!clearSelection) {
          this.pseudoElem.find('span').text(text);
          this.searchInput.val(text);
        } else {
          this.pseudoElem.find('span').text('');
          this.searchInput.val('');
        }

        if (this.element.attr('maxlength')) {
          trimmed = text.substr(0, this.element.attr('maxlength'));
          this.pseudoElem.find('span').text(trimmed);
          this.searchInput.val(trimmed);
        }

        // Set the new value on the <select>
        this.element.val(val);

        // Fire the change event with the new value if the noTrigger flag isn't set
        if (!noTrigger) {
          this.element.trigger('change').triggerHandler('selected', [option, isAdded]);
        }

        // If multiselect, reset the menu to the unfiltered mode
        if (this.settings.multiple) {
          if (this.list.hasClass('search-mode')) {
            this.resetList();
          }
          this.activate(true);
        }

        this.setBadge(option);
      },

      setBadge: function (option) {
        //Badge Support
        if (this.badges) {
          var badge = this.element.parent().find('.badge');

          if (badge.length === 0) {
            this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
            badge = this.element.parent().find('.badge');
          }

          badge.attr('class', 'badge ' + (option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07'))
            .text(option.attr('data-badge'));
        }
      },

      // Execute the source ajax option
      callSource: function(callback) {
        var self = this, searchTerm = '';

        if (this.settings.source) {
          this.isFiltering = false;

          var sourceType = typeof this.settings.source,
            response = function (data, isManagedByTemplate) {
            //to do - no results back do not open.
            var list = '',
              val = self.element.val();

            function replaceDoubleQuotes(content) {
              return content.replace('"', '\'');
            }

            function buildOption(option) {
              if (option === null || option === undefined) {
                return;
              }

              var isString = typeof option === 'string',
                stringContent = option;

              if (isString) {
                option = {
                  value: stringContent
                };
              }
              option.value = replaceDoubleQuotes(option.value);

              if (option.id !== undefined) {
                if (!isNaN(option.id)) {
                  option.id = '' + option.id;
                }
                option.id = replaceDoubleQuotes(option.id);
              }

              if (option.label !== undefined) {
                option.label = replaceDoubleQuotes(option.label);
              }

              if (!option.selected && option.value === val) {
                option.selected = true;
              }

              list += '<option' + (option.id === undefined ? '' : ' id="' + option.id + '"') +
                        ' value="' + option.value + '"' +
                        (option.selected ? ' selected ' : '') +
                      '>'+ (option.label !== undefined ? option.label : option.value !== undefined ? option.value : '') + '</option>';
            }

            // If the incoming dataset is different than the one we started with,
            // replace the contents of the list, and rerender it.
            if (!self.isFiltering && !Soho.utils.equals(data, self.dataset)) {
              self.dataset = data;

              if (!isManagedByTemplate) {
                self.element.empty();
                for (var i=0; i < data.length; i++) {
                  var opts;

                  if (data[i].group) {
                    opts = data[i].options;
                    list += '<optgroup label="' + data[i].group + '">';
                    for (var ii = 0; ii < opts.length; ii++) {
                      buildOption(opts[ii]);
                    }
                    list += '</optgroup>';
                  } else {
                    buildOption(data[i]);
                  }
                }

                self.element.append(list);
              }
              self.updateList();
            }

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [searchTerm, data]);
            callback();
            return;
          };

          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart');

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            this.settings.source(response, searchTerm, this.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
            response(sourceData);
          } else {
            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = this.settings.source.toString(),
              request = $.getJSON(sourceURL);

            request.done(function(data) {
              response(data);
            }).fail(function() {
              response([]);
            });
          }

          return true;
        }
        return false;
      },

      /**
       * External Facing function to set value by code - Depricated set on select and trigger updated.
       *
       * @param {String} code - The value to match and set on the value element.
       */
      setCode: function(code) {
        var self = this,
          doSetting = function ()  {
            self.element.val(code);
            self.updated();
          };

        if (!self.callSource(doSetting)) {
          doSetting();
        }
      },

      isMobile: function() {
        return ['ios', 'android'].indexOf(Soho.env.os.name) > -1;
      },

      isListClosable: function() {
        return this.list.hasClass('is-closable');
      },

      /**
       * Disable the input element.
       */
      disable: function() {
        this.element
          .prop('disabled', true)
          .prop('readonly', false);

        if (this.pseudoElem.is($(document.activeElement))) {
          this.pseudoElem.blur();
        }

        this.pseudoElem
          .addClass('is-disabled')
          .removeClass('is-readonly')
          .attr('tabindex', '-1')
          .prop('readonly', false)
          .prop('disabled', true);
        this.closeList('cancel');
      },

      /**
      * Returns true if the dropdown is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Enable the input element.
       */
      enable: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', false);
        this.pseudoElem
          .prop('disabled', false)
          .prop('readonly', false)
          .attr('tabindex', '0')
          .removeClass('is-disabled')
          .removeClass('is-readonly');
      },

      /**
       * Make the input element readonly.
       */
      readonly: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', true);
        this.pseudoElem
          .removeClass('is-disabled')
          .addClass('is-readonly')
          .attr('tabindex', '0')
          .prop('disabled', false)
          .prop('readonly', true);
        this.closeList('cancel');
      },

      // Triggered whenever the plugin's settings are changed
      updated: function() {
        this.closeList('cancel');

        // Update the 'multiple' property
        if (this.settings.multiple && this.settings.multiple === true) {
          this.element.prop('multiple', true);
        } else {
          this.element.prop('multiple', false);
        }

        // update "readonly" prop
        if (this.element.prop('readonly') === true) {
          this.readonly();
        } else {
          this.pseudoElem.removeClass('is-readonly');
        }

        // update "disabled" prop
        this.pseudoElem[ this.element.prop('disabled') ? 'addClass' : 'removeClass' ]('is-disabled');

        // update the list and set a new value, if applicable
        this.updateList();
        this.setValue();

        this.element.trigger('has-updated');

        return this;
      },

      /**
       * Tear down events and restore to default.
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.closeList('cancel');
        this.label.remove();
        this.pseudoElem.off().remove();
        this.icon.remove();
        this.wrapper.remove();
        this.listfilter.destroy();
        this.element.removeAttr('style');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Dropdown#events
       * @param {Object} listopened  &nbsp;-&nbsp; Fires as the calendar popup is opened
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires as the calendar popup is closed
       * @param {Object} change  &nbsp;-&nbsp; Fires after the value in the input is changed by any means.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       *
       */
      handleEvents: function() {
        var self = this;

        this.pseudoElem.on('keydown.dropdown', function(e) {
          self.ignoreKeys($(this), e);
          self.handleKeyDown($(this), e);
        }).on('keypress.dropdown', function(e) {
          if (e.keyCode === 9) {
            return;
          }
          self.ignoreKeys($(this), e);

          if (!self.settings.noSearch) {
            self.toggleList();
          }
          self.handleAutoComplete(e);
        }).on('click.dropdown', function(e) {
          e.stopPropagation();
        }).on('mouseup.dropdown', function(e) {
          if (e.button === 2) {
            return;
          }
          self.toggleList();
        }).on('touchend.dropdown touchcancel.dropdown', function(e) {
          e.stopPropagation();
          self.toggleList();
          e.preventDefault();
        });

        self.element.on('activated.dropdown', function () {
          self.label.trigger('click');
        }).on('updated.dropdown', function (e) {
          e.stopPropagation();
          self.updated();
        }).on('openlist.dropdown', function() {
          self.toggleList();
        });

        //for form resets.
        self.element.closest('form').on('reset.dropdown', function() {
          setTimeout(function () {
            self.element.triggerHandler('updated');
          }, 1);
        });

        //Handle Label click
        this.label.onTouchClick().on('click', function () {
          self.pseudoElem.focus();
        });

      }

    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, settings, instance.settings);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Dropdown(this, settings));
      }
    });
  };


  $.fn.drag = function(options) {
    //TODO: Resize: http://stackoverflow.com/questions/8258232/resize-an-html-element-using-touches
    // Similar: https://github.com/desandro/draggabilly
    'use strict';

    // Settings and Options
    var pluginName = 'drag',
      defaults = {
        axis: null,
        clone: false,
        cloneCssClass: 'is-clone',
        clonePosIsFixed: false,
        cloneAppendTo: null,
        containment: false,
        obstacle: false,
        containmentOffset: {left: 0, top: 0}
      },
      settings = $.extend({}, defaults, options);

    /**
    * Drag/Drop functions with touch support.
    *
    * @class Drag
    * @param {String} axis  &nbsp;-&nbsp; Constrains dragging to either axis. Possible values: null, 'x', 'y'
    * @param {Boolean} clone  &nbsp;-&nbsp;  Set to true to clone the object to drag. In many situations this is needed to break out of layout.
    * @param {String} cloneCssClass  &nbsp;-&nbsp; Css class added to clone element (defaults to is-clone)
    * @param {Boolean} clonePosIsFixed  &nbsp;-&nbsp; if true cloned object will use css style "position: fixed"
    * @param {String} cloneAppendTo  &nbsp;-&nbsp; Selector to append to for the clone ['body'|'parent'|'jquery object'] default:'body'
    * @param {Boolean} containment  &nbsp;-&nbsp; Constrains dragging to within the bounds of the specified element or region. Possible values: "parent", "document", "window".
    * @param {String} obstacle  &nbsp;-&nbsp; jQuery Selector of object(s) that you cannot drag into,
    * @param {String} containmentOffset  &nbsp;-&nbsp; How close to the containment object should we be allowed to drag in position form. `{left: 0, top: 0}`
    *
    */
    function Drag(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Drag.prototype = {

      init: function() {
        this.handleEvents();
      },

      //Trigger events and remove clone
      finish: function (left, top) {
        var pos = {top: top, left: left};

        this.element.off('mouseup.draggable');
        $(document).off('mousemove.draggable mouseup.draggable');

        this.element.trigger('dragend', pos);
        this.element.removeClass('is-dragging');

        if (this.clone) {
          if (settings.axis === 'x') {
            delete pos.top;
          }

          if (settings.axis === 'y') {
            delete pos.left;
          }
          //this.element.css(pos);
          this.clone.remove();
          this.clone = null;
        }

        //Clear Cached Sizes
        if (this.obstacle) {
          this.obstacle = null;
        }
        if (this.upperYLimit) {
          this.upperYLimit = null;
        }
        if (this.upperXLimit) {
          this.upperXLimit = null;
        }
        $('body').removeClass('disable-select');
      },

      //Move the object from the event coords
      move: function(left, top) {
        var self = this;

        var css = {
          left: left,
          top: top
        };

        //X-Y Axis
        if (settings.axis === 'x') {
          delete css.top;
        }

        if (settings.axis === 'y') {
          delete css.left;
        }

        if (settings.containment) {

          if (settings.containment === 'parent') {
            this.container = this.element.parent();
          } else if (settings.containment === 'window') {
            this.container = $(window);
          } else if (settings.containment === 'container') {
            this.container = this.element.closest('.page-container');
          } else {
            this.container = $(document);
          }

          if (!this.upperXLimit) {
            this.upperXLimit = this.container.width() - this.element.outerWidth() + settings.containmentOffset.left;
          }
          if (!this.upperYLimit) {
            this.upperYLimit = this.container.height() - this.element.outerHeight() + settings.containmentOffset.top;
          }
          if (css.top > this.upperYLimit) {
            css.top = this.upperYLimit;
          }

          if (css.left > this.upperXLimit) {
            css.left = this.upperXLimit;
          }

          if (css.top < 0) {
            css.top = 0;
          }

          if (css.left < 0) {
            css.left = 0;
          }

          if (settings.containment === 'container' && css.left <= 1) {
            css.left = 1;
          }
        }

        if (settings.obstacle) {
          var elemOffset = (this.clone ? this.clone.offset() : this.element.offset()),
            elemWidth = (this.clone ? this.clone.outerWidth() : this.element.outerWidth()),
            movingRight = css.left > elemOffset.left;

          // Caching this so drag is not jaggie
          if (!this.obstacle) {
            this.obstacle = $(settings.obstacle).not(this.element);
            var obstacleOffset = $(this.obstacle).offset();

            this.constraints = {
              top: obstacleOffset.top,
              left: obstacleOffset.left,
              bottom: obstacleOffset.top + this.obstacle.outerHeight(),
              right: obstacleOffset.left + this.obstacle.outerWidth()
            };
          }

          if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
            css.left = this.constraints.right;
          }

          if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
            css.left = (this.constraints.left - this.obstacle.outerWidth());
          }

          //TODO: Moving Down
        }

        var applyCssStyle = function(el, css, prop) {
          if (typeof css[prop] !== 'undefined') {
            el[0].style[prop] = css[prop] +'px';
          }
        };
        applyCssStyle((this.clone || this.element), css, 'top');
        applyCssStyle((this.clone || this.element), css, 'left');

        this.element.trigger('drag', css);
      },

      /**
      * Detach all functionality and events.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Drag#events
       * @param {Object} dragstart  &nbsp;-&nbsp; When the dragging is initiated. Use this to customize/style the drag/drop objects in the DOM.
       * @param {Object} drag  &nbsp;-&nbsp; Fires (many times) while dragging is occuring. Use this for DOM feedback but be careful about what you do in here for performance.
       * @param {Object} dragend  &nbsp;-&nbsp; Fires after the drag is completed. Use this to remove / set drag feedback off.
       *
       */
      handleEvents: function() {
        var self = this;
        self.offset = null;

        //Touch and Drag Support
        self.element.attr('draggable', false);

        if ('onpointerdown' in window || 'onmspointerdown' in window) {
          // TODO: Setup Pointer Events for IE10/11 - pointerdown MSPointerDown, pointermove MSPointerMove, pointerup MSPointerUp
        } else {

          //Touch-only Drag Support
          self.element.on('touchstart.draggable gesturestart.draggable', function(e) {
            var pos = $(this).position(),
                orig = e.originalEvent;

            self.offset = {
              x:  orig.changedTouches[0].pageX - pos.left,
              y:  orig.changedTouches[0].pageY - pos.top
            };

            self.originalPos = pos;
            self.element.addClass('is-dragging');
            self.element.trigger('dragstart', pos);
          })

          // Move
          .on('touchmove.draggable gesturechange.draggable', function(e) {
            e.preventDefault();
            var orig = e.originalEvent;

            // do now allow two touch points to drag the same element
            if (orig.targetTouches.length > 1) {
              return;
            }
            self.move(orig.changedTouches[0].pageX - self.offset.x, orig.changedTouches[0].pageY - self.offset.y);
          })

          //Finish Touch Dragging
          .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
            e.preventDefault();
            var touch = e.originalEvent.changedTouches[0];
            self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
          });

        }

        // Always bind mousedown in either scenario, in the event that a mouse is used
        self.element.on('mousedown.draggable', function(e) {
          e.preventDefault();

          var pos = settings.clonePosIsFixed ?
            self.element[0].getBoundingClientRect() : self.element.position();

          //Save offset
          self.offset = {
            x: e.pageX - pos.left,
            y: e.pageY - pos.top
          };

          self.originalPos = pos;

          //Prevent Text Selection
          $('body').addClass('disable-select');

          //Handle Mouse Press over draggable element
          $(document).on('mousemove.draggable', function (e) {
            e.preventDefault();
            self.move(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Handle Mouse release over draggable element close out events and trigger
          $(document).on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          self.element.on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Trigger dragging
          //Clone
          if (!self.clone && settings.clone) {
            self.clone = self.element.clone(true);
            if (settings.cloneAppendTo === 'parent') {
              settings.cloneAppendTo = self.element.parent();
            }
            self.clone
              .addClass(settings.cloneCssClass)
              .appendTo(settings.cloneAppendTo || 'body');

          }

          self.element.addClass('is-dragging');
          self.element.trigger('dragstart', [pos, self.clone]);
        });

      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Drag(this, settings));
      }
    });
  };


  $.fn.editor = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'editor',
      defaults = {
        buttons: {
          editor: [
            'header1', 'header2',
            'separator', 'bold', 'italic', 'underline', 'strikethrough',
            'separator', 'foreColor', 'backColor',
            'separator', 'justifyLeft', 'justifyCenter', 'justifyRight',
            'separator', 'quote', 'orderedlist', 'unorderedlist',
            'separator', 'anchor',
            'separator', 'image',
            'separator', 'source'
          ],
          source: [
            'visual'
          ]
        },
        excludeButtons: {
          editor: ['backColor'],
          source: []
        },
        delay: 200,
        firstHeader: 'h3',
        secondHeader: 'h4',
        placeholder: null,
        pasteAsPlainText: false,
        // anchor > target: 'Same window'|'New window'| any string value
        anchor: {url: 'http://www.example.com', class: 'hyperlink', target: 'New window'},
        image: {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}
      },
      settings = $.extend({}, defaults, options);

    /**
    * The Editor Component is displays and edits markdown.
    *
    * @class Editor
    * @param {String} firstHeader  &nbsp;-&nbsp; Allows you to set if the first header inserted is a h3 or h4 element. You should set this to match the structure of the parent page for accessibility
    * @param {Boolean} secondHeader  &nbsp;-&nbsp; Allows you to set if the second header inserted is a h3 or h4 element. You should set this to match the structure of the parent page for accessibility
    * @param {String} productName  &nbsp;-&nbsp; Additional product name information to display
    * @param {String} pasteAsPlainText  &nbsp;-&nbsp; If true, when you paste into the editor the element will be unformatted to plain text.
    * @param {String} anchor  &nbsp;-&nbsp; Info object to populate the link dialog defaulting to `{url: 'http://www.example.com', class: 'hyperlink', target: 'New window'},`
    * @param {String} image  &nbsp;-&nbsp; Info object to populate the image dialog defaulting to ` {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}`
    */
    function Editor(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);

      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Editor.prototype = {

      init: function() {
        this.isIE = $('html').is('.ie');
        this.isMac = $('html').is('.is-mac');
        this.isIeEdge = $('html').is('.ie-edge');
        this.isFirefox = $('html').is('.is-firefox');
        this.parentElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'];
        this.id = $('.editor-toolbar').length + 1;
        this.container = this.element.parent('.field, .field-short').addClass('editor-container');
        settings.anchor.defaultUrl = settings.anchor.url;
        settings.anchor.defaultClass = settings.anchor.class;
        settings.anchor.defaultTargetText = settings.anchor.target;

        settings.anchor.targets = {
          'Same window': '',
          'New window': '_blank'
        };
        $.each(settings.anchor.targets, function(key, val) {
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            settings.anchor.target = val;
            settings.anchor.defaultTarget = val;
          }
        });
        if (!settings.anchor.defaultTarget) {
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            settings.anchor.defaultTarget = settings.anchor.target;
          } else {
            settings.anchor.defaultTargetText = 'Same window';
            settings.anchor.defaultTarget = settings.anchor.targets[settings.anchor.defaultTargetText];
          }
        }
        return this.setup();
      },

      setup: function () {
        this.isActive = true;
        this.modals = {};
        this.initElements()
          .bindSelect()
          .bindPaste()
          .setPlaceholders()
          .bindWindowActions()
          .setupKeyboardEvents()
          .onPasteTriggered();
      },

      initElements: function () {
        var i,
          elem = this.element;

        //Make it an editor
        elem.attr({'contentEditable': true, 'aria-multiline': true, 'role': 'textbox'});

        //Bind functionality for Pre elements. We dont use this yet but could if we want to edit code blocks.
        elem.attr('data-editor', true);
        this.bindParagraphCreation(i).bindTab(i);

        this.initToolbar()
          .bindButtons()
          .bindModals()
          .bindAnchorPreview();

        //Build the textarea that will be used as source view and for content serialization
        this.initTextarea();
        return this;
      },

      // Returns true if the source view is currently active.
      sourceViewActive: function() {
        return this.element.hasClass('source-view-active');
      },

      //Bind Events for the place holder
      setPlaceholders: function () {
        var self = this;

        self.element.on('blur.editor', function () {
          self.togglePlaceHolder();
        }).on('keypress', function () {
          self.togglePlaceHolder();
        });

        self.togglePlaceHolder();
        return this;
      },

      togglePlaceHolder: function () {
        var self = this.element;

        if (self.text().trim() === '') {
          self.addClass('editor-placeholder');
        } else {
          self.removeClass('editor-placeholder');
        }
      },

      // Returns the currently visible element - either the main editor window, or the source-view textarea
      getCurrentElement: function() {
        return this.sourceViewActive() ? this.textarea : this.element;
      },

      bindParagraphCreation: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keyup.editor', function (e) {
          var node = self.getSelectionStart(),
              tagName;

          if (node && node.getAttribute('data-editor') && node.children.length === 0) {
            document.execCommand('formatBlock', false, 'p');
          }

          if (e.which === 13) {
            node = self.getSelectionStart();
            tagName = node.tagName.toLowerCase();

            if (tagName !== 'li' && !self.isListItemChild(node)) {
              if (!e.shiftKey) {
                  document.execCommand('formatBlock', false, 'p');
              }
              if (tagName === 'a') {
                  document.execCommand('unlink', false, null);
              }
            }
          }
        });
        return this;
      },

      bindTab: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keydown.editor', function (e) {
          if (e.which === 9) {
            // Override tab only for pre nodes
            var tag = self.getSelectionStart().tagName.toLowerCase();
            if (tag === 'pre') {
              e.preventDefault();
              document.execCommand('insertHtml', null, '    ');
            }
            // Tab to indent list structures!
            if ( tag === 'li' ) {
              // If Shift is down, outdent, otherwise indent
              if ( e.shiftKey ) {
                document.execCommand('outdent', e);
              } else {
                document.execCommand('indent', e);
              }
            }
          }
        });
        return this;
      },

      // Builds a fake element and gets the name of the event that will be used for "paste"
      // Used for cross-browser compatability.
      getPasteEvent: function() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input') + '.editor';
      },

      initToolbar: function () {
        if (this.toolbar) {
            return this;
        }
        this.toolbar = this.createToolbar();
        this.toolbarActions = this.toolbar;
        this.toolbar.toolbar();
        return this;
      },

      // Set excluded buttons
      setExcludedButtons: function() {
        var self = this,
          excludeButtons = function(elements, toExclude) {
            var separatorIndex = -1,
              numOfExcluded = 0;

            return elements.filter(function(x, i) {
              var r = true;
              // Exclude matching buttons but keep separator/s
              if (toExclude.indexOf(x) > -1 && x !== 'separator') {
                numOfExcluded++;
                r = false;
              }
              // Exclude extra separator/s
              else if (x === 'separator' && ((i - numOfExcluded - 1) === separatorIndex)) {
                numOfExcluded = 0;
                r = false;
              }
              if (x === 'separator') {
                separatorIndex = i;
              }
              return r;
            });
          },

          // Run only if it needs (excludeButtons)
          setButtons = function() {
            var s = self.settings,
              btns = s.buttons,
              exBtns = s.excludeButtons;
            return (self.sourceViewActive()) ?
              (exBtns && exBtns.source && exBtns.source.length ?
                excludeButtons(btns.source, exBtns.source) : btns.source) :
              (exBtns && exBtns.editor && exBtns.editor.length ?
                excludeButtons(btns.editor, exBtns.editor) : btns.editor);
          };

        return setButtons();
      },

      createToolbar: function () {
        var toolbar = $('<div class="toolbar editor-toolbar formatter-toolbar"></div>').attr('id', 'editor-toolbar-' + this.id);
        this.toolbarButtons(toolbar);
        toolbar.insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
        toolbar.find('button').tooltip();
        return toolbar;
      },

      toolbarButtons: function (toolbar) {
        var btns = this.setExcludedButtons(),
            buttonset = toolbar.find('.buttonset'),
            i, btn;

        if (!buttonset.length) {
          buttonset = $('<div class="buttonset"></div>').appendTo(toolbar);
        }

        for (i = 0; i < btns.length; i += 1) {
          btn = this.buttonTemplate(btns[i]);

          if (btn) {
            buttonset.append(btn);
          }
        }
        // Invoke colorpicker
        var cpElements = $('[data-action="foreColor"], [data-action="backColor"]', buttonset);
        cpElements.colorpicker({placeIn: 'editor'});
        $('.trigger', cpElements).off('click.colorpicker');
      },

      /**
      * Switch between source and editing toolbar.
      */
      switchToolbars: function() {
        this.destroyToolbar();

        // Rebind everything to the new element
        this.setupTextareaEvents().initToolbar().bindButtons().bindModals().bindAnchorPreview();
        this.bindSelect().bindPaste().setupKeyboardEvents();
        this.toolbar.find('button').button();
      },

      initTextarea: function() {
        var self = this;
        if (this.textarea) {
          return this;
        }
        this.textarea = this.createTextarea();

        // fill the text area with any content that may already exist within the editor DIV
        this.textarea.text(this.element.html().toString());

        this.element.on('input.editor keyup.editor', function() {
          self.textarea.val(self.element.html().toString());
        });

        this.setupTextareaEvents();
        return this.textarea;
      },

      createTextarea: function() {
        this.sourceView = $('<div></div>').attr({
          'class' : 'editor-source editable hidden',
          'id' : 'editor-source-' + this.id
        }).insertBefore(this.element);

        $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
        var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView),
          newTextareaID = 'source-textarea-' + ($('[id^="source-textarea-"]').length+1),
          labelContents = this.element.prev('.label').addClass('audible').text() + ' - HTML Source View';

        $('<label class="audible" for="'+ newTextareaID +'">'+ labelContents +'</label>').appendTo(textareaContainer);
        var textarea = $('<textarea id="'+ newTextareaID +'" class="editable"></textarea>').appendTo(textareaContainer);
        return textarea;
      },

      triggerClick: function(e, btn) {
        $('button[data-action="'+ btn +'"]', this.toolbar).trigger('click.editor');
      },

      setupKeyboardEvents: function() {
        var self = this,
          currentElement = this.getCurrentElement(),
          keys = {
            b  : 66, // {Ctrl + B} bold
            e  : 69, // {Ctrl + E} justifyCenter
            h  : 72, // {Ctrl + H} anchor
            i  : 73, // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
            l  : 76, // {Ctrl + L} justifyLeft
            bl : 55, // {Ctrl + + Shift + 7} bullet list
            n  : 56, // {Ctrl + Shift + 8} numbered list
            q  : 81, // {Ctrl + Q} blockquotes
            r  : 82, // {Ctrl + R} justifyRight
            u  : 85, // {Ctrl + U} underline
            h3 : 51, // {Ctrl + 3} h3
            h4 : 52, // {Ctrl + 4} h4
            sv : 192 // {Ctrl + ~} toggle source -or- visualview
          };

        currentElement.on('keydown.editor', function(e) {
          e = (e) ? e : window.event;
          keys.charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false);

          switch (e.ctrlKey && keys.charCode) {
            case keys.h3:
              self.triggerClick(e, 'append-' + settings.firstHeader);
              break;
            case keys.h4:
              self.triggerClick(e, 'append-' + settings.secondHeader);
              break;
            case keys.b:
              self.triggerClick(e, 'bold');
              e.preventDefault();
              break;
            case keys.e:
              self.triggerClick(e, 'justifyCenter');
              break;
            case keys.h:
              self.triggerClick(e, 'anchor');
              e.preventDefault();
              break;
            case keys.i:
              self.triggerClick(e, e.shiftKey ? 'image' : 'italic');
              if (!e.shiftKey) {
                e.preventDefault();
              }
              break;
            case keys.bl:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertunorderedlist');
              }
              e.preventDefault();
              break;
            case keys.l:
              if (!e.shiftKey) {
                self.triggerClick(e, 'justifyLeft');
              }
              e.preventDefault();
              break;
            case keys.n:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertorderedlist');
              }
              break;
            case keys.q:
              self.triggerClick(e, 'append-blockquote');
              break;
            case keys.r:
              self.triggerClick(e, 'justifyRight');
              break;
            case keys.u:
              self.triggerClick(e, 'underline');
              e.preventDefault();
              break;
            case keys.sv:
              self.triggerClick(e, currentElement === self.element ? 'source' : 'visual');
              break;
          }
        });

        // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)
        self.element.on('mousedown.editor', 'a', function(e) {
          var href = $(this).attr('href');
          if(!self.isFirefox && ((self.isMac && e.metaKey) || (!self.isMac && e.ctrlKey))) {
            window.open(href, '_blank');
            e.preventDefault();
          }
        });

        return self;
      },

      setupTextareaEvents: function() {
        var self = this;
        // Adjust line numbers on input
        this.textarea.on('input.editor keyup.editor', function() {
          if (!(self.sourceView.hasClass('hidden'))) {
            self.adjustSourceLineNumbers();
          }
        }).on('focus.editor', function() {
          self.sourceView.addClass('is-focused');
        }).on('blur.editor', function(e) {
          self.sourceView.removeClass('is-focused');
          self.element.empty().html($.sanitizeHTML(self.textarea.val()));

          if (self.element.data('validate')) {
            self.element.data('validate').validate(self.element, true, e);
          }
        });

        return this;
      },

      adjustSourceLineNumbers: function() {

        var container = this.textarea.parent(),
          lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight),
          YPadding = (this.textarea.innerHeight() - this.textarea.height());

        this.textarea[0].style.height = '';

        var scrollHeight = this.textarea[0].scrollHeight,
          lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight),
          numberList = this.sourceView.find('.line-numbers'),
          lastIdx = numberList.find('li').length,
          list = '',
          i = 0;

        if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
          if (!this.lineNumbers) {
            // Build the list of line numbers from scratch
            this.lineNumbers = lineNumberCount;
            while (i < this.lineNumbers) {
              list += '<li role="presentation"><span>'+ (i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers < lineNumberCount) {
            // Add extra line numbers to the bottom
            while (i < (lineNumberCount - this.lineNumbers)) {
              list += '<li role="presentation"><span>'+ (lastIdx + i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers > lineNumberCount) {
            // Remove extra line numbers from the bottom
            i = this.lineNumbers - lineNumberCount;
            numberList.find('li').slice(-(i)).remove();
          }
          this.lineNumbers = lineNumberCount;
          container[0].style.width = 'calc(100% - ' + (numberList.outerWidth() + 1) + 'px)';
        }
        if (scrollHeight !== this.textarea[0].scrollHeight) {
          this.adjustSourceLineNumbers();
          return;
        }

        this.textarea[0].style.height = numberList[0].scrollHeight + 'px';
      },

      wrapTextInTags: function(insertedText, selectedText, action) {
        var tags,
          finalText;
        switch(action) {
          case 'bold':
            tags = ['<b>','</b>'];
            break;
          case 'italic':
            tags = ['<i>','</i>'];
            break;
          case 'underline':
            tags = ['<u>','</u>'];
            break;
          case 'strikethrough':
            tags = ['<strike>', '</strike>'];
            break;
          case 'append-blockquote':
            tags = ['<blockquote>', '</blockquote>'];
            break;
          default:
            tags = ['',''];
        }

        if (action === 'anchor') {
          var alink = $('<a href="'+ insertedText +'">' + selectedText + '</a>');

          if(settings.anchor.class && $.trim(settings.anchor.class).length) {
            alink.addClass(settings.anchor.class);
          }
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            alink.attr('target', settings.anchor.target);
          }

          finalText = alink[0].outerHTML;
        }
        else {
          finalText = tags[0] + insertedText + selectedText + tags[1];
        }
        return finalText;
      },

      insertTextAreaContent: function(text, action) {
        var el = this.textarea[0],
          val = el.value,
          sel, startPos, endPos, scrollTop;

        // Always have empty text
        text = text ? text : '';

        if (document.selection && el.tagName === 'TEXTAREA') {
          //IE textarea support
          $(el).focus();
          sel = document.selection.createRange();
          sel.text = this.wrapTextInTags(text, sel.text, action);
          $(el).focus();
        } else if (el.selectionStart || el.selectionStart === '0') {
          //MOZILLA/NETSCAPE support
          startPos = el.selectionStart;
          endPos = el.selectionEnd;
          scrollTop = el.scrollTop;
          sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
          el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
          $(el).focus();
          el.selectionStart = startPos + sel.length;
          el.selectionEnd = startPos + sel.length;
          el.scrollTop = scrollTop;
        } else {
          // IE input[type=text] and other browsers
          el.value += this.wrapTextInTags(text, el.value, action);
          $(el).focus();
          el.value = el.value;    // forces cursor to end
        }
      },

      buttonTemplate: function (btnType) {
        var buttonLabels = this.getButtonLabels(settings.buttonLabels),
          buttonTemplates = {
            'bold': '<button type="button" class="btn" title="'+ Locale.translate('ToggleBold') + '" data-action="bold" data-element="b">' + buttonLabels.bold + '</button>',
            'italic': '<button type="button" class="btn" title="'+ Locale.translate('ToggleItalic') + '" data-action="italic" data-element="i">' + buttonLabels.italic + '</button>',
            'underline': '<button type="button" class="btn underline" title="'+ Locale.translate('ToggleUnderline') + '" data-action="underline" data-element="u">' + buttonLabels.underline + '</button>',
            'strikethrough': '<button type="button" class="btn" title="'+ Locale.translate('StrikeThrough') + '" data-action="strikethrough" data-element="strike">' + buttonLabels.strikethrough + '</button>',
            'foreColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('TextColor') + '" data-action="foreColor" data-element="foreColor">' + buttonLabels.foreColor + '</button>',
            'backColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('BackgroundColor') + '" data-action="backColor" data-element="backColor">' + buttonLabels.backColor + '</button>',
            'superscript': '<button type="button" class="btn" title="'+ Locale.translate('Superscript') + '" data-action="superscript" data-element="sup">' + buttonLabels.superscript + '</button>',
            'subscript': '<button type="button" class="btn" title="'+ Locale.translate('Subscript') + '" data-action="subscript" data-element="sub">' + buttonLabels.subscript + '</button>',
            'separator': '<div class="separator"></div>',
            'anchor': '<button type="button" class="btn" title="'+ Locale.translate('InsertAnchor') + '" data-action="anchor" data-modal="editor-modal-url" data-element="a">' + buttonLabels.anchor + '</button>',
            'image': '<button type="button" class="btn" title="'+ Locale.translate('InsertImage') + '" data-action="image" data-modal="editor-modal-image" data-element="img">' + buttonLabels.image + '</button>',
            'header1': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH3') + '" data-action="append-' + settings.firstHeader + '" data-element="' + settings.firstHeader + '">' + buttonLabels.header1 + '</button>',
            'header2': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH4') + '" data-action="append-' + settings.secondHeader + '" data-element="' + settings.secondHeader + '">' + buttonLabels.header2 + '</button>',
            'quote': '<button type="button" class="btn" title="'+ Locale.translate('Blockquote') + '" data-action="append-blockquote" data-element="blockquote">' + buttonLabels.quote + '</button>',
            'orderedlist': '<button type="button" class="btn" title="'+ Locale.translate('OrderedList') + '" data-action="insertorderedlist" data-element="ol">' + buttonLabels.orderedlist + '</button>',
            'unorderedlist': '<button type="button" class="btn" title="'+ Locale.translate('UnorderedList') + '" data-action="insertunorderedlist" data-element="ul">' + buttonLabels.unorderedlist + '</button>',
            'justifyLeft': '<button type="button" class="btn" title="'+ Locale.translate('JustifyLeft') + '" data-action="justifyLeft" >' + buttonLabels.justifyLeft + '</button>',
            'justifyCenter': '<button type="button" class="btn" title="'+ Locale.translate('JustifyCenter') + '" data-action="justifyCenter">' + buttonLabels.justifyCenter + '</button>',
            'justifyRight': '<button type="button" class="btn" title="'+ Locale.translate('JustifyRight') + '" data-action="justifyRight" >' + buttonLabels.justifyRight + '</button>',
            'source': '<button type="button" class="btn" title="'+ Locale.translate('ViewSource') + '" data-action="source" >' + buttonLabels.source + '</button>',
            'visual': '<button type="button" class="btn" title="'+ Locale.translate('ViewVisual') + '" data-action="visual" >' + buttonLabels.visual + '</button>'
          };
       return buttonTemplates[btnType] || false;
      },

      getIcon: function(textName, iconName, className) {
        return '<span class="audible">'+ Locale.translate(textName) +'</span>' + $.createIcon({ classes: (className || ''), icon: iconName });
      },

      getButtonLabels: function (buttonLabelType) {
        var customButtonLabels,
          attrname,
          buttonLabels = {
            'bold': this.getIcon('Bold', 'bold'),
            'italic': this.getIcon('Italic', 'italic'),
            'underline': this.getIcon('Underline', 'underline'),
            'superscript': '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
            'subscript': '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
            'strikethrough': this.getIcon('StrikeThrough', 'strike-through'),
            'foreColor': this.getIcon('TextColor', 'fore-color'),
            'backColor': this.getIcon('BackgroundColor', 'back-color'),
            'anchor': this.getIcon('InsertAnchor', 'link'),
            'image': this.getIcon('InsertImage', 'insert-image'),
            'header1': this.getIcon('ToggleH3', 'h3'),
            'header2': this.getIcon('ToggleH4', 'h4'),
            'quote': this.getIcon('Blockquote', 'quote'),
            'orderedlist': this.getIcon('OrderedList', 'number-list'),
            'unorderedlist': this.getIcon('UnorderedList', 'bullet-list'),
            'pre': '<span aria-hidden="true"><b>0101</b></span>',
            'indent': '<span aria-hidden="true"><b>&rarr;</b></span>',
            'outdent': '<span aria-hidden="true"><b>&larr;</b></span>',
            'justifyLeft': this.getIcon('JustifyLeft', 'left-text-align'),
            'justifyCenter': this.getIcon('JustifyCenter', 'center-text'),
            'justifyRight': this.getIcon('JustifyRight', 'right-text-align'),
            'source': this.getIcon('ViewSource', 'html', 'html-icon'),
            'visual': this.getIcon('ViewSource', 'visual', 'visual-icon')
          };

        if (typeof buttonLabelType === 'object') {
          customButtonLabels = buttonLabelType;
        }
        if (typeof customButtonLabels === 'object') {
          for (attrname in customButtonLabels) {
            if (customButtonLabels.hasOwnProperty(attrname)) {
              buttonLabels[attrname] = customButtonLabels[attrname];
            }
          }
        }
        return buttonLabels;
      },

      //Show the Buttons
      activateButton: function (tag) {
        this.toolbar.find('[data-element="' + tag + '"]').addClass('is-active');
      },

      //Bind Events to Toolbar Buttons
      bindButtons: function () {
        var self = this;

        this.toolbar.on('touchstart.editor click.editor', 'button', function (e) {
          var btn = $(this),
            action = btn.attr('data-action');

          // Don't do anything if it's the More Button
          if (btn.is('.btn-actions')) {
            return;
          }

          e.preventDefault();
          self.getCurrentElement().focus();

          if (self.selection === undefined) {
            self.checkSelection();
          }

          if (!self.sourceViewActive()) {
            btn.toggleClass('is-active');
          }

          if (action) {
            self.execAction(action, e);
          }

          return false;
        });

        return this;
      },

      bindModals: function() {
        var self = this;

        self.modals = {
          url: self.createURLModal(),
          image: self.createImageModal()
        };

        $('[name="em-target"]').dropdown();

        $('#editor-modal-url, #editor-modal-image').modal()
          .on('beforeopen', function () {
            self.savedSelection = self.saveSelection();

            if ($(this).attr('id') === 'editor-modal-url') {

              if (!self.selectionRange) {
                return undefined;
              }
            }
          })
          .off('open')
          .on('open', function () {
            var isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
              id = $(this).attr('id'),
              input = $('input:first', this),
              button = $('.modal-buttonset .btn-modal-primary', this);

            $('[name="em-url"]').val(settings.anchor.url);
            $('[name="em-class"]').val(settings.anchor.class);
            $('[name="em-target"]').val(settings.anchor.target).trigger('updated');

            // $('[id="em-target-shdo"]').val($('[name="em-target"] option:selected').text());

            setTimeout(function () {
              if (isTouch && id === 'editor-modal-image') {
                button.focus();
              } else {
                input.focus().select();
              }
            }, 10);

          })
          .off('close')
          .on('close', function (e, isCancelled) {
            self.restoreSelection(self.savedSelection);

            if (isCancelled) {
              return;
            }

            //insert image or link
            if ($(this).attr('id') === 'editor-modal-url') {
              var currentLink = $(self.findElementInSelection('a', self.element[0]));
              if (currentLink.length) {
                self.updateCurrentLink(currentLink);
              } else {
                self.createLink($('[name="em-url"]', this));
              }
            } else {
              self.insertImage($('#image').val());
            }
          });

        return this;
      },

      /**
      * Function that creates the Url Modal Dialog. This can be customized by making a modal with ID `#editor-modal-url`
      */
      createURLModal: function() {
        var targetOptions = '',
          isTargetCustom = true,
          urlModal = $('#editor-modal-url');

        if (urlModal.length > 0) {
          return urlModal;
        }

        $.each(settings.anchor.targets, function(key, val) {
          targetOptions += '<option value="'+ val +'">'+ key +'</option>';
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            isTargetCustom = false;
          }
        });
        if (isTargetCustom) {
          targetOptions += '<option value="'+ settings.anchor.target +'">'+ settings.anchor.target +'</option>';
        }

        return $('<div class="modal editor-modal-url" id="editor-modal-url"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertAnchor') + '</h1>' +   //TODO: Rename to link when you get strings
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="em-url">' + Locale.translate('Url') + '</label>' +
                '<input id="em-url" name="em-url" type="text" value="'+ settings.anchor.url +'">' +
              '</div>' +
              '<div class="field">' +
                '<label for="em-class">' + Locale.translate('CssClass') + '</label>' +
                '<input id="em-class" name="em-class" type="text" value="'+ settings.anchor.class +'">' +
              '</div>' +
              '<div class="field">' +
                '<label for="em-target" class="label">' + Locale.translate('Target') + '</label>' +
                '<select id="em-target" name="em-target" class="dropdown">' +
                  targetOptions +
                '</select>' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

       /**
       * Function that creates the Image Dialog. This can be customized by making a modal with ID `#editor-modal-image`
       */
      createImageModal: function() {
        var imageModal = $('#editor-modal-image');
        if (imageModal.length > 0) {
          return imageModal;
        }
        return $('<div class="modal editor-modal-image" id="editor-modal-image"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertImage') + '</h1>' +
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="image">' + Locale.translate('Url') + '</label>' +
                '<input id="image" name="image" type="text" value="'+ settings.image.url +'">' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

      bindAnchorPreview: function () {
        this.element.find('a').tooltip({content: function() {
          return $(this).attr('href');
        }});
        return;
      },

      updateCurrentLink: function (alink) {
        var emUrl = $('[name="em-url"]').val(),
          emClass = $('[name="em-class"]').val(),
          emTarget = $('[name="em-target"]').val();

        alink.attr('href', (emUrl && $.trim(emUrl).length ? emUrl : settings.anchor.defaultUrl));
        alink.attr('class', (emClass && $.trim(emClass).length ? emClass : settings.anchor.defaultClass));

        if (emTarget && $.trim(emTarget).length) {
          alink.attr('target', emTarget);
        } else {
          alink.removeAttr('target');
        }
      },

      createLink: function (input) {
        var alink;

        //Restore Selection in the Editor and Variables
        this.restoreSelection(this.savedSelection);

        //Fix and Format the Link
        input.val(this.fixLinkFormat(input.val()));

        // Set selection ur/class/target for Link
        settings.anchor.url = input.val();
        settings.anchor.class = $('[name="em-class"]').val();
        settings.anchor.target = $('[name="em-target"]').val();

        alink = $('<a href="'+ input.val() +'">' + input.val() + '</a>');

        if(settings.anchor.class && $.trim(settings.anchor.class).length) {
          alink.addClass(settings.anchor.class);
        }
        if(settings.anchor.target && $.trim(settings.anchor.target).length) {
          alink.attr('target', settings.anchor.target);
        }

        if (this.sourceViewActive()) {
          this.insertTextAreaContent(input.val(), 'anchor');
        }
        else {
          var sel, range;

          if (!this.selection.isCollapsed) {
            //document.execCommand('createLink', false, input.val());

            //get example from: http://jsfiddle.net/jwvha/1/
            //and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
            if (window.getSelection) {
              // IE9 and non-IE
              sel = window.getSelection();
              if (sel.getRangeAt && sel.rangeCount) {
                range = sel.getRangeAt(0);
                alink.html(range + '');
                range.deleteContents();

                // Range.createContextualFragment() would be useful here but is
                // only relatively recently standardized and is not supported in
                // some browsers (IE9, for one)
                var el = document.createElement('div');
                el.innerHTML = alink[0].outerHTML;
                var frag = document.createDocumentFragment(), node, lastNode;

                while ((node = el.firstChild)) {
                  lastNode = frag.appendChild(node);
                }
                range.insertNode(frag);

                // Preserve the selection
                if (lastNode) {
                  range = range.cloneRange();
                  range.setStartAfter(lastNode);
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);
                }
              }
            }
          }
          else {
            var self = this;
            document.execCommand('insertHtml', null, alink[0].outerHTML);
            setTimeout(function () {
              self.getCurrentElement().focus();
            }, 1);
          }
          this.bindAnchorPreview();
        }
      },

      fixLinkFormat: function (value) {
        var re = /^https?:\/\//;
        if (value.match(re)) {
          return value;
        }
        return 'http://' + value;
      },

      //Setup Events For Text Selection
      bindSelect: function () {
        var self = this,
            selectionTimer = '';

        this.selectionHandler = function () {
          clearTimeout(selectionTimer);
          selectionTimer = setTimeout(function () {
            self.checkSelection();
          }, settings.delay);
        };

        var currentElement = self.getCurrentElement();

        currentElement.off('mouseup.editor keyup.editor')
          .on('mouseup.editor keyup.editor', this.selectionHandler);

        return this;
      },

      checkSelection: function () {
        var newSelection,
            selectionElement;

        if (this.selection === undefined) {
          if (this.sourceViewActive()) {
            newSelection = this.textarea.val().substring( this.textarea[0].selectionStart, this.textarea[0].selectionEnd ).toString().trim();
            this.hideToolbarActions();
            return;
          }
        }

        newSelection = window.getSelection();
        selectionElement = this.getSelectionElement();
        if (!selectionElement) {
            this.hideToolbarActions();
        } else {
          this.checkSelectionElement(newSelection, selectionElement);
        }
        return this;
      },

      getSelectionElement: function () {
        var selection = window.getSelection(),
          range, current, parent,
          result,
          getElement = function (e) {
            var localParent = e;
            try {
                while (!localParent.getAttribute('data-editor')) {
                    localParent = localParent.parentNode;
                }
            } catch (errb) {
                return false;
            }
            return localParent;
          };

        // First try on current node
        try {
          range = selection.getRangeAt(0);
          current = range.commonAncestorContainer;
          parent = current.parentNode;

          if (current.getAttribute('data-editor')) {
              result = current;
          } else {
              result = getElement(parent);
          }
          // If not search in the parent nodes.
        } catch (err) {
          result = getElement(parent);
        }
        return result;
      },

      //See if the Editor is Selected and Show Toolbar
      checkSelectionElement: function (newSelection, selectionElement) {
        var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];

        this.selection = newSelection;
        this.selectionRange = this.selection.getRangeAt(0);
        if (currentElement === selectionElement) {
          this.setToolbarButtonStates();
          return;
        }
        this.hideToolbarActions();
      },

      //See if the Editor is Selected and Show Toolbar
      setToolbarButtonStates: function () {
        var buttons = this.toolbarActions.find('button');

        buttons.removeClass('is-active');
        this.checkActiveButtons();
        return this;
      },

      checkActiveButtons: function () {
        this.checkButtonState('bold');
        this.checkButtonState('italic');
        this.checkButtonState('underline');

        var self = this,
            parentNode = this.getSelectedParentElement();

        while (parentNode.tagName !== undefined && this.parentElements.indexOf(parentNode.tagName.toLowerCase) === -1) {
          this.activateButton(parentNode.tagName.toLowerCase());

          // we can abort the search upwards if we leave the contentEditable element
          if (self.element.is(parentNode)) {
            break;
          }
          parentNode = parentNode.parentNode;
        }
      },

      checkButtonState: function(command) {
        if (!document.queryCommandState) {
          return;
        }

        if (document.queryCommandState(command)) {
          this.toolbar.find('[data-action="' + command + '"]').addClass('is-active');
        } else {
          this.toolbar.find('[data-action="' + command + '"]').removeClass('is-active');
        }
      },

      rangeSelectsSingleNode: function (range) {
        var startNode = range.startContainer;
        return startNode === range.endContainer &&
            startNode.hasChildNodes() &&
            range.endOffset === range.startOffset + 1;
      },

      getSelectedParentElement: function () {
        var selectedParentElement = null,
            range = this.selectionRange;
        if (this.rangeSelectsSingleNode(range)) {
            selectedParentElement = range.startContainer.childNodes[range.startOffset];
        } else if (range.startContainer.nodeType === 3) {
            selectedParentElement = range.startContainer.parentNode;
        } else {
            selectedParentElement = range.startContainer;
        }
        return selectedParentElement;
      },

      //Hide Toolbar
      hideToolbarActions: function () {
        if (this.toolbar !== undefined) {
          this.toolbar.removeClass('is-active');
        }
      },

      //Handle Pasted In Text
      bindPaste: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        if (!self.pasteEvent) {
          self.pasteEvent = self.getPasteEvent();
        }

        this.pasteWrapper = function (e) {

          var paste = e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData ?
            e.originalEvent.clipboardData.getData('text/plain') : // Standard
            window.clipboardData && window.clipboardData.getData ?
            window.clipboardData.getData('Text') : // MS
            false,
            paragraphs,
            html = '',
            p;

          if (self.sourceViewActive() ) {
            return this;
          }

          if (paste && !e.defaultPrevented) {
            e.preventDefault();
            paragraphs = paste.split(/[\r\n]/g);

            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    html += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }

            if (document.queryCommandSupported('insertText')) {
                document.execCommand('insertHTML', false, html);
                return false;
            } else { // IE > 7
              self.pasteHtmlAtCaret(html);
            }
          }
        };

        this.pasteWrapperHtml = function (e) {
          if (self.sourceViewActive()) {
            return this;
          }
          var types, clipboardData, pastedData,
            paste, p, paragraphs,
            getCleanedHtml = function(pastedData) {
              var i, l, attributeStripper,
                s = pastedData || '',
                badAttributes = [
                  'start','xmlns','xmlns:o','xmlns:w','xmlns:x','xmlns:m',
                  'onmouseover','onmouseout','onmouseenter','onmouseleave',
                  'onmousemove','onload','onfocus','onblur','onclick',
                  'style'
                ];

              // Remove extra word formating
              if (self.isWordFormat(s)) {
                s = self.cleanWordHtml(s);
              }

              // Remove bad attributes
              for (i = 0, l = badAttributes.length; i < l; i++) {
                attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);

                attributeStripper = new RegExp(' ' + badAttributes[i] + '=\'(.*?)\'','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);
              }

              // Remove "ng-" directives and "ng-" classes
              s = s.replace(/(ng-\w+-\w+="(.|\n)*?"|ng-\w+="(.|\n)*?"|ng-(\w+-\w+)|ng-(\w+))/g, '');

              // Remove comments
              s = s.replace(/<!--(.*?)-->/gm, '');

              // Remove extra spaces
              s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>');

              // Remove extra attributes from list elements
              s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>');

              // Remove html and body tags
              s = s.replace(/<\/?(html|body)(.*?)>/gi, '');

              // Remove header tag and content
              s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, '');

              return s;
            };

          if (e.clipboardData || e.originalEvent) {
            if (e.clipboardData && e.clipboardData.types) {
              clipboardData = e.clipboardData;
            }
            else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
              clipboardData = e.originalEvent.clipboardData;
            }
          }

          if (clipboardData && clipboardData.types) {
            types = clipboardData.types;
            // jshint undef:false
            if ((types instanceof DOMStringList && types.contains('text/html')) ||
                (types.indexOf && types.indexOf('text/html') !== -1)) {
            // jshint undef:true
              pastedData =  e.originalEvent.clipboardData.getData('text/html');
            }
          } else {
            paste = window.clipboardData.getData('Text');
            paragraphs = paste.split(/[\r\n]/g);
            pastedData = '';
            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    pastedData += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }
          }

          self.pastedData = getCleanedHtml(pastedData);

          $.when(self.element.triggerHandler('beforepaste', [{pastedData: self.pastedData}])).done(function() {
            if (self.pastedData && !e.defaultPrevented) {
              e.preventDefault();

              if (document.queryCommandSupported('insertText')) {
                  document.execCommand('insertHTML', false, self.pastedData);
                  return false;
              } else { // IE > 7
                self.pasteHtmlAtCaret(self.pastedData);
              }
            }
            self.element.triggerHandler('afterpaste', [{pastedData: self.pastedData}]);
            self.pastedData = null;
          });
          return false;
        };

        currentElement.on(self.pasteEvent, (self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml));

        return this;
      },

      pasteHtmlAtCaret: function(html) {
        var sel, range;
        if (window.getSelection) {
          // IE9 and non-IE
          sel = window.getSelection();
          if (sel.getRangeAt && sel.rangeCount) {
            range = sel.getRangeAt(0);
            range.deleteContents();

            // Range.createContextualFragment() would be useful here but is
            // only relatively recently standardized and is not supported in
            // some browsers (IE9, for one)
            var el = document.createElement('div');

            el.innerHTML = html;
            var frag = document.createDocumentFragment(), node, lastNode;
            while ( (node = el.firstChild) ) {
              lastNode = frag.appendChild(node);
            }
            range.insertNode(frag);

            // Preserve the selection
            if (lastNode) {
              range = range.cloneRange();
              range.setStartAfter(lastNode);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        } else if (document.selection && document.selection.type !== 'Control') {
          // IE < 9
          document.selection.createRange().pasteHTML(html);
        }
      },

      htmlEntities: function (str) {
        // converts special characters (like <) into their escaped/encoded values (like &lt;).
        // This allows you to show to display the string without the browser reading it as HTML.
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      },

      bindWindowActions: function () {
        var self = this,
          editorContainer = this.element.closest('.editor-container'),
          currentElement = self.getCurrentElement();

        self.element
        // Work around for Firefox with using keys was not focusing on first child in editor
        // Firefox behaves differently than other browsers
        .on('mousedown.editor', function () {
          self.mousedown = true;
        })
        .on('focus.editor', function () {
          if (self.isFirefox && !self.mousedown && self.element === currentElement) {
            self.setFocus();
          }
        })

        // Work around for Chrome's bug wrapping contents in <span>
        // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
        .on('DOMNodeInserted', function(e) {
          var target = $(e.target),
            helper = $('<b>helper</b>');

          if (e.target.tagName === 'IMG') {
            target.removeAttr('id style srcset');
          }
          else if (e.target.tagName === 'SPAN') {

            target.before(helper);
            helper.after(target.contents());
            helper.add(target).remove();
          }
        });

        editorContainer
          .on('focus.editor', '.editor, .editor-source', function () {
            var elem = $(this);

            editorContainer.addClass('is-active');
            setTimeout(function () {
              if (elem.hasClass('error')) {
                editorContainer.parent().find('.editor-toolbar').addClass('error');
                editorContainer.parent().find('.editor-source').addClass('error');
              }
            }, 100);
          })
          .on('blur.editor', '.editor, .editor-source', function() {
            editorContainer.removeClass('is-active');
            editorContainer.parent().find('.editor-toolbar').removeClass('error');
            editorContainer.parent().find('.editor-source').removeClass('error');
          });

        //Attach Label
        var label = this.element.prevAll('.label');
        for (var i = 0, l = label.length; i < l; i++) {
          label[i].style.cursor = 'default';
        }
        label.on('click.editor', function () {
          currentElement.focus();
        });
        currentElement.attr('aria-label', label.text());
        return this;
      },

      //Restore Text Selection
      restoreSelection: function(savedSel) {
        var i,
          len,
          sel = window.getSelection();

        if (!savedSel) {
          savedSel = this.savedSelection;
        }

        if (savedSel) {
          sel.removeAllRanges();
          for (i = 0, len = savedSel.length; i < len; i += 1) {
              sel.addRange(savedSel[i]);
          }
        }
      },

      //Save Text Selection
      saveSelection: function() {
        var i,
          len,
          ranges,
          sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          ranges = [];
          for (i = 0, len = sel.rangeCount; i < len; i += 1) {
              ranges.push(sel.getRangeAt(i));
          }
          return ranges;
        }
        return null;
      },

      // Get the Element the Caret idea from http://bit.ly/1kRmZIL
      getSelectionStart: function() {
        var node = document.getSelection().anchorNode,
          startNode = (node && node.nodeType === 3 ? node.parentNode : node);
        return startNode;
      },

      getrange: function() {
        return window.getSelection().getRangeAt(0);
      },

      // Find element within the selection
      // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
      findElementInSelection: function(tagname, container) {
        var i, len, el, comprng, selparent,
          rng = this.getrange();

        if (rng) {
          selparent = rng.commonAncestorContainer || rng.parentElement();
          // Look for an element *around* the selected range
          for (el = selparent; el !== container; el = el.parentNode) {
            if (el.tagName && el.tagName.toLowerCase() === tagname) {
              return el;
            }
          }

          // Look for an element *within* the selected range
          if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
            el = selparent.getElementsByTagName(tagname);
            comprng = document.createRange ? document.createRange() : document.body.createTextRange();

            for (i = 0, len = el.length; i < len; i++) {
              // determine if element el[i] is within the range
              if (document.createRange) { // w3c
                comprng.selectNodeContents(el[i]);
                if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                  return el[i];
                }
              }
              else { // microsoft
                comprng.moveToElementText(el[i]);
                if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                  return el[i];
                }
              }
            }
          }
        }
      },

      // Restore if Selection is a Link
      restoreLinkSelection: function () {
        var currentLink = $(this.findElementInSelection('a', this.element[0]));

        settings.anchor.url = settings.anchor.defaultUrl;
        settings.anchor.class = settings.anchor.defaultClass;
        settings.anchor.target = settings.anchor.defaultTarget;

        if (currentLink.length) {
          settings.anchor.url = currentLink.attr('href');
          settings.anchor.class = currentLink.attr('class');
          settings.anchor.target = currentLink.attr('target');

          // currentLink.removeAttr('class target');
          // document.execCommand('unlink', false, null);
        }

      },

      //Run the CE action.
      execAction: function (action) {
        var currentElement = this.getCurrentElement();

        // Visual Mode
        if (currentElement === this.element) {
          if (action.indexOf('append-') > -1) {
            this.execFormatBlock(action.replace('append-', ''));
            this.setToolbarButtonStates();
          } else if (action === 'anchor') {
            this.restoreLinkSelection();
            this.modals.url.data('modal').open();
          } else if (action === 'image') {
            this.modals.image.data('modal').open();
          } else if (action === 'foreColor' || action === 'backColor') {
            this.colorpickerActions(action);
          } else if (action === 'source' || action === 'visual') {
            this.toggleSource();
          } else {
            document.execCommand(action, false, null);
          }
        } else {
          // Source Mode
          switch(action) {
            case 'visual':
              this.toggleSource();
              break;
            case 'anchor':
              this.modals.url.data('modal').open();
              break;
            default:
              this.insertTextAreaContent(null, action);
              break;
          }
        }

      },

      insertImage: function (url) {
        document.execCommand('insertImage', false, url);
      },

      toggleSource: function() {
        if (this.sourceViewActive()) {
          this.element.empty().html($.sanitizeHTML(this.textarea.val()));
          this.element.removeClass('source-view-active hidden');
          this.sourceView.addClass('hidden').removeClass('is-focused');
          this.element.trigger('focus.editor');
        } else {
          // Format The Text being pulled from the WYSIWYG editor
          var val = this.element.html().toString().trim()
            .replace(/\s+/g, ' ')
            .replace(/<br( \/)?>/g, '<br>\n')
            .replace(/<\/p> /g, '</p>\n\n')
            .replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

          this.textarea.val(val).focus();

          // var val = this.element.html().toString();
          // this.textarea.val(this.formatHtml(val)).focus();

          this.element.addClass('source-view-active hidden');
          this.sourceView.removeClass('hidden');
          this.adjustSourceLineNumbers();
          this.textarea.focus();
        }
        this.switchToolbars();
      },

      // Colorpicker actions ['foreColor'|'backColor']
      colorpickerActions: function(action) {
        var self = this,
          cpBtn = $('[data-action="'+ action +'"]', this.toolbar),
          cpApi = cpBtn.data('colorpicker'),
          color = document.queryCommandValue(action);

        // Set selection color checkmark in picker popup
        // by adding/updating ['data-value'] attribute
        if (cpApi) {
          if (self.isFirefox && action === 'backColor') {
            color = $(window.getSelection().focusNode.parentNode).css('background-color');
          }
          // IE-11 queryCommandValue returns the as decimal
          if (typeof color === 'number') {
            color = cpApi.decimal2rgb(color);
          }
          color = cpApi.rgb2hex(color);
          cpBtn.attr('data-value', color).find('.icon').css('fill', color);
        }

        cpBtn.on('selected.editor', function (e, item) {
          var value = ('#' + item.data('value')).toLowerCase();
          cpBtn.attr('data-value', value).find('.icon').css('fill', value);

          if (self.isIE || action === 'foreColor') {
            document.execCommand(action, false, value);
          }

          // [action: backColor] - for Chrome/Firefox/Safari
          else {
            // Get selection parent element
            var getSelectionParentElement = function() {
              var parentEl = null, sel;
              if (window.getSelection) {
                sel = window.getSelection();
                if (sel.rangeCount) {
                  parentEl = sel.getRangeAt(0).commonAncestorContainer;
                  if (parentEl.nodeType !== 1) {
                    parentEl = parentEl.parentNode;
                  }
                }
              } else if ( (sel = document.selection) && sel.type !== 'Control') {
                  parentEl = sel.createRange().parentElement();
              }
              return parentEl;
            };

            // FIX: "backColor" - Chrome/Firefox/Safari
            // some reason font/span node not get inserted with "backColor"
            // so use "fontSize" command to add node, then remove size attribute
            // this fix will conflict with combination of font size & background color
            document.execCommand('fontSize', false, '2');
            var parent = getSelectionParentElement().parentNode,
              els = parent.getElementsByTagName('font');

            // Using timeout, firefox not executes with current call stack
            setTimeout(function() {
              for (var i = 0, l = els.length; i < l; i++) {
                if (els[i].hasAttribute('size')) {
                  els[i].setAttribute('style', 'background-color: '+ value +';');
                  els[i].removeAttribute('size');
                }
              }
            }, 0);

          }
        });

        // Toggle colorpicker
        cpApi.toggleList();
      },

      execFormatBlock: function (el) {
        var selectionData = this.getSelectionData(this.selection.anchorNode);
        // FF handles blockquote differently on formatBlock
        // allowing nesting, we need to use outdent
        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
        if (el === 'blockquote' && selectionData.el &&
            selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
            return document.execCommand('outdent', false, null);
        }
        if (selectionData.tagName === el) {
            el = 'p';
        }
        // When IE we need to add <> to heading elements and
        // blockquote needs to be called as indent
        // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
        // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
        if (this.isIE) {
          if (el === 'blockquote') {
              return document.execCommand('indent', false, el);
          }
          el = '<' + el + '>';
        }

        return document.execCommand('formatBlock', false, el);
      },

      //Get What is Selected
      getSelectionData: function (el) {
        var tagName;

        if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
        }

        while (el && this.parentElements.indexOf(tagName) === -1) {
          el = el.parentNode;
          if (el && el.tagName) {
              tagName = el.tagName.toLowerCase();
          }
        }

        return {
          el: el,
          tagName: tagName
        };
      },

      isListItemChild: function (node) {
        var parentNode = node.parentNode,
            tagName = parentNode.tagName.toLowerCase();
        while (this.parentElements.indexOf(tagName) === -1 && tagName !== 'div') {
          if (tagName === 'li') {
              return true;
          }
          parentNode = parentNode.parentNode;
          if (parentNode && parentNode.tagName) {
              tagName = parentNode.tagName.toLowerCase();
          } else {
              return false;
          }
        }
        return false;
      },

      destroyToolbar: function() {
        var element = this.getCurrentElement();
        // Unbind all events attached to the old element that involve triggering the toolbar hide/show

        var toolbarApi = this.toolbar.data('toolbar');
        if (toolbarApi) {
          toolbarApi.destroy();
        }

        var tooltips = this.toolbar.find('button');
        tooltips.each(function() {
          var tooltip = $(this).data('tooltip');
          if (tooltip && typeof tooltip.destroy === 'function') {
            tooltip.destroy();
          }
        });

        this.toolbar.off('click.editor mousedown.editor');
        this.toolbar.remove();
        this.toolbar = undefined;
        this.element.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        this.textarea.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        element.off('keydown.editor');
        this.element.prev('.label').off('click.editor');
        $(window).off('resize.editor');
        $.each(this.modals, function(i, modal) {
          modal.off('beforeclose close open');
        });
        this.modals = {};

        this.element.trigger('destroy.toolbar.editor');
      },

      updated: function() {
        // TODO: Updated Method
        return this;
      },

     /**
     * Disable the editable area.
     */
      disable: function () {
        this.element.addClass('is-disabled').attr('contenteditable', 'false');
        this.container.addClass('is-disabled');
      },

      /**
      * Enable the editable area.
      */
      enable: function () {
        this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
        this.container.removeClass('is-disabled is-readonly');
      },

      /**
      * Make the editable area readonly.
      */
      readonly: function () {
        this.element.removeClass('is-readonly').attr('contenteditable', 'false');
        this.container.addClass('is-readonly');
      },

      // Fix to Firefox get focused by keyboard
      setFocus: function() {
        var self = this,
          el = ($.trim(self.element.html()).slice(0, 1) === '<') ?
            $(':first-child', self.element)[0] : self.element[0];

        window.setTimeout(function() {
          var sel, range;
          if (window.getSelection && document.createRange) {
            range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(true);
            sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else if (document.body.createTextRange) {
            range = document.body.createTextRange();
            range.moveToElementText(el);
            range.collapse(true);
            range.select();
          }
        }, 1);

      },

      // Called whenever a paste event has occured
      onPasteTriggered: function () {
        if(!this.isFirefox && document.addEventListener) {
          document.addEventListener('paste', function (e) {
            if(typeof e.clipboardData !== 'undefined') {
              var copiedData = e.clipboardData.items[0]; // Get the clipboard data
              // If the clipboard data is of type image, read the data
              if(copiedData.type.indexOf('image') === 0) {
                var imageFile = copiedData.getAsFile();
                // We will use HTML5 FileReader API to read the image file
                var reader = new FileReader();

                reader.onload = function (evt) {
                  var result = evt.target.result; // base64 encoded image
                  document.execCommand('insertImage', false, result);
                  // Create an image element and append it to the content editable div
                  // var img = document.createElement('img');
                  // img.src = result;
                  // document.getElementById('editablediv').appendChild(img);
                };
                // Read the image file
                reader.readAsDataURL(imageFile);
              }
            }
          }, false);
        }
      },

      isWordFormat: function(content) {
        return (
          (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i).test(content) ||
          (/class="OutlineElement/).test(content) ||
          (/id="?docs\-internal\-guid\-/.test(content))
        );
      },

      cleanWordHtml: function(content) {
        var s = content;

        // Word comments like conditional comments etc
        s = s.replace(/<!--[\s\S]+?-->/gi, '');

        // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
        // MS Office namespaced tags, and a few other tags
        s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');

        // Convert <s> into <strike> for line-though
        s = s.replace(/<(\/?)s>/gi, '<$1strike>');

        // Replace nsbp entites to char since it's easier to handle
        s = s.replace(/&nbsp;/gi, '\u00a0');

        // Convert <span style="mso-spacerun:yes"></span> to string of alternating
        // breaking/non-breaking spaces of same length
        s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function(str, spaces) {
          return (spaces.length > 0) ?
          spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join('\u00a0') : '';
        });

        // Remove line breaks / Mso classes
        s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');

        var i, l, re,
          badTags = ['style', 'script','applet','embed','noframes','noscript'];

        // Remove everything in between and including "badTags"
        for (i = 0, l = badTags.length; i < l; i++) {
          re = new RegExp('<'+badTags[i]+'.*?'+badTags[i]+'(.*?)>', 'gi');
          s = s.replace(re, '');
        }

        return s;
      },

      // Strip attributes
      stripAttribute: function (s, attribute, attributeStripper) {
        return (attribute === 'style') ?
          this.stripStyles(s, attributeStripper) :
          s.replace(attributeStripper, '');
      },

      // Strip styles
      stripStyles: function (s, styleStripper) {
        var stylesToKeep = ['color','background','font-weight','font-style','text-decoration','text-align'];
        return s.replace(styleStripper, function(m) {
          m = m.replace(/( style=|("|\'))/gi, '');
          var attributes = m.split(';'),
          strStyle = '';
          for (var i = 0; i < attributes.length; i++) {
            var entry = attributes[i].split(':');
            strStyle += (stylesToKeep.indexOf(entry[0]) > -1) ? entry[0] +':'+ entry[1] +';' : '';
          }
          return (strStyle !=='') ? (' style="'+ strStyle +'"') : '';
        });
      },

      getIndent: function(level) {
        var result = '',
          i = level * 2;
        if (level > -1) {
          while (i--) {
            result += ' ';
          }
        }
        return result;
      },

      formatHtml: function(html) {
        html = html.trim();
        var result = '',
          indentLevel = 0,
          tokens = html.split(/</);

        for (var i = 0, l = tokens.length; i < l; i++) {
          var parts = tokens[i].split(/>/);
          if (parts.length === 2) {
            if (tokens[i][0] === '/') {
              indentLevel--;
            }
            result += this.getIndent(indentLevel);
            if (tokens[i][0] !== '/') {
              indentLevel++;
            }
            if (i > 0) {
              result += '<';
            }
            result += parts[0].trim() + '>\n';
            if (parts[1].trim() !== '') {
              result += this.getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' ') + '\n';
            }
            if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
              indentLevel--;
            }
          } else {
            result += this.getIndent(indentLevel) + parts[0] + '\n';
          }
        }
        return result.trim();
      },

      /**
      * Detach Events and tear back additions.
      */
      destroy: function () {
        $('html').off('mouseup.editor');
        this.destroyToolbar();
        this.sourceView.remove();
        if ($('[data-editor="true"]').length === 1) {
          $('#editor-modal-url, #editor-modal-image').remove();
        }
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Editor#events
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires after as keys are pressed.
       *
       */
      handleEvents: function () {

      }

    };

    // Make it plugin protecting from double initialization
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Editor(this, settings));
      }
    });

  };


  $.fn.expandablearea = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'expandablearea',
        defaults = {
          trigger: null,
          bottomBorder: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class ExpandableArea
    * @param {String} trigger  &nbsp;-&nbsp; Id of some other button to use as a trigger
    * @param {String} bottomBorder  &nbsp;-&nbsp; Change the border to bottom vs top (for some cases)
    *
    */
    function ExpandableArea(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ExpandableArea.prototype = {
      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var id;
        this.id = id = this.element.attr('id');
        if (!id || id === undefined) {
          this.id = id = 'expandable-area-' + $('body').find('.expandable-area').index(this.element);
        }

        this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
        this.footer = this.element.children('.expandable-footer');
        this.content = this.element.children('.expandable-pane');

        this.isCard = this.element.is('.card, .widget');
        return this;
      },

      build: function() {
        var self = this,
          expanded = this.element.hasClass('is-expanded');

        this.header.attr({
          'aria-expanded': '' + expanded,
          'aria-controls': this.id + '-content',
          'id': this.id + '-header'
        });
        this.content.attr({
          'id': this.id + '-content'
        });

        // Add the link and footer if not there.
        // If we're using an expandable card,
        if (!this.isCard && !this.footer.length && !this.settings.trigger) {
          this.footer =  $('<div class="expandable-footer"></div>').appendTo(this.element);
        }

        function getExpander(instance, useHeaderExpander) {
          var expander;

          if (useHeaderExpander === true) {
            // Use icon-based expander in the header
            expander = instance.header.find('expandable-expander');
            if (!expander.length) {
              expander = $('<a href="#" target="_self" class="btn-expander">' +
                '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' +
                  '<use xlink:href="' + '#icon-caret-down' + '"></use>' +
                '</svg>' +
                '<span class="audible">'+ Locale.translate('ShowMore') +'</span>' +
              '</a>').appendTo(instance.header);
            }

            return expander;
          }

          // Use the text-based expander button in the footer
          expander = instance.footer.find('.expandable-expander');
          if (!expander.length) {
            expander = $('<a href="#" target="_self" class="expandable-expander hyperlink">' +
              '<span data-translated="true">'+ Locale.translate('ShowMore') +'</span>' +
            '</a>').prependTo(instance.footer);
          }
          return expander;
        }

        this.expander = getExpander(self, this.isCard);
        this.expander.attr('href', '#').hideFocus();

        if (this.expander.length === 0) {
          this.expander = $('#' + this.settings.trigger);
        }

        // Change the borer to the bottom vs top
        if (this.settings.bottomBorder) {
          this.element.addClass('has-bottom-border');
        }

        //Initialized in expanded mode.
        if (expanded) {
          this.content.addClass('no-transition');
          this.element.one('afterexpand.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.open();
        }

        if (!expanded) {
          this.content.addClass('no-transition');
          this.element.one('aftercollapse.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.close();
        }

        return this;
      },

      /**
      * Return if the expandable area is current disable or not.
      * @returns {Boolean}
      */
      isDisabled: function() {
        return this.element.hasClass('is-disabled');
      },

      handleKeys: function(e) {
        if (this.isDisabled()) {
          return;
        }

        var key = e.which;

        if (key === 13 || key === 32) { // Enter/Spacebar
          e.preventDefault();
          this.toggleExpanded();
          return false;
        }
      },

      handleFocus: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.addClass('is-focused');
      },

      handleBlur: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.removeClass('is-focused');
      },

      /**
       * Indicates whether or not this area is expanded.
       * @returns {boolean}
       */
      isExpanded: function() {
        return this.element.is('.is-expanded');
      },

      /**
       * Toggle Current Expansion State.
       */
      toggleExpanded: function() {
        // if (this.header.attr('aria-expanded') === 'true') {
        if (this.isExpanded()) {
          this.close();
        } else {
          this.open();
        }
      },

      /**
       * Open the pane if closed.
       */
      open: function() {
        var self = this,
        canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

        if (canExpand === false) {
          return;
        }

        this.element.addClass('is-expanded');
        this.header.attr('aria-expanded', 'true');
        this.expander.addClass('active');
        this.element.triggerHandler('expand', [this.element]);

        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

        if (this.isCard) {
          this.expander.find('.icon').addClass('active');
        }

        if (this.content[0]) {
          this.content[0].style.display = 'block';
        }
        this.content.one('animateopencomplete', function() {
          self.element.triggerHandler('afterexpand', [self.element]);
        }).animateOpen();
      },

      /**
       * Close the pane if open.
       */
      close: function() {
        var self = this,
        canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

        if (canCollapse === false) {
          return;
        }

        this.expander.removeClass('active');
        this.element.triggerHandler('collapse', [this.element]);
        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

        if (this.isCard) {
          this.expander.find('.icon').removeClass('active');
        }

        this.content.one('animateclosedcomplete', function() {
          self.element.removeClass('is-expanded');
          self.header.attr('aria-expanded', 'false');
          self.element.triggerHandler('aftercollapse', [self.element]);
          self.content[0].style.display = 'none';
        }).animateClosed();
      },

      /**
       * Disable the Expandable Area from being closable.
       */
      disable: function() {
        this.element.addClass('is-disabled');
      },

      /**
       * Enable the Expandable Area to allow close.
       */
      enable: function() {
        this.element.removeClass('is-disabled');
      },

      /**
       * Teardown - Remove added markup and events
       */
      destroy: function() {
        this.header.children('a').offTouchClick('expandablearea').off();
        this.header.off();
        this.header
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded')
          .removeAttr('id');
        this.content.removeAttr('id').removeClass('no-transition');
        $.removeData(this.element[0], pluginName);
      },

      handleEvents: function() {
        var self = this;
        this.expander.onTouchClick('expandablearea').on('click.expandablearea', function(e) {
          if (!self.isDisabled()) {
            e.preventDefault();
            self.toggleExpanded();
          }
        });

        this.header.on('keydown.expandablearea', function(e) {
          self.handleKeys(e);
        }).on('focus.expandablearea', function(e) {
          self.handleFocus(e);
        }).on('blur.expandablearea', function(e) {
          self.handleBlur(e);
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ExpandableArea(this, settings));
      }
    });
  };


  /**
  * Make elements in the jQuery selector disabled if they support the prop disabled. Or has a disable method.
  */
  $.fn.disable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    return this;
  };

  /**
  * Make elements in the jQuery selector enabled if they support the prop disabled. Or has a enable method.
  */
  $.fn.enable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.enable) {
        value.enable();
      }
    });
    this.prop('disabled', false);
    return this;
  };

  /**
  * Make elements in the jQuery selector readonly if they support the prop readonly. Or has a readonly method.
  */
  $.fn.readonly = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };

  /**
  * Track changes on the inputs passed in the jQuery selector and show a dirty indicator.
  */
  $.fn.trackdirty = function() {
      this.each(function () {
        var input = $(this);

        function valMethod(elem) {
          switch(elem.attr('type')) {
            case 'checkbox':
            case 'radio':
              return elem.prop('checked');
            default:
              return elem.val();
          }
        }

        // Get absolute position for an element
        function getAbsolutePosition(element) {
          var pos = element.position();
          element.parents().each(function() {
            var el = this;
            if (window.getComputedStyle(el, null).position === 'relative') {
              return false;
            }
            pos.left += el.scrollLeft;
            pos.top += el.scrollTop;
          });
          return {left:pos.left, top:pos.top};
        }

        input.data('original', valMethod(input))
        .on('resetdirty.dirty', function () {
          input.data('original', valMethod(input))
            .triggerHandler('doresetdirty.dirty');
        })
        .on('change.dirty doresetdirty.dirty', function (e) {
          var el = input,
            field = input.closest('.field'),
            label = $('label:visible', field),
            d = {class: '', style: ''};

          if (field.is('.field-fileupload')) {
            el = label.prev('input');
          }

          // Used element without .field wrapper
          if (!label[0]) {
            label = input.next('label');
          }
          if (input.attr('data-trackdirty') !== 'true') {
            return;
          }

          // Add class to element
          input.addClass('dirty');

          //Set css class
          if (input.is('[type="checkbox"], [type="radio"]')) {
            d.class += ' dirty-'+ input.attr('type');
            d.class += input.is(':checked') ? ' is-checked' : '';
          }
          if (input.is('select')) {
            d.class += ' is-select';
            el = input.next('.dropdown-wrapper').find('.dropdown');
          }

          //Add class and icon
          d.icon = el.prev();
          if (!d.icon.is('.icon-dirty')) {
            if (input.is('[type="checkbox"]')) {
              d.rect = getAbsolutePosition(label);
              d.style = ' style="left:'+ d.rect.left +'px; top:'+ d.rect.top +'px;"';
            }
            d.icon = '<span class="icon-dirty'+ d.class +'"'+ d.style +'></span>';
            d.msg = Locale.translate('MsgDirty') || '';
            d.msg = '<span class="audible msg-dirty">'+ d.msg +'</span>';

            // Add icon and msg
            el.before(d.icon);
            label.append(d.msg);

            // Cache icon and msg
            d.icon = el.prev();
            d.msg = label.find('.msg-dirty');
          }

          //Handle reseting value back
          if (valMethod(input) === input.data('original')) {
            input.removeClass('dirty');
            $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
            input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
            return;
          }

          //Trigger event
          input.trigger('dirty');

        });
      });
    return this;
  };

  // Fix: Labels without the "for" attribute
  $(function () {
    var str, control,
      labelText = $('.label-text'),
      labels = labelText.closest('label, .label');

    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class');

      $(this).addClass(function () {
        // Add "inline" and "inline-{control}" class to label
        // assuming control class is first thing in class string
        return 'inline' + (str ? ' inline-'+ (str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '');
      });
    });
  });

  // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox
  $(function () {
    $('input:radio').on('click.radios', function() {
      this.focus();
    });
  });

  // Add css classes to parent for apply special rules
  $(function () {
    var addCssClassToParent = function(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };
    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });


  $.fn.fileupload = function() {

    'use strict';

    // Settings and Options
    var pluginName = 'fileupload';

    /**
    * A trigger field for uploading a single file.
    *
    * @class FileUpload
    * @param {Boolean} none  &nbsp;-&nbsp; No options
    */
    function FileUpload(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUpload Methods
    FileUpload.prototype = {

      init: function() {
        this.build();
      },

      // Example Method
      build: function() {
        var elem = this.element;
        this.fileInput = elem.find('input');

        elem.parent('.field').addClass('field-fileupload');

        //append markup
        var id = elem.find('input').attr('name'),
          elemClass = elem.find('input').attr('class'),
          instructions = Locale.translate('FileUpload'),
          label = $('<label for="'+ id +'-filename">'+ elem.text() +' <span class="audible">'+ instructions +'</span></label>'),
          shadowField = $('<input readonly id="'+ id +'-filename" class="fileupload-background-transparent'+ (elemClass ? ' '+ elemClass : '') +'" type="text">'),
          svg = '<span class="trigger" tabindex="-1">' + $.createIcon('folder') + '</span>';

        elem.before(label, shadowField);
        this.fileInput.after(svg);

        this.textInput = elem.parent().find('[type="text"]');
        this.textInput.on('keypress.fileupload', function (e) {
          if (e.which === 13 || e.which === 32) {
            e.stopPropagation();
            elem.find('input').trigger('click');
          }
        });

        if (this.fileInput.is(':disabled')) {
          this.textInput.prop('disabled', true);
        }

        if (this.fileInput.attr('readonly')) {
          this.textInput.prop('disabled', false);
          this.textInput[0].classList.remove('fileupload-background-transparent');
          this.fileInput.attr('disabled', 'disabled');
        }

        this.fileInput.attr('tabindex', '-1').on('change.fileupload', function () {
          elem.prev('input').val(this.files[0].name);
        });
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.fileInput.removeAttr('tabindex').off('change.fileupload');
        this.textInput.off('keypress.fileupload');
        this.element.closest('.field-fileupload')
          .removeClass('field-fileupload')
          .find('>label:first, >[type="text"]:first, .trigger, .icon-dirty, .msg-dirty').remove();

        $.removeData(this.element[0], pluginName);
      },

      /**
      * Disable the input and button.
      */
      disable: function() {
        this.textInput.prop('disabled', true);
        this.fileInput.prop('disabled', true);
      },

      /**
      * Enable the input and button.
      */
      enable: function() {
        this.textInput.prop('disabled', false).prop('readonly', false);
        this.fileInput.removeAttr('disabled');
      },

      /**
      * Make the input readonly and disable the button.
      */
      readonly: function() {
        this.textInput.prop('readonly', true);
        this.fileInput.prop('disabled', true);
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new FileUpload(this));
      }
    });
  };


  $.fn.fileuploadadvanced = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'fileuploadadvanced',
        defaults = {
          isStandalone: true, //
          standaloneClass: 'standalone', // css class if on page
          allowedTypes: '*', // restrict file types(ie. 'jpg|png|gif') ['*' all types]
          maxFilesInProcess: 99999, // max files can be upload
          maxFileSize: -1, // max file size in bytes, -1 for unlimited
          fileName: 'myfile', // variable name to read from server

          // Text strings
          textDropArea: 'Drag and Drop File to Upload',
          textBtnCancel: 'Cancel uploading this file',
          textBtnCloseError: 'Close this error',
          textBtnRemove: 'Remove from server this file',

          // Error strings
          errorAllowedTypes: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorAllowedTypes'),
          errorMaxFileSize: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFileSize'),
          errorMaxFilesInProcess: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFilesInProcess')
        },
        settings = $.extend({}, defaults, options);

    /**
    * A trigger field for uploading a single file.
    *
    * @class FileUploadAdvanced
    * @param {Boolean} isStandalone  &nbsp;-&nbsp; On page(true) -or- on modal (false) , this is used for some visual style only.
    * @param {Boolean} allowedTypes  &nbsp;-&nbsp; Restrict file types(ie. 'jpg|png|gif') ['*' all types]
    * @param {Boolean} maxFilesInProcess  &nbsp;-&nbsp; Max number of files can be uploaded
    * @param {Boolean} maxFileSize  &nbsp;-&nbsp; Max file size in bytes, -1 for unlimited
    * @param {Boolean} fileName  &nbsp;-&nbsp; Variable name to read from server
    *
    */
    function FileUploadAdvanced(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUploadAdvanced Methods
    FileUploadAdvanced.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {
        var settings = this.settings,
          standaloneClass = settings.isStandalone ? settings.standaloneClass : '';

        this.element.append(
          '<div class="fileupload-wrapper '+ standaloneClass +'">' +
            '<div class="container drop-area">' +
              $.createIcon('upload-adv') +
              '<p>'+ settings.textDropArea +'</p>' +
            '</div>' +
          '</div>');

        this.dropArea = $('.drop-area', this.element);
      },

      //Attach Events used by the Control
      handleEvents: function () {
        var self = this,
          settings = this.settings;

        self.dropArea

        // Drag enter
        .on('dragenter.fileuploadadvanced', function (e) {
          self.element.triggerHandler('filesdragenter');
          e.stopPropagation();
          e.preventDefault();
          $(this).addClass('hover');
        })

        // Drag over
        .on('dragover.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();
        })

        // Drop
        .on('drop.fileuploadadvanced', function (e) {
          var files = e.originalEvent.dataTransfer.files;
          e.preventDefault();

          self.element.triggerHandler('filesdroped', [files]);

          $(this).removeClass('hover');

          // Clear previous errors in general area
          $('span.msg', this.element).closest('.error').remove();

          // Max files can be upload
          if ((files.length + $('.progress', this.element).length) > settings.maxFilesInProcess) {
            self.showError(settings.errorMaxFilesInProcess);
            return;
          }

          self.handleFileUpload(files);
        });

        // If the files are dropped outside the div, files will open in the browser window.
        // To avoid this prevent 'drop' event on document.
        $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();

          if (e.type === 'dragover') {
            self.dropArea.removeClass('hover');
          }
        });

      },

      /**
      * Read the file contents using HTML5 FormData()
      * @param {Object} files &nbsp;-&nbsp; File object containing uploaded files.
      */
      handleFileUpload: function (files) {
        var fileName = this.settings.fileName.replace('[]', '');

        for (var i = 0, l = files.length; i < l; i++) {

          // Check if file type allowed
          if (!this.isFileTypeAllowed(files[i].name)) {
            this.showError(settings.errorAllowedTypes, files[i]);
            continue;
          }

          // Check for max file size
          if (settings.maxFileSize !== -1 && files[i].size > settings.maxFileSize) {
            this.showError(settings.errorMaxFileSize, files[i]);
            continue;
          }

          this.element.triggerHandler('beforecreatestatus', [files[i]]);
          var fd = new FormData();
          fd.append(fileName + '[]', files[i]);

          var status = this.createStatus(files[i]);
          this.element.triggerHandler('aftercreatestatus', [files[i]]);

          this.sendFileToServer(fd, status);
        }
      },

      // Create status
      createStatus: function (file) {
        var self = this,
          settings = this.settings,
          container = $(
            '<div class="container">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ icon: 'close', classes: ['icon-close'] }) +
                    '<span>'+ settings.textBtnCancel +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ self.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="progress-row">' +
                '<span class="progress">' +
                  '<span class="progress-bar" data-value="0"></span>' +
                '</span>' +
              '</div>' +
            '</div>'),

          btnCancel = $('.action', container).button(),
          rightSide = $('.l-pull-right', container),
          progressBar = $('.progress-bar', container).progress({ animationLength: 10 });

        // Add this container
        self.dropArea.after(container);

        // Update progress-bar
        var setProgress = function(progress) {
            self.element.triggerHandler('fileprogress', [{file: file, 'progress': progress}]);
            progressBar.attr('data-value', progress).triggerHandler('updated');
          },

          // Set abort action
          setAbort = function(jqxhr) {
            btnCancel.on('click.fileuploadadvanced', function() {
              self.element.triggerHandler('fileaborted', [file]);
              jqxhr.abort();
              container.remove();
            });
          },

          // Set completed state
          setCompleted = function(data) {
            container.addClass('completed');

            // Add "Completed" icon
            btnCancel.after($.createIcon('check'));

            // Add "Remove from server" button
            rightSide.append(
              '<button type="button" class="btn-icon action">' +
                $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                '<span>'+ settings.textBtnRemove +'</span>' +
              '</button>');

            // Set "Remove from server" button action
            $('.action', rightSide).button().on('click.fileuploadadvanced', function() {
              container.remove();

              // TODO: server call for removing data
              data.remove();
            });

            // Remove Cancel button and progress-bar area
            btnCancel.add(progressBar.closest('.progress-row')).remove();
            self.element.triggerHandler('filecompleteuploading', [file]);
          };

        return {
          file: file,
          container: container,
          setProgress: setProgress,
          setAbort: setAbort,
          setCompleted: setCompleted
        };
      },

      /**
      * Function you can implement to send data to the server.
      * @param {Object} formData - Contains the form data / file data.
      * @param {Object} status - Status of the upload operation
      *
      */
      sendFileToServer: function (formData, status) {
        var jqXHR = { abort: function() {} },
          tempData = { remove: function() {} },
          percent = 0,
          total = parseFloat(status.file.size),
          timer = new $.fn.timer(function() {
            status.setCompleted(tempData);
          }, total);

        $(timer.event)
        .on('update', function(e, data) {
          percent = Math.ceil(data.counter / total * 100);
          status.setProgress(percent);
        });

        status.setAbort(jqXHR);
      },

      sendFileToServer2: function (formData, status) {
        this.element.triggerHandler('beforeuploading', [formData]);
        var uploadURL = 'http://myserver.com/upload/upload.php', // Upload URL
          jqXHR = $.ajax({
            xhr: function() {
              var xhrobj = $.ajaxSettings.xhr();

              if (xhrobj.upload) {
                xhrobj.upload.addEventListener('progress', function(e) {
                  var percent = 0,
                    position = e.loaded || e.position,
                    total = e.total;

                  if (e.lengthComputable) {
                    percent = Math.ceil(position / total * 100);
                  }

                  // Set progress
                  status.setProgress(percent);
                }, false);
              }
              return xhrobj;
            },
            url: uploadURL,
            type: 'POST',
            contentType: false,
            processData: false,
            cache: false,
            data: formData,
            success: function(data) {
              // File upload Done
              status.setCompleted(data);
            }
        });

        status.setAbort(jqXHR);
      },

      // Show Errors
      showError: function (error, file) {
        var container;

        if (error === this.settings.errorMaxFilesInProcess) {
          // This error show without file name or size in general area
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ settings.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="msg">'+ error +'</span>' +
              '</div>' +
            '</div>');
        }
        else {
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ settings.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ this.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="msg">' +
                '<p>' + error +'</p>' +
              '</div>' +
            '</div>');
        }

        $('.action', container).button().on('click.fileuploadadvanced', function() {
          container.remove();
        });

        // Add this container
        this.dropArea.after(container);
      },

      // Check if file type allowed
      isFileTypeAllowed: function (fileName) {
        var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g),
          ext = fileName.split('.').pop().toLowerCase();
          if(this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
            return false;
          }
          return true;
        },

      // Helper function that formats the file sizes
      formatFileSize: function (bytes) {
        var scale = {
          GB: 1000000000,
          MB: 1000000,
          KB: 1000
        };
        if (typeof bytes !== 'number') {
          return '';
        }
        if (bytes >= scale.GB) {
          return (bytes / scale.GB).toFixed(2) +' GB';
        }
        if (bytes >= scale.MB) {
          return (bytes / scale.MB).toFixed(2) +' MB';
        }
        return (bytes / scale.KB).toFixed(2) +' KB';
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $('.action', this.element).off('click.fileuploadadvanced');
        $('.fileupload-wrapper', this.element).remove();

        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new FileUploadAdvanced(this, settings));
      }
    });
  };


/*
ERROR
--------
https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

*/

  $.fn.header = function(options) {

    'use strict';

    // Tab Settings and Options
    var pluginName = 'header',
        defaults = {
          demoOptions: true,
          useBackButton: true,
          useBreadcrumb: false,
          usePopupmenu: false,
          tabs: null,
          wizardTicks: null,
          useAlternate: false,
          addScrollClass: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * Special Toolbar at the top of the page used to faciliate SoHo Xi Nav Patterns
    *
    * @class Header
    * @param {Boolean} demoOptions  &nbsp;-&nbsp; Used to enable/disable default SoHo Xi options for demo purposes
    * @param {Boolean} useBackButton  &nbsp;-&nbsp; If true, displays a back button next to the title in the header toolbar
    * @param {Boolean} useBreadcrumb  &nbsp;-&nbsp; If true, displays a breadcrumb on drilldown
    * @param {Boolean} usePopupmenu  &nbsp;-&nbsp; f true, changes the Header Title into a popupmenu that can change the current page
    * @param {Array} tabs  &nbsp;-&nbsp; If defined as an array of Tab objects, displays a series of tabs that represent application sections
    * @param {Array} wizardTicks  &nbsp;-&nbsp; If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
    * @param {Boolean} useAlternate  &nbsp;-&nbsp; If true, use alternate background/text color for sub-navigation areas
    * @param {Boolean} addScrollClass  &nbsp;-&nbsp; If true a class will be added as the page scrolls up and down to the header for manipulation. Eg: Docs Page.
    *
    */
    function Header(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Header.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();

        // Theme, Personalization, Language Changer, Scrolling
        if (this.settings.demoOptions) {
          this.initPageChanger();
        }
      },

      setup: function() {
        // TODO: Settings all work independently, but give better descriptions
        this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
        this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
        this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
        this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;

        this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
        this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;

        this.titleText = this.element.find('.title > h1');

        // Used to track levels deep
        this.levelsDeep = [];
        this.levelsDeep.push('' + this.titleText.text());

        return this;
      },

      build: function() {
        this.toolbarElem = this.element.find('.toolbar');

        // Build toolbar if it doesn't exist
        if (!this.toolbarElem.data('toolbar')) {
          var opts = $.fn.parseOptions(this.toolbarElem);
          this.toolbarElem.toolbar(opts);
        }
        this.toolbar = this.toolbarElem.data('toolbar');

        // Hamburger Icon is optional, but tracking it is necessary.
        this.titleButton = this.element.find('.title > .application-menu-trigger');
        this.hasTitleButton = this.titleButton.length > 0;

        if (this.hasTitleButton) {
          this.toolbarElem.addClass('has-title-button');
          var appMenu = $('#application-menu').data('applicationmenu');
          if (appMenu) {
            appMenu.modifyTriggers([this.titleButton], null, true);
          } else {
            $('#application-menu').applicationmenu({
              triggers: [this.titleButton]
            });
          }
        }

        // Application Tabs would be available from the Application Start, so activate them during build if they exist
        if (this.settings.tabs && this.settings.tabs.length) {
          this.buildTabs();
        }

        if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
          this.buildWizard();
        }

        if (this.settings.usePopupmenu) {
          this.buildPopupmenu();
        }

        //Add a Scrolling Class to manipulate the header
        if (this.settings.addScrollClass) {
          var self =$(this.element),
            scrollDiv = $(this.element).next('.scrollable'),
            container = (scrollDiv.length === 1 ? scrollDiv : $(window)),
            scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;

          container.on('scroll.header', function () {
            if (this.scrollTop > scrollThreshold) {
              self.addClass('is-scrolled-down');
            } else {
              self.removeClass('is-scrolled-down');
            }

          });

          if (container.scrollTop() > scrollThreshold ) {
            self.addClass('is-scrolled-down');
          }
        }

        return this;
      },

      buildTitleButton: function() {
        if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
          this.titleButton = $('<button class="btn-icon back-button" type="button"></button>');
          this.titleButton.html('<span class="audible">'+ Locale.translate('Drillup') +'</span>' +
            '<span class="icon app-header go-back">' +
              '<span class="one"></span>' +
              '<span class="two"></span>' +
              '<span class="three"></span>' +
            '</span>');
          this.titleButton.prependTo(this.element.find('.title'));

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }

        this.titleButton.find('.icon.app-header').addClass('go-back');
      },

      // Used for adding a Breadcrumb Element to the Header
      buildBreadcrumb: function() {
        var self = this,
          breadcrumbClass = 'has-breadcrumb';

        if (this.settings.useAlternate) {
          breadcrumbClass = 'has-alternate-breadcrumb';
        }
        this.element.addClass(breadcrumbClass);

        this.breadcrumb = this.element.find('.breadcrumb');
        if (!this.breadcrumb.length) {
          this.breadcrumb = $('<nav class="breadcrumb" role="navigation" style="display: none;"></nav>').appendTo(this.element);
          this.breadcrumb.on('click', 'a', function(e) {
            self.handleBreadcrumbClick(e);
          });
        }

        this.breadcrumb[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');
        this.adjustBreadcrumb();
      },

      // Builds Breadcrumb markup that reflects the current state of the application
      adjustBreadcrumb: function() {
        var last = this.levelsDeep[this.levelsDeep.length - 1];
        this.breadcrumb.empty();

        var bcMarkup = $('<ol aria-label="breadcrumb"></ol>').appendTo(this.breadcrumb);
        $.each(this.levelsDeep, function(i, txt) {
          var current = '';
          if (last === txt) {
            current = ' current';
          }

          bcMarkup.append($('<li><a href="#" class="hyperlink'+ current +'">'+ txt +'</a></li>'));
        });
      },

      buildTabs: function() {
        this.tabsContainer = this.element.find('.tab-container');
        if (!this.tabsContainer.length) {
          this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element);

          // TODO: Flesh this out so that the header control can build tabs based on options
          var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
          $('<li class="tab"><a href="#header-tabs-home" role="tab">SoHo Xi Controls | Patterns</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
        }

        this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
        this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
        $('#header-tabs-level-1').removeAttr('style');
        $('#header-tabs-level-2').removeAttr('style');

        // Invoke Tabs Control
        this.tabsContainer.tabs({
          containerElement: '#maincontent'
        });
      },

      buildWizard: function() {
        this.element.addClass('has-wizard');

        this.wizard = this.element.find('.wizard');
        if (!this.wizard.length) {
          this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
          var header = $('<div class="wizard-header"></div>').appendTo(this.wizard),
            bar = $('<div class="bar"></div>').appendTo(header);
          $('<div class="completed-range"></div>').appendTo(bar);

          // TODO: Flesh this out so the header control can build the Wizard Ticks based on options
          $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
        }

        this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
        // inside the Nav Patterns Test page.
        // TODO: Build shifting forms

        // Invoke the Wizard Control
        this.wizard.wizard();
      },

      buildPopupmenu: function() {
        var title = this.toolbarElem.children('.title');
        this.titlePopup = title.find('.btn-menu');
        if (!this.titlePopup.length) {
          var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.
          heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
          this.titlePopup = heading.parent('.btn-menu');
        }
        this.titlePopupMenu = this.titlePopup.next('.popupmenu');
        if (!this.titlePopupMenu.length) {
          this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
          $('<li class="is-checked"><a href="#">Page One Title</a></li>' +
            '<li><a href="#">Page Two Title</a></li>' +
            '<li><a href="#">Page Three Title</a></li>' +
            '<li class="is-disabled"><a href="#">Page Four Title</a></li>' +
            '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
        }
        this.titlePopupMenu.addClass('is-selectable');

        // Set the text on the Title
        this.titlePopup.children('h1').text(this.titlePopupMenu.children().first().text());

        // Invoke the Popupmenu on the Title
        this.titlePopup.button().popupmenu();

        // Update the Header toolbar to account for the new button
        this.toolbarElem.triggerHandler('updated');
      },

      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.header', function() {
            self.updated();
          })
          .on('reset.header', function() {
            self.reset();
          })
          .on('drilldown.header', function(e, viewTitle) {
            self.drilldown(viewTitle);
          })
          .on('drillup.header', function(e, viewTitle) {
            self.drillup(viewTitle);
          });

        // Events for the title button.  e.preventDefault(); stops Application Menu functionality while drilled
        this.titleButton.bindFirst('click.header', function(e) {
          if (self.levelsDeep.length > 1) {
            e.stopImmediatePropagation();
            self.drillup();
            e.returnValue = false;
          }
        });

        // Popupmenu Events
        if (this.settings.usePopupmenu) {
          this.titlePopup.on('selected.header', function(e, anchor) {
            $(this).children('h1').text(anchor.text());
          });
        }

        return this;
      },

      handleBreadcrumbClick: function(e) {
        var selected = $(e.target).parent(),
          breadcrumbs = this.breadcrumb.find('li'),
          selectedIndex = breadcrumbs.index(selected),
          delta;

        if (selected.hasClass('current')) {
          return;
        }

        if (selectedIndex === 0) {
          return this.reset();
        }

        if (selectedIndex < breadcrumbs.length - 1) {
          delta = (breadcrumbs.length - 1) - selectedIndex;
          while (delta > 0) {
            this.drillup();
            delta = delta - 1;
          }
        }
      },

      initPageChanger: function () {
        this.element.find('.page-changer').on('selected.header', function (e, link) {
          // Change Theme
          if (link.attr('data-theme')) {
            var theme = link.attr('data-theme');
            $('body').trigger('changetheme', theme.replace('-theme',''));
            return;
          }

          // TODO: Change Lang
          if (link.attr('data-lang')) {
            Locale.set(link.attr('data-lang'));
            return;
          }

          // Change Color
          var color = link.attr('data-rgbcolor');
          $('body').trigger('changecolors', [color]);
        });
      },

      // Activates the Drilldown Header View
      drilldown: function(viewTitle) {
        this.element.addClass('is-drilldown');
        this.levelsDeep.push(viewTitle.toString());
        this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

        if (this.settings.useBackButton) {
          this.buildTitleButton();
        }

        if (this.settings.useBreadcrumb) {
          if (!this.breadcrumb || !this.breadcrumb.length) {
            this.buildBreadcrumb();
            this.breadcrumb.css({'display': 'block', 'height': 'auto'});
          } else {
            this.adjustBreadcrumb();
          }
        }
      },

      drillup: function(viewTitle) {
        var title;
        this.element.removeClass('is-drilldown');

        if (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
          title = this.levelsDeep[this.levelsDeep.length - 1];
        }

        if (viewTitle !== undefined) {
          title = viewTitle;
        }

        if (this.levelsDeep.length > 1) {
          if (this.settings.useBreadcrumb) {
            this.adjustBreadcrumb();
          }
          this.titleText.text(title);
          return;
        }

        // Completely reset all the way back to normal
        title = this.levelsDeep[0];

        if (this.settings.useBackButton) {
          this.removeButton();
        }
        if (this.settings.useBreadcrumb) {
          this.removeBreadcrumb();
        }
        if (this.settings.usePopupmenu) {
          this.removePopupmenu();
        }

        this.titleText.text(title);
        this.element.trigger('drillTop');
      },

      /**
      * Reset the toolbar to its default removing the drilled in patterns.
      */
      reset: function() {
        while (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
        }
        this.titleText.text(this.levelsDeep[0]);

        this.removeBreadcrumb();
        this.removeTabs();
        this.removeWizard();
        this.removePopupmenu();
        this.removeButton();

        this.element.trigger('afterreset');
        return this;
      },

      removeButton: function() {
        if (this.hasTitleButton) {
          this.titleButton.find('.icon.app-header').removeClass('go-back');
          return;
        }

        if (this.titleButton && this.titleButton.length) {
          this.titleButton.remove();
          this.titleButton = $();

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }
      },

      removeBreadcrumb: function() {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyBreadcrumb() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.breadcrumb-header');
          self.breadcrumb.off().remove();
          self.breadcrumb = $();
        }

        self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');
        if (this.breadcrumb.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.breadcrumb-header', destroyBreadcrumb);
          timeout = setTimeout(destroyBreadcrumb, 300);
        } else {
          destroyBreadcrumb();
        }
      },

      removeTabs: function() {
        if (!this.tabsContainer || !this.tabsContainer.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyTabs() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.tabs-header');
          self.tabsContainer.data('tabs').destroy();
          self.tabsContainer.remove();
          self.tabsContainer = null;

          // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
          $('#header-tabs-level-1').css('display', 'none');
          $('#header-tabs-level-2').css('display', 'none');
        }

        this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');
        if (this.tabsContainer.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.tabs-header', destroyTabs);
          timeout = setTimeout(destroyTabs, 300);
        } else {
          destroyTabs();
        }
      },

      removeWizard: function() {
        if (!this.wizard || !this.wizard.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyWizard() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.wizard-header');
          self.wizard.data('wizard').destroy();
          self.wizard.remove();
          self.wizard = null;

        }

        this.element.removeClass('has-wizard');
        if (this.wizard.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.wizard-header', destroyWizard);
          timeout = setTimeout(destroyWizard, 300);
        } else {
          destroyWizard();
        }
      },

      removePopupmenu: function() {
        var self = this;

        if (!this.titlePopup || !this.titlePopup.length) {
          return;
        }

        this.titlePopup.data('popupmenu').destroy();
        this.titlePopup.data('button').destroy();
        this.titlePopupMenu.remove();
        this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
        this.titlePopup.remove();

        this.titlePopup = undefined;
        this.titlePopupMenu = undefined;

        this.toolbarElem.triggerHandler('updated');
      },

      // teardown events
      unbind: function() {
        this.titleButton.off('click.header');
        this.element.off('drilldown.header drillup.header');
        return this;
      },

      /**
      * Sync up the ui with settings.
      */
      updated: function() {
        this
          .reset()
          .unbind()
          .init();
      },

      /**
      * Tear down and destroy the menu and events.
      */
      destroy: function() {
        this.unbind();
        if (this.hasTitleButton) {
          this.toolbarElem.removeClass('has-title-button');
        }

        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Header(this, settings));
      }
    });
  };


 $.fn.hierarchy = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'hierarchy',
        defaults = {
          legend: [],
          legendKey: '',
          dataset: [],
          newData: [],
          templateId: '',  //Id to the Html Template
          mobileView: false,
          mouseEnterTarget: '',
          rightClickTarget: '',
          leafHeight: null,
          leafWidth: null,
          beforeExpand: null
        },
        settings = $.extend({}, defaults, options);

    var colorClass = [
      'azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06'
    ];

    var constants = {
      container       : 'container',
      chart           : 'content',
      toplevel        : 'top-level',
      sublevel        : 'sub-level',
      noSublevel      : 'no-sublevel',
      sublist         : 'sublist',
      button          : 'btn-expand',
      leaf            : 'leaf',
      inner           : 'inner',
      multiRoot       : 'multi-root',
      root            : 'root',
      back            : 'back',
      activeBranch    : 'active-branch',
      branchExpanded  : 'branch-expanded',
      branchCollapsed : 'branch-collapsed',
      collapsedLeaf   : 'collapsed-leaf',
      expanded        : 'expanded',
      collapsed       : 'collapsed',
      close           : 'close',
      open            : 'open',
      shadow          : 'shadow',
      line            : 'line',
      selected        : 'selected',
      show            : 'show',
      hide            : 'hidden'
    };

    /**
    * The displays custimizable hierarchical data such as an org chart.
    *
    * @class Hierarchy
    * @param {String} legend  &nbsp;-&nbsp; Pass in custom markdown for the legend structure.
    * @param {String} legendKey  &nbsp;-&nbsp; Key to use for the legend matching
    * @param {String} dataset  &nbsp;-&nbsp; Hierarchical Data to display
    * @param {Boolean} newData  &nbsp;-&nbsp; Id to the Html Template
    * @param {String} templateId  &nbsp;-&nbsp; Additional product name information to display
    * @param {Boolean} mobileView  &nbsp;-&nbsp; If true will only show mobile view, by default using device info to determine.
    * @param {String} beforeExpand  &nbsp;-&nbsp; A callback that fires before node expansion of a node.
    *
    */
    function Hierarchy(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Hierarchy Methods
    Hierarchy.prototype = {
      init: function() {

        var isMobile = $(this.element).parent().width() < 610; //Phablet down

        if (isMobile) {
          this.mobileView = true;
        } else {
          this.mobileView = false;
        }

        this.handleEvents();

        if (settings.dataset) {
          if (settings.dataset[0].children.length > 0) {
            var data = settings.dataset[0] === undefined ? settings.dataset : settings.dataset[0];

            data.isRootNode = true;
            data.isExpanded = true;
            this.render(data);
          } else {
            $(this.element).append('<p style=\'padding:10px;\'>No data available</p>');
          }
        }

        if (settings.leafHeight !== null && settings.leafWidth !== null) {

          var style = 'body .hierarchy .leaf,' +
                'body .hierarchy .sublevel .leaf,' +
                'body .hierarchy .container .root.leaf { width: ' + settings.leafWidth + 'px; ' + ' height: ' + settings.leafHeight + 'px; ' + ' }';

          $('<style type=\'text/css\' id=\'hierarchyLeafStyles\'>' + style + '</style>').appendTo('body');
        }
      },

      // Attach all event handlers
      handleEvents: function() {
        var self = this;

        // Expand or Collapse
        self.element.onTouchClick('hierarchy', '.' + constants.button).on('click.hierarchy', '.' + constants.button, function(event) {

          if (settings.newData.length > 0) {
            settings.newData = [];
          }

          var nodeId = $(this).closest('.' + constants.leaf).attr('id');
          var dataObject = self.data(nodeId, settings.dataset, settings.newData);
          var domObject = {
            branch: $(this).closest('li'),
            leaf: $(this).closest('.' + constants.leaf),
            button: $(this)
          };

          if (dataObject.isExpanded) {
            self.collapse(event, dataObject, domObject);
          } else {
            self.expand(event, dataObject, domObject);
          }

        });

        //TODO: Are we using this?
        self.element.onTouchClick('click', '.' + constants.back).on('click', '.' + constants.back, function() {
          var nodeId     = $(this).parent().find('.' + constants.leaf).attr('id');
          var nodeData   = self.data(nodeId, settings.dataset, settings.newData);
          var domObject  = {
            branch: $(this).closest('li'),
            leaf: $(this).closest('.' + constants.leaf),
            button: $(this)
          };

          self.collapse(event, nodeData, domObject);
        });

        self.element.on('keypress', '.' + constants.leaf, function(event) {
          var nodeId     = $(this).attr('id');
          var nodeData   = self.data(nodeId, settings.dataset, settings.newData);

          if (event.which === 13) {
            if (nodeData.isExpanded) {
              self.collapse(event, nodeData);
            } else {
              self.expand(event, nodeData);
            }
          }
        });

        // Select
        self.element.on('mousedown', '.' + constants.leaf, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};

          $('.is-' + constants.selected).removeClass('is-'+constants.selected);
          $('#' + nodeData.id).addClass('is-'+constants.selected);

          $(this).trigger('selected', nodeData, element);
        });

        // Right Click
        var rightClickTarget = settings.rightClickTarget === '' ? '.' + constants.leaf : settings.rightClickTarget;
        self.element.on('mousedown', rightClickTarget, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};
          if (event.which === 1) {
            $(this).trigger('click');
          }
          if (event.which === 3) {
            $(this).trigger('rightClick', [nodeData, element]);
          }
        });

        // Mouseenter
        var mouseEnterTarget = settings.mouseEnterTarget === '' ? '.' + constants.leaf : settings.mouseEnterTarget;
        self.element.on('mouseenter', mouseEnterTarget, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};

          if (event.which !== 3) {
            $(this).trigger('mouseEnter', [nodeData, element]);
          }
        });

        // Double Click
        self.element.on('dblclick', '.' + constants.leaf, function(event) {
          var nodeData  = $(this).data();
          var element = {target: event.target, clientX: event.clientX, clientY: event.clientY};

          $(this).trigger('doubleClick', nodeData, element);
        });

      },

      // Process data attached through jquery data
      data: function(nodeId, currentDataObject, newDataObject, params) {

        if (params === undefined) {
          params = {};
        }

        var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
        var nodeData = [];

        if (settings.newData.length > 0) {
          settings.newData = [];
        }

        function processData(self, obj, newDataObject) {
          if (obj.length === undefined) {
            checkForChildren(self, obj, newDataObject);
          } else {
            for (var i = 0, l = obj.length; i < l; i++) {
              var o = obj[i];
              checkForChildren(self, o, newDataObject);
            }
          }
        }

        if (newDataObject !== undefined) {
          processData(this, obj, newDataObject);
        }

        function checkForChildren(self, obj, newDataObject) { //jshint ignore:line
          for (var prop in obj) {
            if (prop === 'id' && nodeId === obj.id) {
              if (!obj.isLoaded && !obj.isRootNode) {
                if (params.updateDisplay) {
                  obj.displayClass = constants.hide + ' ' + constants.collapsed;
                }
                else {
                  addChildrenToObject(obj, params);
                }
              }
              nodeData.push(obj);
            }
          }
          if (obj.children) {
            processData(self, obj.children, newDataObject);
          }
        }

        function addChildrenToObject(obj, params) { //jshint ignore:line
          if (params.insert) {
            delete obj.isLeaf;
            delete obj.displayClass;
            obj.displayClass = constants.expanded;
            obj.isExpanded = true;
          }
          if (newDataObject.length !== 0 && params.insert) {
            obj.children = [newDataObject];
          } else {
            obj.children = newDataObject;
          }
        }

        if (nodeData.length !== 0) {
          $('#' + nodeData[0].id).data(nodeData[0]);
        }

        return nodeData[0];
      },

      /**
      * Add data as children for the given nodeId.
      */
      add: function (nodeId, currentDataObject, newDataObject) {
        var self            = this;
        var id              = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
        var node            = $('#' + id);
        var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
        var selectorObject  = {};
        var isSubLevelChild = parentContainer.parent().attr('class') !== constants.sublevel;
        var subListExists   = parentContainer.children('.' + constants.sublist).length === 1;

        if (isSubLevelChild) {
          if (subListExists) {
            selectorObject.element = parentContainer.children('.' + constants.sublist);
          } else {
            selectorObject.el = parentContainer.append('<ul class=\'' + constants.sublist + '\'></ul>');
            selectorObject.element = $(selectorObject.el).find('.' + constants.sublist);
          }
        } else {
          selectorObject.el = parentContainer.children('ul');
          selectorObject.element = $(selectorObject.el);
        }

        if (!currentDataObject.isRootNode) {
          for(var i = 0, l = newDataObject.length; i < l; i++) {
            settings.newData.push(newDataObject[i]);
          }
          self.createLeaf(newDataObject, selectorObject.element);
        }
      },

      /**
      * Expand the nodes until nodeId is displayed on the page.
      */
      expand: function(event, nodeData, domObject) {
        var self = this,
          node = domObject.leaf,
          nodeTopLevel  = node.next().not('.' + constants.line);

        nodeTopLevel.animateOpen();
        self.element.trigger(constants.expanded, [nodeData, settings.dataset]);

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateOpen();
        }

        nodeData.isExpanded = true;
        self.setNodeData(nodeData);

        node.parent().removeClass(constants.branchCollapsed).addClass(constants.branchExpanded);
        self.setButtonState(node, nodeData);
      },

      /**
      * Collapse the passed in nodeId.
      */
      collapse: function(event, nodeData, domObject) {
        var self = this,
          node = domObject.leaf,
          nodeTopLevel  = node.next().not('.' + constants.line);

        nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
          self.element.trigger(constants.collapsed, [nodeData, settings.dataset]);
        });

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateClosed();
        }

        nodeData.isExpanded = false;
        self.setNodeData(nodeData);
        node.parent().removeClass(constants.branchExpanded).addClass(constants.branchCollapsed);
        self.setButtonState(node, nodeData);
      },

      //Main render method
      render: function (data) {
        var legend       = settings.legend;
        var children     = data.children;
        var hasTopLevel  = this.checkChildren(children, 'top-level');
        var hasSubLevel  = this.checkChildren(children, 'sub-level');
        var rootNodeHTML = [];
        var structure    = {
          legend    : '<legend><ul></ul></legend>',
          chart     : '<ul class=\'' + constants.container + '\'>'+ '<li class=\'' + constants.chart + '\'></li></ul>',
          toplevel  : '<ul class=\'' + constants.toplevel + '\'></ul>',
          sublevel  : '<ul class=\'' + constants.sublevel + '\'></ul>'
        };

        var chartContainer  = this.element.append(structure.chart);
        var chart = $('.' + constants.chart, chartContainer);

        if (legend.length !== 0) {
          this.element.prepend(structure.legend);
          var element = $('legend', chartContainer);
          this.createLegend(element);
        }

        // Create root node
        this.setColor(data);
        this.displayButton(data);

        if (data.isMultiRoot) {
          var multiRootHTML = '<div class=\'' + constants.leaf + ' ' + constants.multiRoot + '\'><div class=\'' +
            constants.inner + '\'><h2>' +
            data.multiRootText +'</h2></div></div>';

          rootNodeHTML.push(multiRootHTML);
          $(rootNodeHTML[0]).addClass(constants.root).appendTo(chart);

        } else {

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: data});
          rootNodeHTML.push(leaf);

          $(rootNodeHTML[0]).addClass(constants.root).appendTo(chart);
          this.setNodeData(data);
        }

        if (!hasTopLevel) {
          $('<div class=\'' + constants.line + '\'></div>').insertAfter('.' + constants.root);
        }

        function renderSubChildren(self, subArray, data) {
          if (subArray !== null && subArray !== undefined) {
            for (var i = 0, l = subArray.length; i < l; i++) {
              var obj = subArray[i];
              subArrayChildren(self, obj, data);
            }
          }
        }

        // Create children nodes
        if (children.length > 0) {
          for (var i = 0, l = children.length; i < l; i++) {

            var childObject = data.children[i].children;

            if (this.isLeaf(children[i])) {
              this.createLeaf(data.children[i], $(structure.toplevel));
            }
            else {
              this.createLeaf(data.children[i], $(structure.sublevel));
            }

            if (childObject !== undefined && childObject !== null) {
              var subArray = data.children[i].children;
              var self = this;
              renderSubChildren(self, subArray, data);
            }
          }
        }

        function subArrayChildren(self, obj, data) { //jshint ignore:line
          for(var prop in obj) {
            if (prop === 'children') {
              var nodeId = obj.id;
              var currentDataObject = obj;
              var newDataObject = obj.children;

              if (newDataObject !== null && newDataObject !== undefined) {
                if (newDataObject.length > 0) {
                  self.add(nodeId, currentDataObject, newDataObject);
                }
              }

              return renderSubChildren(self, newDataObject, data);
            }
          }
        }

        if (!hasSubLevel) {
          $('.' + constants.topLevel).addClass(constants.noSublevel);
        }

        var containerWidth = this.element.find('.' + constants.container).outerWidth();
        var windowWidth = $(window).width();
        var center = (containerWidth - windowWidth) / 2;
        this.element.scrollLeft(center);

      },

      checkChildren : function(children, param) {
        var n = 0;
        var i = children.length;
        while(i--) {
          if (param === 'top-level') {
            if (children[i].isLeaf) {
              n += 1;
            }
          }
          if (param === 'subLevel') {
            if (children[i].children) {
              n += 1;
            }
          }
        }
        return n > 0;
      },

      // Add the legend from the Settings
      createLegend : function(element) {
        var mod      = 4;
        var index    = 0;

        for (var i = 0, l = settings.legend.length; i < l; i++) {
          var label  = settings.legend[i].label;
          var color  = colorClass[i];

          if (i - 1 % mod + 1 === mod) {
            element.append('<ul></ul>');
            index++;
          }

          element.children('ul').eq(index).append(
            '<li>' +
            '<span>' + label + '</span>' +
            '<span class=\'key ' + color + '\'></span>' +
            '</li>'
          );
        }
      },

      // Creates a leaf node under element for nodeData
      createLeaf: function(nodeData, container) {
        var self           = this;
        //console.log(nodeData.id);
        var chartClassName = self.element.attr('class');
        var chart          = $('.' + chartClassName + ' .' + constants.chart, self.container);
        var elClassName    = container.attr('class');
        var el             = elClassName !== undefined ? $('.' + elClassName) : container;

        if (el.length < 1) {
          if (elClassName === constants.toplevel) {
            container.insertAfter('.' + constants.root);
          } else {
            container.appendTo(chart);
          }
        }

        function processDataForleaf(nodeData, isLast) {
          self.setColor(nodeData);
          self.displayButton(nodeData);

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: nodeData});
          var animateParam = nodeData.isExpanded || nodeData.isExpanded === undefined ? 'expand' : 'collapse';
          var parent       = el.length === 1 ? el : container;
          var lineHtml     = '';

          parent.children('li').children('.ln').removeClass('last-line');

          if (isLast) {
            lineHtml += '<span class=\'ln last-line\'></span>';
          } else {
            lineHtml += '<span class=\'ln\'></span>';
          }

          var lf = $(leaf);
          self.setButtonState(lf, nodeData);

          if (elClassName !== constants.sublevel && elClassName !== constants.toplevel) {
            $(lf).append('<span class=\'horizontal-line\'></span>');
          }

          var branchState = nodeData.isExpanded || nodeData.isExpanded === undefined ? constants.branchExpanded : constants.branchCollapsed;
          if (nodeData.isLeaf) {
            branchState = '';
          }

          parent.append('<li class=' + branchState + '>' + lineHtml + $(lf)[0].outerHTML + '</li>');

          self.setNodeData(nodeData);

          if (nodeData.children) {
            var childrenNodes = '';
            nodeData.isLoaded = true;

            if (nodeData.displayClass === constants.expanded || nodeData.isExpanded) {
              nodeData.isExpanded = true;
              $('#' + nodeData.id).data(nodeData);
            }
            else {
              nodeData.isExpanded = false;
            }

            for (var j = 0, l = nodeData.children.length; j < l; j++) {
              self.setColor(nodeData.children[j]);
              self.displayButton(nodeData.children[j]);

              var childleaf = leafTemplate.render({dataset: nodeData.children[j]});
              var c = $(childleaf);

              $(c).append('<span class=\'horizontal-line\'></span>');

              if (j === nodeData.children.length - 1) {
                childrenNodes += '<li><span class=\'ln last-line\'></span>' + $(c)[0].outerHTML + '</li>';
              }
              else {
                childrenNodes += '<li><span class=\'ln\'></span>' + $(c)[0].outerHTML + '</li>';
              }
            }

            parent = $('#' + nodeData.id).parent();
            parent.append('<ul>' + childrenNodes + '</ul>');

            var childLength = nodeData.children.length;
            while (childLength--) {
              self.setNodeData(nodeData.children[childLength]);
            }

            //TODO: Test case with data loading collapsed nodes
            if (!nodeData.isExpanded && !nodeData.isLeaf) {
              self.animateExpandCollapse($('#' + nodeData.id).parent(), animateParam);
            }
          }
        }

        if (nodeData.length) {
          for (var i = 0, l = nodeData.length; i < l; i++) {
            var isLast = i === nodeData.length -1;
            processDataForleaf(nodeData[i], isLast);
          }
        } else {
          processDataForleaf(nodeData, true);
        }

      },

      // Determine the color from settings
      setColor: function(data) {
        for (var i = 0, l = settings.legend.length; i < l; i++) {
          if (data[settings.legendKey] === settings.legend[i].value) {
            data.colorClass = colorClass[i];
            break;
          }
          else if (data[settings.legendKey] === '') {
            data.colorClass =  'default-color';
          }
        }

        if (data.children && !data.isRootNode) {
          for (var k = 0, ln = data.children.length; k < ln; k++) {
            for (var j = 0, x = settings.legend.length; j < x; j++) {
              if (data.children[k][settings.legendKey] === settings.legend[j].value) {
                data.children[k].colorClass = colorClass[j];
              }
            }
          }
        }
      },

      setNodeData: function(nodeData) {
        var leafObject   = $('#' + nodeData.id).data(nodeData);
        leafObject.data  = nodeData;
      },

      /**
      * Return whether or not a particular node is a leaf
      */
      isLeaf: function(dataNode) {

        if (dataNode.children === undefined) {
          dataNode.isLeaf = true;
          return dataNode.isLeaf;
        }

        if (settings.beforeExpand) {
          return dataNode.isLeaf;
        }

        if (dataNode.children && dataNode.children.length > 0) {
          return false;
        }

        return true;
      },

      //set the classes and svg on the button
      setButtonState: function (leaf, data) {
        var btn = leaf.find('.'+ constants.button);

        if (data.isExpanded || data.isExpanded === undefined) {
          btn.find('svg.icon').changeIcon('caret-up');
        } else {
          btn.find('svg.icon').changeIcon('caret-up');
        }

        if (data.isExpanded === undefined) {
          btn.button();
        }
      },

      // Determine the state of the expand collapse button and show it
      displayButton: function(data) {

        if (data.isLeaf) {
          data.displayClass = constants.hide;
        } else {
          data.displayClass = constants.show;
        }

        if (data.isRootNode) {
          data.displayClass = constants.hide;
        }

        if (data.isExpanded) {
          data.displayClass += ' ' + constants.expanded;
        } else {
          data.displayClass += ' ' + constants.collapsed;
        }

        if (data.isExpanded === undefined) {
          if (!data.isLeaf && data.children && !data.isRootNode) {
            data.displayClass = constants.expanded;
          }
        }

      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Hierarchy(this, settings));
      }

    });
  };

/*
 * Text Highlight/Unhighlight Control
 * Originally called "highlight v5" by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Modified for SoHo Xi (TODO: bit.ly link to docs)
**/


  $.fn.highlight = function(pat) {

    function innerHighlight(node, pat) {
      var skip = 0,
        pos, spannode, middlebit, middleclone, endbit;

      if (node.nodeType === 3) {
        pos = node.data.toUpperCase().indexOf(pat);
        pos -= (node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length);

        if (pos >= 0) {
          spannode = document.createElement('mark');
          spannode.className = 'highlight';
          middlebit = node.splitText(pos);
          endbit = middlebit.splitText(pat.length);
          middleclone = middlebit.cloneNode(true);
          spannode.appendChild(middleclone);
          middlebit.parentNode.replaceChild(spannode, middlebit);
          skip = 1;
        }

      } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
        for (var i = 0; i < node.childNodes.length; ++i) {
          i += innerHighlight(node.childNodes[i], pat);
        }
      }

      return skip;
    }

    return this.length && pat && pat.length ? this.each(function() {
      innerHighlight(this, pat.toUpperCase());
    }) : this;
  };

  $.fn.unhighlight = function() {
    return this.find('mark.highlight').each(function() {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };


  $.fn.homepage = function(options) {

    // Settings and Options
    var pluginName = 'homepage',

        defaults = {
          gutterSize: 20, //Private
          widgetWidth: 360, //Private
          widgetHeight: 370, //Private
          animate: true,
          timeout: 100, //Private
          columns: 3,
          easing: 'blockslide' //Private
        },
        settings = $.extend({}, defaults, options);


    /**
    * The Homepage handles card layout at multiple breakpoints.
    *
    * @class Homepage
    * @param {Boolean} animate  &nbsp;-&nbsp; Disable animation during resize
    * @param {Number} columns  &nbsp;-&nbsp; Display in 3 (default) or 4 column layout
    *
    */
    function Homepage(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Homepage.prototype = {

      init: function() {
        this.settings = settings;
        this.isTransitionsSupports = this.supportsTransitions();
        this.initHeroWidget();
        this.handleEvents();

        //Initial Sizing
        this.resize(this, false);
      },

      initColumns: function(row) {
        row = row || 0;
        this.rowsAndCols[row] = [];

        for (var i = 0, l = this.settings.columns; i < l; i++) {
          this.rowsAndCols[row][i] = true;// Make all columns available in first row[true]
        }
      },

      initHeroWidget: function() {
        var heroWidget = $('.hero-widget');
        if (heroWidget.length > 1) {
          heroWidget = heroWidget.not(':first').remove();
        }
        this.heroWidget = heroWidget;
      },

      initRowsAndCols: function() {
        this.rowsAndCols = [];// Keeping all blocks as rows and columns
        this.initColumns();
      },

      // Return [x and y] where we can fit this block
      getAvailability: function(block) {
        var i, j, n, l, cols, innerCheck,
          self = this,
          rows = self.rowsAndCols.length,
          smallest = {},
          abort = false;

        // Loop thru each row and column soon it found first available spot
        // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops
        for (i = 0, l = rows; i < l && !abort; i++) {
          for (j = 0, innerCheck = true, cols = self.rowsAndCols[i].length; j < cols && !abort; j++) {
            if ((self.rowsAndCols[i][j]) && ((block.w + j) <= cols)) {
              if ((block.w > 1) && (cols > (j+1))) {
                for (n = 0; n < block.w; n++) {
                  if (!self.rowsAndCols[i][j + n]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if ((block.h > 1) && (rows > (i+1))) {
                for (n = 0; n < block.h; n++) {
                  if (!self.rowsAndCols[i + n][j]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if (innerCheck) {
                smallest.row = i;
                smallest.col = j;
                abort = true;
              }
            }
          }
        }

        // If did not found any available spot from previous loops
        // Add new row and asign to [smallest] first column in this new row
        if (!Object.getOwnPropertyNames(smallest).length) {
          self.initColumns(rows);
          smallest.row = rows;
          smallest.col = 0;
        }

        return smallest; //{x:0, y:0}
      },

      // Make all spots as unavailable, depends on block's width and height
      // Soon we used this block
      fitBlock: function(r, c, block) {
        var i, j, l, l2,
          self = this,
          addRow = true;

        block.x = c;
        block.y = r;

        if ((block.w === 1) && (block.h === 1)) { // Single block can fit anywhere
          self.rowsAndCols[r][c] = false;
        } else {
          // If more then one row or column then loop thru to block's width and height
          // If height is more then current rows then add new row
          // Mark those spots as unavailable[false]
          if(block.w !== 1) {
            // Left to right
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.w + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][j] = false;
              }
            }
          } else {
            // Top to bottom
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.h + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][c] = false;
              }
            }
          }
        }

        // Check if reach to end of columns then assign flag[addRow]
        for (i = 0, l = self.rowsAndCols[r].length; i < l; i++) {
          if(self.rowsAndCols[r][i]) {
            addRow = false;
          }
        }

        // If reach to end of columns and next row is not avaiable then add new row
        // Make all columns available, if not assigned earlier as unavailable
        if (addRow) {
          if (!self.rowsAndCols[r +1]) {
            self.initColumns(r +1);
          }
        }
      },

      // Setup each block sizes, based on classes provided from markup
      setBlocks: function() {
        var self = this;
        self.blocks = [];

        self.element.find('.card, .widget').each(function () {
          var card = $(this),
            h = card.hasClass('double-height') ? 2 : 1,
            w = card.hasClass('quad-width') ? 4 : card.hasClass('triple-width') ? 3 : card.hasClass('double-width') ? 2 : 1;

          self.blocks.push({w: w, h: h, elem: card, text: card.text()});
        });

        // Max sized columns brings to top
        for (var i=0, j=0, w=0, l=self.blocks.length; i<l; i++) {
          if (self.settings.columns > 1) {
            if (self.blocks[i].w >= self.settings.columns && i) {
              self.arrayIndexMove(self.blocks, i, j);
            }
            w += self.blocks[i].w;
            if(w >= self.settings.columns) {
              w = 0; //reset
              j = (self.blocks[j].w >= self.settings.columns) ? j+1 : i; //record to move
            }
          }
        }
      },

      //Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Resize Method
      resize: function(self, animate) {
        //Sizes of "breakpoints" is  320, 660, 1000 , 1340 (for 320)
        //or 360, 740, 1120, 1500 or (for 360)
        var bpXL    = (self.settings.widgetWidth * 4) + (self.settings.gutterSize * 3),
          bpDesktop = (self.settings.widgetWidth * 3) + (self.settings.gutterSize * 2),
          bpTablet  = (self.settings.widgetWidth * 2) + self.settings.gutterSize,
          bpPhone   = self.settings.widgetWidth;

        var bp = bpXL, //1340,
          elemWidth = self.element.outerWidth(); //Math min against window.screen.width for single line mobile support

        // elemWidth -= 30; //extra break space

        // Find the Breakpoints
        var xl    = (elemWidth >= bpXL),
          desktop = (elemWidth >= bpDesktop && elemWidth <= bpXL),
          tablet  = (elemWidth >= bpTablet && elemWidth <= bpDesktop),
          phone   = (elemWidth <= bpTablet);

        var maxAttr = this.element.attr('data-columns'),
          content = self.element.find('> .content');
        this.settings.columns = parseInt((maxAttr || this.settings.columns));

        // Assign columns as breakpoint sizes
        if (xl && self.settings.columns === 4) {
          self.settings.columns = 4;
          bp = bpXL;
        }
        if ((desktop) || (xl && self.settings.columns === 3)) {
          self.settings.columns = 3;
          bp = bpDesktop;
        }
        if (tablet) {
          self.settings.columns = 2;
          bp = bpTablet;
        }
        if (phone) {
          self.settings.columns = 1;
          bp = bpPhone;
        }

        if (content.length) {
          content[0].style.marginLeft = '-' + (bp/2) + 'px';
        }

        this.setBlocks(); //setup blocks
        this.initRowsAndCols(); //setup colums

        // Loop thru each block, make fit where available and
        // If block more wider than available size, make as  available size
        // Assign new left and top css positions
        for (var i = 0, l = self.blocks.length; i < l; i++) {
          var left, top, pos, available,
            block = self.blocks[i];

          // Remove extra classes if assigned earlier
          block.elem.removeClass('to-single to-double to-triple');

          // If block more wider than available size, make as available size
          if (block.w > self.settings.columns) {
            block.w = self.settings.columns;

            if (self.settings.columns === 1) {
              block.elem.addClass('to-single');
            }
            else if (self.settings.columns === 2) {
              block.elem.addClass('to-double');
            }
            else if (self.settings.columns === 3) {
              block.elem.addClass('to-triple');
            }
          }

          // Get Availability
          available = self.getAvailability(block);

          // Set positions
          var box = self.settings.widgetWidth + self.settings.gutterSize,
            totalWidth = box * self.settings.columns;

          left = Locale.isRTL() ? totalWidth - ((box * block.w) + (box * available.col)) : box * available.col;
          top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
          pos = {left: left, top: top};

          if (animate) {
            var easing = self.settings.easing,
              blockslide = [0.09, 0.11, 0.24, 0.91];

            if (easing === 'blockslide') {
              if (self.isTransitionsSupports) {
                self.applyCubicBezier(block.elem, blockslide);
                block.elem[0].style.left = pos.left + 'px';
                block.elem[0].style.top = pos.top + 'px';
              }
              // IE-9
              else {
                block.elem.animate(pos, self.settings.timeout);
              }
            }

            // Other easing effects ie (linear, swing)
            else {
              block.elem.animate(pos, self.settings.timeout, easing);
            }
          }
          else {
            block.elem[0].style.left = pos.left + 'px';
            block.elem[0].style.top = pos.top + 'px';
          }

          // Mark all spots as unavailable for this block, as we just used this one
          self.fitBlock(available.row, available.col, block);
        }
        self.element.triggerHandler('resize', self.settings.columns);
      },

      applyCubicBezier: function (el, cubicBezier) {
        el[0].style['-webkit-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-moz-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-ms-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-o-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style.transition = 'all .3s cubic-bezier('+ cubicBezier +')';
      },

      supportsTransitions: function () {
        var s = document.createElement('p').style,
          p = 'transition';

        if (typeof s[p] === 'string') {
          return true;
        }

        // Tests for vendor specific prop
        var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
        p = p.charAt(0).toUpperCase() + p.substr(1);

        for (var i = 0, l = v.length; i < l; i++) {
          if (typeof s[v[i] + p] === 'string') {
            return true;
          }
        }
        return false;
      },

      detachEvents: function () {
        $('body').off('resize.homepage');
        $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.detachEvents();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Homepage#events
       * @param {Object} resize  &nbsp;-&nbsp; Fires after the page is resized and layout is set. Can be used for any special adjustments.
       *
       */
      handleEvents: function () {
        var self = this;

        $('body').on('resize.homepage', function() {
          self.resize(self, self.settings.animate);
        });

        $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
          self.resize(self, self.settings.animate);
        });
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Homepage(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.icon = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'icon',
        defaults = {
          use: 'user-profile', // Match this to one of the SoHo Xi icons, prefixed with an ID of '#icon-'
          focusable: false
        },
        settings = $.extend({}, defaults, options);

    /**
     * Icon Control
     * Wraps SVG Icons with a Javascript control that can change the icon type, reference
     * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
     * @constructor
     * @param {Object} element
     */
    function Icon(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Icon.prototype = {
      init: function() {
        this.getExistingUseTag();

        //Do other init (change/normalize settings, load externals, etc)
        return this
          .render()
          .handleEvents();
      },

      // Add markup to the control
      render: function() {
        var self = this;
        this.element.addClass('icon');

        if (!this.element.is('svg')) {
          // TODO: Possibly work with span-based icons here?
          return this;
        }

        // Get a "base-tag-proof" version of the Use tag's definition.
        // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs
        var use = this.element[0].getElementsByTagName('use')[0];
        if (!use) {
          return this;
        }

        if (use.getAttribute('xlink:href') !== self.getBasedUseTag()) {
          setTimeout(function () {
            use.setAttribute('xlink:href', self.getBasedUseTag());
          }, 0);
        }

        return this;
      },

      getBasedUseTag: function() {
        return $.getBaseURL('#icon-' + this.settings.use);
      },

      // In the event that a <use> tag exists on an icon, we want to retain it
      // and replace the settings.
      getExistingUseTag: function() {
        if (!this.element.is('svg')) {
          return;
        }

        var useTag = this.element.children('use');
        if (!useTag.length) {
          return this;
        }

        var xlinkHref = useTag.attr('xlink:href');
        this.settings.use = xlinkHref.replace('#icon-', '');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        return this;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
        var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Icon(this, settings));
      }
    });
  };

  // Factory Function for instantly building icons.
  // Use this for building icons that don't exist yet.
  // Scoped Privately on purpose...
  (function (){
    'use strict';

    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile', // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      }

      // reroute "options.class" if that exists
      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      return options;
    }

    // Returns the RAW HTML for creating a new icon in string form
    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);

      return [
        '<svg class="' + options.classes.join(' ') + '" focusable="false" aria-hidden="true" role="presentation">' +
          '<use xlink:href="#icon-' + options.icon + '"></use>' +
        '</svg>'
      ].join('');
    };

    // Returns a jQuery-wrapped element containing a new icon
    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    };

    // Returns just the path part
    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL('#icon-' + options.icon.replace('icon-',''));
    };

    //Toggle the use or entire svg icon in the case of the polyfill
    $.fn.changeIcon = function(icon) {
      $(this).find('use').attr('xlink:href', $.createIconPath({icon: icon}));
    };

    $.fn.getIconName = function() {
      var svg = $(this),
          use = svg.find('use');

      if (use.length === 1) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-')+6);
      } else {
        return svg.attr('data-icon');
      }

    };

  })();


  $.fn.lookup = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'lookup',
        defaults = {
          click: null,
          field: 'id',
          title: null,
          buttons: [],
          options: null,
          beforeShow: null,
          modalContent: null,
          editable: true,
          typeahead: false, // Future TODO
          autoApply: true,
          validator: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * Input element that opens a dialog with a list for selection.
    *
    * @class Lookup
    * @param {Function} click  &nbsp;-&nbsp; Provide a special function to run when the dialog opens to customize the interaction entirely.
    * @param {String} field  &nbsp;-&nbsp; Field name to return from the dataset or can be a function which returns a string on logic
    * @param {String} title  &nbsp;-&nbsp;  Dialog title to show, or befault shows  field label + "Lookup"
    * @param {Array} buttons  &nbsp;-&nbsp; Pass dialog buttons or Cancel / Apply
    * @param {Object} options  &nbsp;-&nbsp; Options to pass to the datagrid
    * @param {Function} beforeShow  &nbsp;-&nbsp; Call back that executes async before the lookup is opened.
    * @param {String} modalContent  &nbsp;-&nbsp; Custom modal markup can be sent in here
    * @param {Boolean} editable  &nbsp;-&nbsp; Can the user type text in the field
    * @param {String} autoApply  &nbsp;-&nbsp; If set to false the dialog wont apply the value on clicking a value.
    * @param {Function} validator  &nbsp;-&nbsp; A function that fires to let you validate form items on open and select
    *
    */
    function Lookup(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    var lookupGridId = 'lookup-datagrid';

    // Plugin Methods
    Lookup.prototype = {

      init: function() {
        this.settings = settings;
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = !!this.inlineLabelText.length;
        this.build();
        this.handleEvents();
        this.grid = null;
        this.selectedRows = null;
      },

      // Build the Ui lookup
      build: function() {
         var lookup = this.element;

        var cssClass = this.element.is('.input-xs') ? 'lookup-wrapper xs' :
            this.element.is('.input-sm') ? 'lookup-wrapper sm' :
            this.element.is('.input-lg') ? 'lookup-wrapper lg' : 'lookup-wrapper';

        if (this.element.is('.has-actions')) {
         cssClass += ' has-actions-wrapper';
        }

        //Add Button
        this.icon = $('<span class="trigger" tabindex="-1"></span>').append($.createIcon('search-list'));
        if (this.isInlineLabel) {
          this.inlineLabel.addClass(cssClass);
        }
        else {
          this.container = $('<span class="'+ cssClass +'"></span>');
          lookup.wrap(this.container);
        }

        // this.container = $('<span class="lookup-wrapper"></span>');
        // lookup.wrap(this.container);
        lookup.after(this.icon);

        //Add Masking to show the #
        if (lookup.attr('data-mask')) {
          lookup.mask();
        }

        if (this.element.is(':disabled')) {
          this.disable();
        }

        if (!this.settings.editable) {
          this.element.attr('readonly', 'true').addClass('is-not-editable');
        }
        this.addAria();
      },

      // Add/Update Aria
      addAria: function () {
        var self = this;

        setTimeout(function () {
          self.label = self.isInlineLabel ? self.inlineLabelText : $('label[for="'+ self.element.attr('id') + '"]');

          if (self.label) {
            self.label.append('<span class="audible">' + Locale.translate('UseEnter') + '</span>');
          }
        }, 500);
      },

      //Handle events on the field
      handleEvents: function () {
        var self = this;

        this.icon.on('click.lookup', function (e) {
          self.openDialog(e);
        });

        //Down Arrow opens the dialog in this field
        this.element.on('keyup.lookup', function (e) {
          //If autocomplete open dont open list
          if ($('#autocomplete-list').length > 0) {
            return;
          }

          if (e.which === 40) {
            self.openDialog(e);
          }
        });

      },

      //Create and Open the Dialog
      openDialog: function (e) {
        var self = this,
          canOpen = self.element.triggerHandler('beforeopen');

        if (canOpen === false) {
          return;
        }

        if (self.isDisabled() || (self.isReadonly() && !self.element.hasClass('is-not-editable'))) {
          return;
        }

        if (self.settings.click) {
          self.settings.click(e, this);
          return;
        }

        if (this.settings.beforeShow) {
         var response = function (grid) {
            if (grid) {
              self.createGrid(grid);
            }
            self.createModal();
            self.element.triggerHandler('complete'); // for Busy Indicator
            self.element.trigger('open', [self.modal, self.grid]);

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }
            return;
          };

          this.element.triggerHandler('start'); // for Busy Indicator
          this.settings.beforeShow(this, response);
          return;
        }

        if (!this.settings.options) {
          return;
        }

        self.createModal();
        self.element.trigger('open', [self.modal, self.grid]);

        self.modal.element.find('.btn-actions').removeClass('is-selected');

        // Fix: IE-11 more button was not showing
        var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');
        if (thisMoreBtn.length) {
          setTimeout(function() {
            window.Soho.utils.fixSVGIcons(thisMoreBtn);
          }, 600);
        }

        self.element.trigger('afteropen', [self.modal, self.grid]);

        if (self.settings.validator) {
          self.settings.validator(self.element, self.modal, self.grid);
        }

      },

      //Overidable function to create the modal dialog
      createModal: function () {
        var self = this,
          content = '<div id="'+lookupGridId+'"></div>',
          thisLabel = $('label[for="'+self.element.attr('id')+'"]'),
          labelText = self.isInlineLabel ? self.inlineLabelText : (thisLabel.length ? thisLabel.clone().find('span').remove().end().text() : '');

        if (this.settings.title) {
          labelText = this.settings.title;
        }

        var settingContent = this.settings.modalContent;
        if (settingContent && settingContent instanceof jQuery) {
          content = settingContent;
          settingContent.show();
        }

        if (settingContent && !(settingContent instanceof jQuery)) {
          content = settingContent;
        }

        var buttons = this.settings.buttons;
        if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || (!self.settings.autoApply && buttons.length === 0)) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }, {
            text: Locale.translate('Apply'),
            click: function(e, modal) {
              var selectedRows = self.grid.selectedRows();
              modal.close();
              self.insertRows(selectedRows);
            },
            isDefault: true
          }];
        }

        if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }];
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

        $('body').modal({
          title: labelText,
          content: content,
          buttons: buttons,
          cssClass: 'lookup-modal' + (!hasKeywordSearch ? ' lookup-no-search' : '')
        }).off('open.lookup').on('open.lookup', function () {
          self.createGrid();
        }).off('close.lookup').on('close.lookup', function () {
          self.element.focus();
          self.element.triggerHandler('close', [self.modal, self.grid]);
        });

        self.modal = $('body').data('modal');
        if (!this.settings.title) {
          self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
        }

        self.modal.element.off('beforeclose.lookup').on('beforeclose.lookup', function () {
          self.closeTearDown();
        });

        // Wait until search field available
        setTimeout(function () {
          $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
            if (e.keyCode === 13) {
              return false; // Prevent for closing modal
            }
          });
        }, 300);
      },

      closeTearDown: function () {
        var search = $('.modal.is-visible .searchfield').off('keypress.lookup');
        if (search.data() && search.data('searchfield')) {
          search.data('searchfield').destroy();
        }

        if (search.data() && search.data('toolbarsearchfield')) {
          search.data('toolbarsearchfield').destroy();
          search.removeData();
        }
        search = null;

        if (!this.grid) {
          this.grid.destroy();
        }
      },

      //Overridable Function in which we create the grid on the current ui dialog.
      createGrid: function (grid) {
        var self = this, lookupGrid;

        if (grid) {
          lookupGrid = grid;
          lookupGridId = grid.attr('id');
          self.settings.options = grid.data('datagrid').settings;
        } else {
          lookupGrid = self.modal.element.find('#' + lookupGridId);
        }

        if (self.settings.options) {

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.settings.options.cellNavigation = false;
            lookupGrid.find('tr').addClass('is-clickable');
          }

          self.settings.options.isList = true;

          // Create grid (unless already exists from passed in grid)
          if (!lookupGrid.data('datagrid')) {
            lookupGrid.datagrid(self.settings.options);
          }
        }

        self.grid = lookupGrid.data('datagrid');
        if (!this.settings.title && self.modal) {
          self.modal.element.find('.title').remove();
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;
        if (!hasKeywordSearch && self.modal) {
          self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
        }

        //Mark selected rows
        lookupGrid.off('selected.lookup');
        var val = self.element.val();
        if (val) {
          self.selectGridRows(val);
        }

        if (this.settings.options) {
          lookupGrid.on('selected.lookup', function (e, selectedRows) {

            // Only proceed if a row is selected
            if (!selectedRows || selectedRows.length === 0) {
              return;
            }

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }

            if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
              setTimeout(function () {
                self.modal.close();
                self.insertRows();
              }, 100);
            }
          });
        }

      },

      //Given a field value, select the row
      selectGridRows: function (val) {
        var self = this,
          selectedId = val;

        if (!val) {
          return;
        }

        //Multi Select
        if (selectedId.indexOf(',') > 1) {
          var selectedIds = selectedId.split(',');

          for (var i = 0; i < selectedIds.length; i++) {
            self.selectRowByValue(self.settings.field, selectedIds[i]);
          }
          return;
        }

        self.selectRowByValue(self.settings.field, selectedId);
      },

      //Find the row and select it based on select value / function / field value
      selectRowByValue: function(field, value) {
        if (!this.settings.options) {
          return;
        }

        var self = this,
          data = this.settings.options.dataset,
          selectedRows = [];

        for (var i = 0; i < data.length; i++) {
          if (typeof self.settings.match === 'function') {
            if (self.settings.match(value, data[i], self.element, self.grid)) {
              selectedRows.push(i);
            }

            continue;
          }

          if (data[i][field] == value) {  // jshint ignore:line
            selectedRows.push(i);
          }
        }

        if (this.grid) {
          this.grid.selectedRows(selectedRows);
        }
      },

      //Get the selected rows and return them to the UI
      insertRows: function () {
        var self = this,
          value = '';

        self.selectedRows = self.grid.selectedRows();

        for (var i = 0; i < self.selectedRows.length; i++) {
          var currValue = '';

          if (typeof self.settings.field === 'function') {
            currValue = self.settings.field(self.selectedRows[i].data, self.element, self.grid);
          } else {
            currValue = self.selectedRows[i].data[self.settings.field];
          }

          value += (i !== 0 ? ',' : '') + currValue;
        }

        self.element.val(value).trigger('change', [self.selectedRows]);
        self.element.focus();
      },

      /**
      * Enable the input.
      */
      enable: function() {
        this.element.prop('disabled', false).prop('readonly', false);
        this.element.parent().removeClass('is-disabled');
      },

      /**
      * Disable the input.
      */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      /**
      * Make the input readonly.
      */
      readonly: function() {
        this.element.prop('readonly', true);
      },

      /**
      * Returns whether or not the Input is disabled
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
      * Returns whether or not the Input is readonly
      */
      isReadonly: function() {
        return this.element.prop('readonly');
      },

      /**
      * Teardown events and objects.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('click.dropdown keypress.dropdown');

        this.icon.remove();
        this.element.unwrap();

        if (this.label && this.label != null) {
          this.label.find('.audible').remove();
        }
      }
    };

    // Initialize the plugin once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Lookup(this, settings));
      }
    });
  };

 // Lifecycle Methods for jQuery Controls
 // Recursive methods that "globally" call certain methods on large groups of controls


  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion'],
      EXCLUDED_FROM_HANDLE_RESIZE = [];

  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid SoHo Xi Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  }

  // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.
  function canCall(prop, method) {
    var api = canAccessAPI(prop);
    if (!api) {
      return false;
    }

    return (prop[method] && typeof prop[method] === 'function');
  }

  // Actually triggers the method on the control if it's possible
  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }
    return false;
  }

  // Tracks each element that attempts to trigger an API method.
  // If a trigger is successful, it stores it in an array that's used later.
  function findControlsOnElements(elems, method) {
    var foundControls = [];

    $.each(elems, function elementIterator(index, elem) {
      $.each($(elem).data(), function dataEntryIterator(index, dataEntry) {
        if (triggerAPIMethod(dataEntry, method)) {
          foundControls.push({ elem: $(elem), control: dataEntry });
        }
      });
    });

    return foundControls;
  }

  // Kicks it all off
  function siftFor(rootElem, method, filteredOutElements) {
    if (!rootElem || !method) {
      return;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem);

    if (filteredOutElements) {
      DOMelements = DOMelements.not(filteredOutElements.join(', '));
    }
    var siftedControls = findControlsOnElements(DOMelements, method);

    rootElem.trigger('sift-' + method + '-complete', [siftedControls]);
    return rootElem;
  }

  //==========================================================
  // Actual Control Plugins
  //==========================================================

  $.fn.destroy = function() {
    return siftFor($(this), 'destroy');
  };

  $.fn.closeChildren = function() {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };

  $.fn.handleResize = function() {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };


  $.fn.listview = function(options) {
    // TODOs: edit and/or alt template
    // navigatable
    // template (as id or string)
    // Methods: add, remove (X), clear (X), destroy, refresh (rebind) (X), select (get or set) (X)
    // Events: rendered, add, select
    // Settings and Options
    var pluginName = 'listview',
      defaults = {
        dataset: [],
        template: null,
        description: null,
        paging: false,
        pagesize: 10,
        searchable: false,
        selectable: 'single',
        selectOnFocus: true,
        hoverable: true,
        source: null
      },
      settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class ListView
    * @param {Array} dataset  &nbsp;-&nbsp; Array of data to feed the template
    * @param {String} content  &nbsp;-&nbsp; Html Template String
    * @param {String} description  &nbsp;-&nbsp; Audible Label (or use parent title)
    * @param {Boolean} paging  &nbsp;-&nbsp; If true, activates paging
    * @param {Number} pagesize  &nbsp;-&nbsp; If paging is activated, sets the number of listview items available per page
    * @param {Boolean} searchable  &nbsp;-&nbsp; If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
    * @param {String|Boolean} selectable  &nbsp;-&nbsp;  //Can be false, 'single' or 'multiple'
    * @param {Boolean} selectOnFocus  &nbsp;-&nbsp;  //Can be false, 'single' or 'multiple'
    * @param {Boolean} hoverable  &nbsp;-&nbsp;  //Can be false, 'single' or 'multiple'
    * @param {Function|String} source  &nbsp;-&nbsp; //If it is a string then it serves as the url for an ajax call that returns the dataset. If its a function it is a call back for getting the data asyncronously.
    *
    */
    function ListView(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    ListView.prototype = {
      init: function() {
        this.setup();
        this.refresh();
        this.selectedItems = [];
        this.lastSelectedRow = 0; // Rember index to use shift key
        this.isSelectedAll = false; // Rember if all selected or not
        this.sortInit('listview', 'click.listview', 'data-sortlist');
        this.handleEvents();
        this.handleResize();
      },

      setup: function() {
        var self = this,
          card = this.element.closest('.card, .widget'),
          selectable = this.element.attr('data-selectable'),
          selectOnFocus = this.element.attr('data-select-onfocus');

        if (selectable && selectable.length) {
          this.settings.selectable = selectable;
        }

        if (selectOnFocus && selectOnFocus.length) {
          this.settings.selectOnFocus = JSON.parse(selectOnFocus);
        }

        self.actionButton = card.find('.btn-actions');

        if (self.actionButton.length > 0) {
          // Action Buttons may already be invoked via initialize.js.
          if (!(self.actionButton.data('popupmenu'))) {
            self.actionButton.popupmenu();
          }
        }

        this.element.attr({'tabindex': '-1'});

        // Configure Paging
        if (this.element.is('.paginated') || this.settings.paging === true) {
          this.element.pager({
            componentAPI: this,
            pagesize: this.settings.pagesize,
            source: this.settings.source
          });
        }

        var cardWidgetContent =  this.element.parent('.card-content, .widget-content');
        if (cardWidgetContent[0]) {
          cardWidgetContent[0].style.overflow = 'hidden';
        }

         // Add Aria Roles
        this.element.attr({ 'role' : 'listbox',
          'aria-label' : this.settings.description || card.find('.card-title, .widget-title').text()
        });

        // Associate with an existing searchfield, if applicable
        if (this.settings.searchable) {
          this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

          if (!this.searchfield.length) {
            // TODO: Create Searchfield somehow
          }

          this.listfilter = new ListFilter({
            filterMode: 'contains'
          });
        }

        if (this.settings.dataset) {
          // Search the global variable space for a dataset variable name, if provided.
          if (typeof this.settings.dataset === 'string') {
            var dataset = window[this.settings.dataset];
            if (dataset && dataset.length) {
              this.settings.dataset = dataset;
            }
          }
        }
      },

      getTotals: function(dataset) {
        var totals = { count: dataset.length },
          property;

        if (!dataset[0]) {
          return;
        }

        for (property in dataset[0]) {
          totals[property] = 0;
        }

        for (var i = 0; i < dataset.length; i++) {
          for (property in dataset[i]) {
            totals[property] += parseFloat(dataset[i][property]);
          }
        }
        return totals;
      },

      /**
      * Render the template against the dataset.
      *
      * @param {Array} dataset  &nbsp;-&nbsp; The data to use
      * @param {Object} pagerInfo  &nbsp;-&nbsp; Pager instructions
      */
      render: function(dataset, pagerInfo) {
        var self = this,
          totals = {};

        // Render "mustache" Template
        if (typeof Tmpl === 'object' && dataset && this.settings.template) {

          // create a copy of an inlined template
          if (this.settings.template instanceof $) {
            this.settings.template = '' + this.settings.template.html();
          }

          if (this.settings.template.indexOf('{{#totals}}') > -1) {
            totals = this.getTotals(dataset);
          }

          var compiledTmpl = Tmpl.compile(this.settings.template),
            renderedTmpl = compiledTmpl.render({dataset: dataset, totals: totals});

          this.element.html(renderedTmpl);
        }

        // Render Pager
        if (this.settings.paging) {
          this.renderPager(pagerInfo);
        }

        // Add Aria
        $('ul', this.element).attr({'role': 'presentation'});

        // Add Checkboxes
        var first = this.element.find('li, tbody > tr').first(),
          items = this.element.find('li, tr'),
          isMultiselect = (this.settings.selectable === 'multiple');

        //Set Initial Tab Index
        first.attr('tabindex', 0);

        //Let the link be focus'd
        if (!this.settings.selectable && first.find('a').length === 1) {
          first.removeAttr('tabindex');
        }

        items.each(function (i) {
          var row = $(this);

          row.attr('role', 'option');

          if (isMultiselect) {
            // Add Selection Checkboxes
            self.element.addClass('is-muliselect');

            // Create a Toolbar for the "Selected Items" area
            var selectedToolbar = self.element.prevAll('.toolbar');
            if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
              selectedToolbar.data('toolbar').toggleMoreMenu();
            }
          }

          // Add Aria
          row.attr({'aria-posinset': i+1, 'aria-setsize': items.length});

          // Add Aria disabled
          if (row.hasClass('is-disabled')) {
            row.attr('aria-disabled','true');
          }
        });

        // TODO: Invoke the "element" here after we write an updated method.
        this.element.children().initialize();
        this.element.trigger('rendered', [dataset]);

        //Handle refresh
        this.element.off('updated').on('updated', function () {
          self.refresh();
        });
      },

      renderPager: function(updatedPagerInfo) {
        var api = this.element.data('pager');
        if (!api || !this.settings.pager) {
          return;
        }

        api.updatePagingInfo(updatedPagerInfo);
      },

      // Get the Data Source. Can be an array, Object or Url
      refresh: function () {
        this.loadData();

        if (this.list) {
          this.render(this.list.data);
        }
      },

      // Load Data from an external API
      loadData: function (ds, pagerInfo) {
        var ajaxDs = false, self = this;

        ds = ds || this.settings.dataset;
        pagerInfo = pagerInfo || {};

        if (!ds) {
          return;
        }

        function done(response, pagingInfo) {
          ds = response;
          self.render(ds, pagingInfo);
        }

        var s = this.settings.source;

        if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
          s = ds;
          ajaxDs = true;
        }

        // If paging is not active, and a source is present, attempt to retrieve information from the datasource
        // TODO: Potentially abstract this datasource concept out for use elsewhere
        if ((s) || ajaxDs) {
          switch (typeof s) {
            case 'function':
              return s(pagerInfo, done);
            case 'string':
              if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
                $.ajax({
                  url: s,
                  async: false,
                  dataType: 'json',
                  success: function(response) {
                    ds = self.settings.dataset = response;
                    return self.render(ds, pagerInfo);
                  }
                });
              }
              return;
            default:
              ds = this.settings.dataset = s;
              return this.render(s, pagerInfo);
          }
        }

        // Otherwise, simply render with the existing dataset
        this.render(ds, pagerInfo);
      },

      /**
      * Toggle all rows from selected to unselected. (Multiselect)
      */
      toggleAll: function() {
        this[this.isSelectedAll ?
          'unselectRowsBetweenIndexes' :
          'selectRowsBetweenIndexes']([0, $('li, tbody tr', this.element).length-1]);
        this.isSelectedAll = !this.isSelectedAll;
      },

      // Select rows between indexes
      selectRowsBetweenIndexes: function(indexes) {
        this.clearSelection();
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);

          if (!item.is('.is-disabled, .is-selected')) {
            this.select(item);
          }
        }
      },

      // Unselect rows between indexes
      unselectRowsBetweenIndexes: function(indexes) {
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);
          if(!item.is('.is-disabled') && item.is('.is-selected')) {
            this.select(item);
          }
        }
      },

      clearSelection: function() {
        if (window.getSelection) {
          window.getSelection().removeAllRanges();
        } else if (document.selection) {
          document.selection.empty();
        }
      },

      // Handle Resize
      handleResize: function () {
        var items = $('li .listview-heading, tr .listview-heading', this.element),
          item1 = items.eq(1),
          item1W = item1.width();

        if (item1.length && item1W) {
          items[0].style.width = item1W + 'px';
        }

        this.setChildIconsValign();

        if (this.element.data('pager')) {
          this.element.data('pager').renderBar();
        }
      },

      // For instances of Listview that are paired with a Searchfield
      // NOTE: Search functionality is called from "js/listfilter.js"
      handleSearch: function(e, searchfield) {
        var list = this.element.find('li, tbody > tr'),
            term = searchfield.val(),
            results;

        this.resetSearch(list);

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        if (!results || !results.length && !term) {
          return;
        }

        list.not(results).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');
          li.highlight(term);
        });

        this.renderPager();
      },

      resetSearch: function(list) {
        list.removeClass('hidden').each(function() {
          $(this).unhighlight();
        });
      },

      // Fix: for vertical-align to icons and buttons
      setChildIconsValign: function() {
        $('li > .icon, li > button', this.element).each(function() {
          var item = $(this),
          itemHeihgt = item.is('button') ? 42 : 22,
          row = item.closest('li'),
          padding = parseInt(row[0].style.paddingTop, 10) + parseInt(row[0].style.paddingBottom, 10),
          rowHeight = row.outerHeight() - padding;

          this.style.top = ((rowHeight - itemHeihgt)/2) +'px';
        });
      },

      focus: function (item) {
        if (item.is(':hidden') || item.is('.is-disabled')) {
          return;
        }

        item.siblings().removeAttr('tabindex');
        item.attr('tabindex', 0).focus();

        if (!this.settings.selectable && item.find('a').length === 1) {
          item.find('a').focus();
          item.removeAttr('tabindex');
        }

        if (this.settings.selectOnFocus && (this.settings.selectable !== 'multiple')) {
          this.select(item);
        }
      },

      /**
      * Remove the given list item.
      *
      * @param {jQuery|Number} li  &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      */
      remove: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        // Un-select selected item
        // and donot trigger selected event, sinnce we removeing
        if (li.is('.is-selected')) {
          this.select(li, true);
        }
        li.remove();
      },

      /**
      * Remove all list items.
      */
      clear: function () {
        var root = $(this.element.children()[0]);
        root.empty();
      },

      /**
      * Remove all selected rows entirely from the list..
      */
      removeAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          self.remove(selected);
        });
      },

      /**
      * Deselect all selected rows.
      */
      clearAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          // Un-select selected item
          self.select(selected);
        });
      },

      // Initialize sortlist
      sortInit: function(control, onEvent, attr){
        if(!attr || $.trim(attr) === '') {
          return;
        }
        $('['+ attr +']').each(function() {
          var elment = $(this),
            options = $.fn.parseOptions(elment, attr);

          elment.on(onEvent, function(e) {
            $(options.list).data(control).setSortColumn(options);
            e.preventDefault();
          });
        });
      },

      // Consider this deprecated
      setSortColumn: function(options) {
        var sort,
        field = options.orderBy || this.list.sort.field,
        reverse = options.order;

        if (!this.list.data && !field) {
          return;
        }

        reverse = reverse ?
          (reverse === 'desc') :
          (this.list.sort && this.list.sort[field] && this.list.sort[field].reverse) ? false : true;

        //reload data
        if (options.reloadApi || options.reloadApiNoSort) {
          this.loadData();
        }

        //reload data but no sort change
        if (options.reloadApiNoSort) {
          field = this.list.sort.field;
          reverse = this.list.sort[field].reverse;
        }

        sort = this.sortFunction(field, reverse);
        this.list.data.sort(sort);
        this.render(this.list.data);

        this.list.sort = {field: field};
        this.list.sort[field] = {reverse: reverse};

        this.element.trigger('sorted', [this.element, this.list.sort]);
      },

      //Overridable function to conduct sorting
      sortFunction: function(field, reverse, primer) {
        var key;
        if (!primer) {
          primer = function(a) {
            a = (a === undefined || a === null ? '' : a);
            if (typeof a === 'string') {
              a = a.toUpperCase();

              if (!isNaN(parseFloat(a))) {
                a = parseFloat(a);
              }
            }
            return a;
          };
        }
        key = primer ? function(x) { return primer(x[field]); } : function(x) { return x[field]; };
        reverse = !reverse ? 1 : -1;
        return function (a, b) {
           return a = key(a), b = key(b), reverse * ((a > b) - (b > a));
        };
      },

      /**
      * Deselect the given list item.
      * @param {jQuery|Number} li  &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      */
      unselect: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        if (li.is('.is-selected')) {
          this.select(li);
        }
      },

      /**
      * Deselect the given list item.
      * @param {jQuery|Number} li &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      * @param {Boolean} noTrigger &nbsp;-&nbsp; Do not trigger the selected event.
      */
      select: function (li, noTrigger) {
        var self = this,
          isChecked = false;

        self.selectedItems = [];
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }

        isChecked = li.hasClass('is-selected');

        //focus
        if (!li.is('[tabindex="0"]')) {
          li.siblings().removeAttr('tabindex');
          li.attr('tabindex', 0);
        }

        if (this.settings.selectable === false || this.settings.selectable === 'false') {
          return;
        }

        //Select
        if (this.settings.selectable !== 'multiple') {
          li.parent().children().removeAttr('aria-selected');
          li.parent().find('.is-selected').removeClass('is-selected');
          self.selectedItems[0] = $(this);
        }

        if (isChecked) {
          self.selectedItems = [];
          li.removeClass('is-selected');
        } else {
          if (this.settings.selectable) {
            li.addClass('is-selected');
            self.lastSelectedRow = li.index();// Rember index to use shift key
          }
        }

        li.parent().find('.is-selected').each(function (i) {
          self.selectedItems[i] = $(this);
        });

        li.attr('aria-selected', !isChecked);
        if (!noTrigger) {
          var triggerStr = isChecked ? 'unselected' : 'selected';
          this.element.triggerHandler(triggerStr, {selectedItems: this.selectedItems, elem: li});
        }

        var toolbar, toolbarControl,
          parent = this.element.closest('.card, .widget');

        if (!parent.length) {
          parent = this.element.parent();
        }
        toolbar = parent.find('.listview-toolbar, .contextual-toolbar');

        toolbarControl = toolbar.data('toolbar');

        if (self.selectedItems.length > 0) {
          if (toolbarControl) {
            toolbarControl.toggleMoreMenu();
          }
          // Order of operations: set up event, change display prop, animate, toggle menu.
          // Menu toggle takes place after the animation starts
          toolbar.one('animateopencomplete', function() {
            self.element.addClass('is-toolbar-open');
            toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
          });
          if (toolbar[0]) {
            toolbar[0].style.display = 'block';
          }
          // toolbar.animateOpen({distance: 52});
          toolbar.animateOpen({distance: 40});

          var title = toolbar.find('.title, .selection-count');
          if (!title || !title.length) {
            title = $('<div class="title selection-count"></div>');
            toolbar.prepend(title);
          }
          title.text(self.selectedItems.length + ' ' + Locale.translate('Selected'));

        } else {
          toolbar.addClass('is-hidden').one('animateclosedcomplete', function(e) {
            e.stopPropagation();
            this.style.display = 'none';
          }).animateClosed();

        }
      },

      updated: function() {
        this.refresh();
        return this;
      },

      teardown: function() {
        $('body').off('resize.listview');
        this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview afterpaging.listview').empty();
        return this;
      },

      /**
      * Detatch all events and tear down.
      */
      destroy: function() {
        this.teardown();
        this.element.removeData(pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires ListBox#events
       * @param {Object} selected  &nbsp;-&nbsp; Fires when a row is selected
       * @param {Object} unselected  &nbsp;-&nbsp; Fires when a row is deselected
       * @param {Object} rendered  &nbsp;-&nbsp; Fires after the listbox is fully rendered
       *
       */
      handleEvents: function () {
        var self = this,
          isSelect = false,
          isFocused = false,
          isMultiple = self.settings.selectable === 'multiple';

        this.element.on('focus.listview', 'li, tbody tr', function () {
          var item = $(this);

          // First element if disabled
          if (item.is(':first-child') && item.hasClass('is-disabled')) {
            var e = $.Event('keydown.listview');

            e.keyCode= 40; // move down
            isSelect = true;
            item.trigger(e);
          }

          if ((!isSelect) &&
              (!item.hasClass('is-disabled')) &&
              (self.settings.selectOnFocus) &&
              (self.settings.selectable !== 'multiple')) {

            self.select(item);
            isSelect = true;
            isFocused = true;
          }
        });

        // Key Board
        this.element.on('keydown.listview', 'li, tr, a', function (e) {
          var elem = $(this),
            item = elem.is('a') ? elem.closest('li') : $(this),
            list = item.is('a') ? item.closest('ul') : item.parent(),
            key = e.keyCode || e.charCode || 0,
            metaKey = e.metaKey;

          if (item.index() === 0 && e.keyCode === 38) {
            return;
          }

          if ((key === 40 || key === 38) && !metaKey) {// move down or up
            var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

            if (newItem.length && ($(e.target).is(item) || e.shiftKey || elem.is('a'))) {
              self.focus(newItem);
            }
            e.preventDefault();
            e.stopPropagation();  //prevent container from scrolling
          }

          if (key === 35 || (key === 40 && metaKey)) { //end
            var last = list.children().last();
            self.focus(last);
            e.stopPropagation();
            return false;
          }

          if (key === 36 || (key === 38 && metaKey)) {  //home
            var first = list.children().first();
            self.focus(first);
            e.stopPropagation();
            return false;
          }

          if (key === 32) { // Space to toggle selection
            if ($(e.target).is(item)) {
              if(isMultiple && e.shiftKey) {
                self.selectRowsBetweenIndexes([self.lastSelectedRow, item.index()]);
              } else {
                self.select(item);
              }
              e.preventDefault();
            }
          }

          // If multiSelect is enabled, press Control+A to toggle select all rows
          if (isMultiple && ((e.ctrlKey || e.metaKey) && key === 65)) {
            self.toggleAll();
            self.focus(item);
            e.preventDefault();
          }

        });

        // Selection View Click/Touch
        if (this.settings.selectable) {

          this.element.addClass('is-selectable');
          var trigger = $('.list-detail-back-button').find('.app-header'),
            pattern = $(this.element).closest('.list-detail, .builder');

          trigger.parent().onTouchClick('listview').on('click.listview', function (e) {
            if (trigger.hasClass('go-back')) {
              trigger.removeClass('go-back');
              pattern.removeClass('show-detail');
            }
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
            return false;
          });

          this.element
          .off('click.listview', 'li, tr')
          .on('click.listview', 'li, tr', function (e) {
            var item = $(this);

            if (!isFocused && !item.hasClass('is-disabled')) {
              isSelect = true;

              if(isMultiple && e.shiftKey) {
                self.selectRowsBetweenIndexes([self.lastSelectedRow, item.index()]);
                e.preventDefault();
              } else {
                self.select(item);
              }
              item.focus();
            }

            if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled')) {
              pattern.toggleClass('show-detail');
              trigger.toggleClass('go-back');
            }

            isFocused = false;
          });
        }

        if (!this.settings.hoverable || this.settings.hoverable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (!this.settings.selectable || this.settings.selectable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (this.settings.selectable === 'multiple') {
          this.element.on('change.selectable-listview', '.listview-checkbox input', function (e) {
           $(this).parent().trigger('click');
           e.stopPropagation();
          });
        }

        // For use with Searchfield
        if (this.settings.searchable) {
          this.searchfield.on('contents-checked.searchable-listview', function(e) {
            self.handleSearch(e, $(this));
          });
        }

        //If used with a Pager Control, listen for the end of the page and scroll the Listview to the top
        if (this.element.data('pager')) {
          this.element.on('afterpaging.listview', function() {
            self.element.scrollTop(0);
          });
        }

        $('body').on('resize.listview', function() {
          self.handleResize();
        });

        //Animate open and Closed from the header
        self.element.prev('.listview-header').onTouchClick().on('click', function () {
          var icon = $(this).find('.plus-minus');
          if (icon.hasClass('active')) {
            icon.removeClass('active');
            self.element.animateClosed();
          } else {
            icon.addClass('active');
            self.element.animateOpen();
          }
        });

      }

    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListView(this, settings));
      }
    });
  };


  $.fn.listbuilder = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'listbuilder',
        defaults = {
          'dataset': [], // Array of data

          // Action buttons
          // use "data-action" attributes, ie. data-action="add"
          // or jQuery elements
          'btnAdd': 'add',
          'btnEdit': 'edit',
          'btnDelete': 'delete',
          'btnGoUp': 'goup',
          'btnGoDown': 'godown',

          // Template HTML
          'template': ''+
            '<ul data-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>',

          'templateNewItem': ''+
            '<li data-value="{{text}}" role="option">'+
              '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
              '<div class="item-content"><p>{{text}}</p></div>'+
            '</li>',

          'templateItemContent': '<p>{{text}}</p>'
        },
        settings = $.extend({}, defaults, options);

    /**
    * A list of items with add/remove/delete and sort functionality.
    *
    * @class ListBuilder
    * @param {Object} dataset  &nbsp;-&nbsp; The array of data
    * @param {String} btnAdd  &nbsp;-&nbsp; The attribute to match the add button in the toolbar (ie. data-action="add")
    * @param {String} btnEdit  &nbsp;-&nbsp; The attribute to match the edit button in the toolbar (ie. data-action="edit")
    * @param {Boolean} btnDelete  &nbsp;-&nbsp; The attribute to match the delete button in the toolbar (ie. data-action="delete")
    * @param {String} btnGoUp  &nbsp;-&nbsp; The attribute to match the move up button in the toolbar (ie. data-action="goup")
    * @param {Boolean} btnGoDown  &nbsp;-&nbsp; The attribute to match the move up button in the toolbar (ie. data-action="dodown")
    * @param {String} template  &nbsp;-&nbsp; The list view markdown / template.
    * @param {String} templateItemContent  &nbsp;-&nbsp; The markdown for editing an item
    */
    function ListBuilder(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // ListBuilder Methods
    ListBuilder.prototype = {

      init: function() {
        var self = this;
        this
          .loadListview()
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Load listview
      loadListview: function() {
        var s = this.settings,
          lv = $('.listview', this.element);

        if (!s.dataset.length && lv.length && $('li', lv).length) {
          this.listApi = lv.listview({selectable: 'single'}).data('listview');
        } else if (lv.length) {
          this.listApi = lv.listview({dataset: s.dataset, template: s.template, selectable: 'single'}).data('listview');
        }
        return this;
      },

      // Init dataset
      initDataset: function() {
        var s = this.settings,
          nodes = $('.listview li', this.element);

        this.dataset = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
          var data,
            li = $(nodes[i]);
          if (s.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(s.dataset[i]));
            data.node = li;
          }
          else {
            data = this.extractNodeData(li);
          }
          this.dataset.push(data);
        }
        return this;
      },

      // Extract node data
      extractNodeData: function(node) {
        var data = {node: node, text: $.trim($('.item-content', node).text())},
          value = node.attr('data-value');
        if (typeof value !== 'undefined') {
          data.value = value;
        }
        return data;
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        // Action buttons
        var setAction = function(selector) {
          return self.isjQuery(selector) ?
            selector : (typeof selector === 'string' ?
              $('[data-action="'+ selector +'"]', self.element) : null);
        };
        s.btnAdd = setAction(s.btnAdd);
        s.btnGoUp = setAction(s.btnGoUp);
        s.btnGoDown = setAction(s.btnGoDown);
        s.btnEdit = setAction(s.btnEdit);
        s.btnDelete = setAction(s.btnDelete);

        // Init tooltips
        this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
        this.topButtons.tooltip();

        // Make Draggable
        this.ul = $('.listview ul', this.element);
        this.arrangeApi = this.ul.arrange({
          placeholder: s.templateNewItem
        }).data('arrange');

        return this;
      },

      // Handle Events
      handleEvents: function() {
        var data,
          self = this,
          s = self.settings;

        // TOP BUTTONS =============================================================================
        var topButtonsClick = function(btn, method) {
          btn.offTouchClick('listbuilder').off('click.listbuilder')
            .onTouchClick('listbuilder').on('click.listbuilder', function() {
            self[method]();
          });
        };
        topButtonsClick(s.btnAdd, 'addItem');
        topButtonsClick(s.btnGoUp, 'moveItemUp');
        topButtonsClick(s.btnGoDown, 'moveItemDown');
        topButtonsClick(s.btnEdit, 'editItem');
        topButtonsClick(s.btnDelete, 'deleteItem');

        // DRAGGABLE ===============================================================================
        self.arrangeApi.element
        .on('beforearrange.listbuilder', function(e, status) {
          var d = self.getDataByNode(status.start),
            str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

          self.arrangeApi.placeholders.attr('data-value', d.data.text)
            .find('.item-content').html(str);
        })
        .on('arrangeupdate.listbuilder', function(e, status) {
          self.updateAttributes();
          self.arrayIndexMove(self.dataset, status.startIndex, status.endIndex);
          data = self.getDataByNode(status.end);
          data.indexBeforeMove = status.startIndex;
          self.element.triggerHandler('arrangeupdate', [data]);
        });

        $('li:not(.is-disabled) '+ self.arrangeApi.handle, self.ul)
          .on('mousedown.listbuilder touchstart.listbuilder', function() {
            var li = $(this);
            if (!li.is('.is-selected')) {
              li.trigger('click');
            }
          });

        $('.listview', self.element)
          .off('selected.listbuilder')
          .on('selected.listbuilder', function(e, args) {
            var data = self.getDataByNode(args.elem[0]);
            self.element.triggerHandler('selected', [data]);
          });

        self.updatedEventsStr = 'arrangeupdate.listbuilder aftergoup.listbuilder aftergodown.listbuilder exiteditmode.listbuilder';
        self.element
          .off(self.updatedEventsStr)
          .on(self.updatedEventsStr, function(e, data) {
            self.element.triggerHandler('updated', [data]);
          });

        return this;
      }, // END: Handle Events ---------------------------------------------------------------------

      /**
      * Add an item into edit node.
      */
      addItem: function() {
        var self = this,
          s = self.settings;

        $.when(self.element.triggerHandler('beforeadd')).done(function() {
          var li, data,
            index = 0,
            node = self.listApi.selectedItems[0],
            str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

          if (node && node.length > 0) {
            data = self.getDataByNode(node);
            index = data.index + 1;
            $(str).insertAfter(node);
            li = $('li', self.ul).eq(index);
          }
          else {
            self.ul.prepend(str);
            li = $('li:first-child', self.ul);
          }

          self.dataset.push(self.extractNodeData(li));
          self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
          self.updateAttributes();
          li.trigger('click');
          self.arrangeApi.updated();
          self.editItem(true);

          data = self.dataset[index];
          self.element.triggerHandler('afteradd', [data]);
        });
      },

      /**
      * Move the currently selected item up.
      */
      moveItemUp: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index > 0) {
            $.when(self.element.triggerHandler('beforegoup', [data])).done(function() {
              var prev = node.prev();
              node.insertBefore(prev);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index - 1);
              data.indexBeforeMove = data.index;
              data.index = data.index - 1;
              self.element.triggerHandler('aftergoup', [data]);
            });
          }
        }
      },

      /**
      * Move the currently selected item down.
      */
      moveItemDown: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
            $.when(self.element.triggerHandler('beforegodown', [data])).done(function() {
              var next = node.next();
              node.insertAfter(next);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index + 1);
              data.indexBeforeMove = data.index;
              data.index = data.index + 1;
              self.element.triggerHandler('aftergodown', [data]);
            });
          }
        }
      },

      /**
      * Edit the selected item
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      editItem: function(isNewItem) {
        var node = this.listApi.selectedItems[0];
        if (node && node.length > 0) {
          if (node.is('.is-editing')) {
            this.commitEdit(node, isNewItem);
          } else {
            this.makeEditable(node, isNewItem);
          }
        }
      },

      /**
      * Make the node editable
      * @param {jQuery} node  &nbsp;-&nbsp; The node to edit
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      makeEditable: function(node, isNewItem) {
        var self = this,
          data = self.getDataByNode(node),
          container = $('.item-content', node);

        if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
          $.when(self.element.triggerHandler('beforeedit', [data])).done(function() {
            var origValue = container.text().trim(),
              editInput = $('<input name="edit-input" class="edit-input" type="text" value="'+ origValue +'" />');

            node.addClass('is-editing');
            container.html(editInput);
            editInput.focus().select();

            editInput
            .on('click.listbuilder', function() {
              return false;
            })
            .on('blur.listbuilder', function() {
              self.commitEdit(node, isNewItem);
            })
            .on('keypress.listbuilder', function (e) {
              var key = e.keyCode || e.charCode || 0;
              if (key === 13) {
                self.commitEdit(node, isNewItem);
                node.focus();
              }
            });

            self.element.triggerHandler('entereditmode', [data]);
          });
        }
      },

      /**
      * Delete the selected item.
      * @param {jQuery} node  &nbsp;-&nbsp; The node to delete
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      commitEdit: function(node, isNewItem) {
        var self = this,
          s = this.settings,
          data = self.getDataByNode(node),
          container = $('.item-content', node),
          editInput = $('.edit-input', container);

        if (isNewItem) {
          data.data.value = editInput.val();
        }
        data.data.text = editInput.val();
        editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
        container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
        node.removeClass('is-editing');
        self.element.triggerHandler('exiteditmode', [data]);
      },

      /**
      * Delete the selected item.
      */
      deleteItem: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined') {
            $.when(self.element.triggerHandler('beforedelete', [data])).done(function() {
              self.listApi.removeAllSelected();
              self.updateAttributes();
              self.dataset.splice(data.index, 1);
              self.element.triggerHandler('afterdelete', [data]);
            });
          }
        }
      },

      /**
      * Get data from dataset by node
      * @returns {Object}
      */
      getDataByNode: function(node) {
        var data = {};
        for (var i = 0,l = this.dataset.length; i < l; i++) {
          var d = this.dataset[i];
          if ($(d.node).is(node)) {
            data = {index: i, data: d};
            break;
          }
        }
        return data;
      },

      // Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Check if given object is a jQuery object
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      // Move cursor to end
      // http://stackoverflow.com/a/26900921
      moveCursorToEnd: function (el) {
        setTimeout(function() {
          if (typeof el.selectionStart === 'number') {
            el.selectionStart = el.selectionEnd = el.value.length;
          } else if (typeof el.createTextRange !== 'undefined') {
            var range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
        }, 100);
      },

      // Update attributes
      updateAttributes: function() {
        var nodes = $('li', this.ul),
          size = nodes.length;

        nodes.each(function(i) {
          $(this).attr({'aria-posinset': i + 1, 'aria-setsize': size});
        });
      },

      // Update dataset
      updateDataset: function(ds) {
        var self = this,
          nodes = $('li', this.ul),
          lv = $('.listview', this.element).data('listview');

        lv.unselectRowsBetweenIndexes([0, nodes.length-1]);
        this.settings.dataset = ds;
        lv.loadData(this.settings.dataset);

        this
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Set pre selected items
      setSelected: function() {
        $('li[selected]', this.ul).each(function() {
          var li = $(this);
          li.removeAttr('selected');
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        });
        return this;
      },

      // Make selected
      select: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Make unselected
      unselect: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Get an item from list, selector: can be
      // jQuery, DOM element, zero based index or 'first'|'last' as string
      getListItem: function(selector) {
        var li = $();
        if (this.isElement(selector) && $.contains(this.ul, selector)) {
          li = this.isjQuery(selector) ? selector : $(selector);
        } else {
          var idx = parseInt(selector),
            items = $('li', this.ul);
          if (!isNaN(idx) && (idx > -1 && idx < items.length)) {
            li = items.eq(idx); // zero based index
          } else if ((selector + '').toLowerCase() === 'first') {
            li = items.first(); // first
          } else if ((selector + '').toLowerCase() === 'last') {
            li = items.last(); // last
          }
        }
        // Make sure to return only one item -or- null
        return (li.length < 1) ? null : ((li.length > 1) ? li.eq(0) : li);
      },

      // Check if given object is a DOM object
      isElement: function(obj) {
        return (this.isjQuery(obj) && obj.get(0) instanceof Element) || obj instanceof Element;
      },

      // Make enable
      enable: function () {
        this.element.removeClass('is-disabled')
          .find('.toolbar .buttonset button').removeAttr('disabled').end()
          .find('.toolbar .buttonset button[data-original-disabled]')
            .attr('disabled', 'disabled').removeAttr('data-original-disabled');

        this.ul
          .find('li').removeClass('is-disabled').end()
          .find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
      },

      // Make disable
      disable: function () {
        this.element.addClass('is-disabled')
          .find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end()
          .find('.toolbar .buttonset button').attr('disabled', 'disabled');

        this.ul
          .find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end()
          .find('li').addClass('is-disabled');
      },

      // Unbind all events
      unbind: function() {
        this.element.off(this.updatedEventsStr);
        $('.listview', this.element).off('selected.listbuilder');

        $('li '+ this.arrangeApi.handle, this.ul)
          .off('mousedown.listbuilder touchstart.listbuilder');

        this.arrangeApi.element
          .off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();

        this.topButtons.off('click.listbuilder').each(function() {
          $(this).data('tooltip').destroy();
        });

        this.listApi.destroy();
        return this;
      },

      // Update this plugin
      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListBuilder(this, settings));
      }
    });
  };


  $.fn.circlepager = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'circlepager',
        defaults = {
          slidesToShow: 1,
          startingSlide: null,
          loop: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Circle Pager Displays content in a sliding carousel and has paging buttons.
    *
    * @class CirclePager
    * @param {String} slidesToShow  &nbsp;-&nbsp; The number of slides to show in one view / pane
    * @param {String} startingSlide  &nbsp;-&nbsp; First showing slide/group, an 0-based integer
    * @param {String} loop  &nbsp;-&nbsp;  Setting loop: true will loop back after next/previous reached to end
    *
    */
    function CirclePager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // CirclePager Methods
    CirclePager.prototype = {

      init: function() {
        this.setElements();

        if (this.slides.length) {
          this.createControls();
          this.handleEvents();
          this.showCollapsedView();
          this.initActiveSlide();
        }
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        this.container = $('.slides', this.element);
        this.slidesJQ = $('.slide', this.element);
        this.slidesToShow = s.slidesToShow;
        this.slides = [];
        this.slidesJQ.each(function() {
          self.slides.push({ node: $(this) });
        });

        if (this.slides.length) {
          // Do not go less than slide width
          this.element.css({'min-width': this.slidesJQ.eq(0).width() + 5});
        }

        this.activeIndex = s.startingSlide !== null &&
          s.startingSlide > -1 && s.startingSlide < this.slides.length ?
            s.startingSlide : 0;
      },

      // Create controls
      createControls: function() {
        var len = this.slides.length,
          html = '<div class="controls">',
          htmlContent = '',
          numOfButtons = 0,
          i, l, slide, temp, href, text, buttonText,
          last, lastIndex, isSingle, isDisabled,
          previousButton, nextButton;

        for (i = 0, l = len; i < l; i += this.slidesToShow) {
          temp = '';
          numOfButtons++;
          isSingle = (this.slidesToShow === 1) || (len - i === 1);
          text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf') + '';
          // Keep href in english language only
          href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}';

          // Collect as much bullets need to present
          for (var g = 0; g < this.slidesToShow && (i + g) < len; g++) {
            temp += (i + g + 1) + ', ';
          }
          text = text.replace(isSingle ? '{1}' : '{2}', len);
          href = href.replace(isSingle ? '{1}' : '{2}', len);
          temp = temp.slice(0, -2);
          lastIndex = temp.lastIndexOf(',');
          last = temp.substr(lastIndex + 2);

          // Controls for single slide in view
          if (isSingle) {
            isDisabled = '';
            slide = this.slides[i].node;

            // Set disabled
            if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
              isDisabled = ' disabled tabindex="-1"';
              this.slides[i].isDisabled = true;
            }

            // Set default starting slide
            if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
              this.activeIndex = i;
            }

            // Use custom text if supplied
            buttonText = slide.attr('data-button-text');
            text = (buttonText && buttonText.length) ?
              buttonText : text.replace('{0}', temp);

            // href = (buttonText && buttonText.length) ?
            //   '#'+ $.trim(text) : href.replace('{0}', temp);
            href = href.replace('{0}', temp);

          }

          // Controls for multiple slides in view
          else {
            temp = temp.substr(0, lastIndex);
            text = text.replace('{1}', last).replace('{0}', temp);
            href = href.replace('{1}', last).replace('{0}', temp);
          }

          href = href.toLowerCase().replace(/[\s,--]+/g, '-');

          htmlContent += '<a href="'+ href +'" class="control-button hyperlink hide-focus"'+ isDisabled +'><span class="audible">'+ text +'</span></a>';
        }

        html += htmlContent + '</div>';

        // Previous/Next buttons
        this.isBulletsNav = this.element.width() > numOfButtons * 29;
        previousButton = $('.btn-previous', this.element);
        nextButton = $('.btn-next', this.element);
        if (!this.isBulletsNav) {
          if (!previousButton.length) {
            html += '<button class="btn-previous" type="button">' + $.createIcon('left-arrow') + '<span class="audible">'+
                Locale.translate('Previous') +'</span></button>';
          }
          if (!nextButton.length) {
            html += '<button class="btn-next" type="button">' + $.createIcon('right-arrow') + '<span class="audible">'+
                Locale.translate('Next') +'</span></button>';
          }
        } else {
          previousButton.add(nextButton).remove();
        }

        this.element.append(html);
      },

      // Check if given element is visible in container
      isVisibleInContainer: function(element) {
        if (element && element[0]) {
          var eRect = element[0].getBoundingClientRect();
          var cRect = this.element[0].getBoundingClientRect();
          return (eRect.left > cRect.left && eRect.left < (cRect.left + cRect.width) &&
            eRect.top > cRect.top && eRect.top < (cRect.top + cRect.height));
        }
        return -1;
      },

      // Update number of slides to show in view
      updateSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        this.settings.slidesToShow = numOfSlides || 1;
        this.updated();
        return this;
      },

      // Make sure max number of slides to show in view
      responsiveSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        var self = this;
        this.slidesToShow = numOfSlides || this.settings.slidesToShow;
        this.unbind().slidesJQ.css('width', '');
        if (this.slides.length) {
          setTimeout(function() {
            self.createControls();
            self.handleEvents();
            self.showCollapsedView();
            self.initActiveSlide();
          }, 0);
        }
      },

      /**
      * Show a slide to First Slide
      * @param {String} index  &nbsp;-&nbsp; The index of the slide to show (0 based)
      */
      show: function(index) {
        if (!this.isActive) {
          return;
        }
        index = typeof index !== 'undefined' ? index : this.activeIndex;
        this.activeIndex = index;

        // var isBulletsNav = this.element.width() > this.controlButtons.length * 30;
        var left = index > 0 ? ((Locale.isRTL() ? '' : '-') + (index * 100) +'%') : 0;
        this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
        this.container[0].style.left = left;

        // Make sure bullets navigation do not overflow
        if (!this.isBulletsNav) {
          this.element.addClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible').end()
            .eq(index).find('span').removeClass('audible');
        } else {
          this.element.removeClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible');
        }

        // Set focus
        if (this.isFocus && this.isBulletsNav) {
          this.isFocus = false;
          this.controlButtons.eq(index).focus();
        }
      },

      /**
      * Move to First Slide
      */
      first: function() {
        this.show(0);
      },

      /**
      * Move to Last Slide
      */
      last: function() {
        this.show(Math.round(this.slides.length/this.slidesToShow)-1);
      },

      /**
      * Move to Previous Slide
      */
      prev: function() {
        var self = this,
          prev = this.activeIndex > 0 ?
            this.activeIndex - 1 : (this.settings.loop ? Math.round(this.slides.length/this.slidesToShow)-1 : 0);

        if (this.slides[prev].isDisabled) {
          setTimeout(function() {
            self.prev();
          }, 0);
          this.activeIndex = prev;
          return false;
        }
        this.show(prev);
      },

      /**
      * Move to Next Slide
      */
      next: function() {
        var self = this,
          next = this.activeIndex >= Math.round(this.slides.length/this.slidesToShow)-1 ?
            (this.settings.loop ? 0 : this.activeIndex) : this.activeIndex + 1;

        if (this.slides[next].isDisabled) {
          setTimeout(function() {
            self.next();
          }, 0);
          this.activeIndex = next;
          return false;
        }
        this.show(next);
      },

      // Make active
      showCollapsedView: function() {
        this.isActive = true;
        this.element.addClass('is-active');
        this.container[0].style.width = (100 * this.slides.length) +'%';
        if (this.settings.slidesToShow > 1 &&
           (this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width())) {
          this.responsiveSlidesToShow(this.slidesToShow - 1);
          return;
        }
        for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
          this.slidesJQ[i].style.width = ((100/this.slidesToShow) / this.slides.length) +'%';
        }
        this.show();
      },

      // Make un-active
      showExpandedView: function() {
        this.isActive = false;
        this.element.removeClass('is-active');
        this.element[0].style.width = '';
        this.container[0].style.width = '';
        this.container[0].style.left = '';
      },

      // Initialize active slide
      initActiveSlide: function() {
        if (this.slides[this.activeIndex].isDisabled) {
          this.next();
          return false;
        }
        this.show();
      },

      unbind: function() {
        $('body').off('resize.circlepager');
        this.element.off('focus.circlepager keydown.circlepager', '*');
        this.controlButtons.off('click.circlepager keydown.circlepager');
        $('.btn-previous, .btn-next', this.element).off('click.circlepager');
        $('.controls', this.element).remove();
        this.showExpandedView();
        return this;
      },

      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },

      // Handle events
      handleEvents: function() {
        var self = this;

        // Previous button
        $('.btn-previous', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.prev();
            e.stopImmediatePropagation();
          });

        // Next button
        $('.btn-next', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.next();
            e.stopImmediatePropagation();
          });

        this.controlButtons = $('.control-button', this.element);
        this.controlButtons.each(function(index) {
          var btn = $(this);
          btn.hideFocus();

          // Handle clicks for bottom bullet links
          btn.on('click.circlepager', function(e) {
            e.preventDefault();
            if (self.slides[index].isDisabled) {
              return;
            }
            self.show(index);
          });

        });

        // Handle keyboard events

        // Prevent hidden slide's content to be get focused
        // on focusable elements in slides content
        this.element.on('focus.circlepager', '*', function(e) {
          var handled = false;
          if (!self.isVisibleInContainer($(this))) {
            var canfocus = self.element.find(':focusable');
            for (var i = 0, l = canfocus.length; i < l; i++) {
              if (self.isVisibleInContainer(canfocus.eq(i))) {
                canfocus.eq(i).focus();
                handled = true;
                break;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });
        // Keydown on focusable elements in slides content to
        // prevent hidden slide's content to be get focused
        this.element.on('keydown.circlepager', '*', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            canfocus = $(':focusable'),
            index = canfocus.index(this);

          if (key === 9) {//tab
            // Using shift key with tab (going backwards)
            if (e.shiftKey) {
              for (var i = index-1; i >= 0; i--) {
                if ((self.element.has(canfocus.eq(i)).length < 1) ||
                    (self.isVisibleInContainer(canfocus.eq(i)))) {
                  canfocus.eq(i).focus();
                  handled = true;
                  break;
                }
              }
            }
            // Using only tab key (going forward)
            else {
              if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
                self.controlButtons.first().focus();
                handled = true;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });

        // Control buttons
        this.controlButtons.on('keydown.circlepager', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            isRTL = Locale.isRTL();

          // Left and Right arrow keys
          if ([37, 39].indexOf(key) !== -1) {
            self.isFocus = true; // Move focus
            if (e.altKey) {
              // [Alt + Left/Right arrow] to move to the first or last
              if ((key === 37 && !isRTL) || (key === 39 && isRTL)) {
                self.first();
              } else {
                self.last();
              }
            }
            // Left and Right arrow keys to navigate
            else {
              if ((!isRTL && key === 37) || (isRTL && key === 39)) {
                self.prev();
              } else {
                self.next();
              }
              handled = true;
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Set max number of slides can view on resize
        $('body').on('resize.circlepager', function() {
          self.responsiveSlidesToShow();
        });

      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CirclePager(this, settings));
      }
    });
  };


  $.fn.pager = function(options) {

    // Settings and Options
    var pluginName = 'pager',
        defaults = {
          componentAPI: undefined,
          type: 'list',
          position: 'bottom',
          activePage: 1,
          hideOnOnePage: false,
          source: null,
          pagesize: 15,
          pagesizes: [15, 25, 50, 75],
          showPageSizeSelector: true,
          indeterminate: false
        },
        settings = $.extend({}, defaults, options);

    var PAGER_NON_NUMBER_BUTTON_SELECTOR = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last)';

    /**
    * The Pager Component supports paging on lists.
    *
    * @class Pager
    * @param {String} componentAPI  &nbsp;-&nbsp; If defined, becomes the definitive way to call methods on parent component.
    * @param {String} type  &nbsp;-&nbsp; Different types of pagers: list, table and more
    * @param {String} position  &nbsp;-&nbsp; Can be on 'bottom' or 'top'.
    * @param {Number} activePage  &nbsp;-&nbsp; Start on this page
    * @param {Boolean} hideOnOnePage  &nbsp;-&nbsp; If true, hides the pager if there is only one page worth of results.
    * @param {Function} source  &nbsp;-&nbsp; Call Back Function for Pager Data Source
    * @param {Number} pagesize  &nbsp;-&nbsp; Can be calculated or a specific number
    * @param {Array} pagesizes  &nbsp;-&nbsp; Array of numbers of the page size selector
    * @param {Boolean} showPageSizeSelector  &nbsp;-&nbsp; If false will not show page size selector
    * @param {Boolean} indeterminate  &nbsp;-&nbsp; If true will not show anything that lets you go to a specific page
    *
    */
    function Pager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Pager.prototype = {

      pagerInfo: {},

      init: function() {
        this.setup();
        this.createPagerBar();
        this.setActivePage(this.settings.activePage); //Get First Page
        this.renderBar();
        this.renderPages('initial');
        this.handleEvents();
      },

      setup: function() {

        // Add [pagesize] if not found in [pagesizes]
        if($.inArray(this.settings.pagesize, this.settings.pagesizes) === -1) {
          var sortNumber = function (a, b) {
            return a - b;
          };
          this.settings.pagesizes.push(this.settings.pagesize);
          this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
        }

        var widgetContainer = this.element.parents('.card, .widget');

        // Adjust for the possibility of the pager being attached to a Table instead of normal grid markup
        if (this.element.is('tbody')) {
          this.isTable = true;
          this.settings.type = 'table';
          this.mainContainer = this.element.closest('.datagrid-container');

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.mainContainer.data('datagrid');
          }

          if (widgetContainer.length) {
            widgetContainer[0].classList.add('has-datagrid');
          }
        }

        // If contained by a widget/card container, build some settings for that
        var listviewContainer = this.element.is('.listview');
        if (listviewContainer.length) {
          this.isTable = false;
          this.settings.type = 'list';
          this.mainContainer = listviewContainer;

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.element.data('listview');
          }
        }

        this.isRTL = Locale.isRTL();

        return this;
      },

      createPagerBar: function () {
        this.pagerBar = this.element.prev('.pager-toolbar');

        if (this.pagerBar.length === 0) {
          this.pagerBar = $('<ul class="pager-toolbar"></ul>');
          var buttons = '<li class="pager-prev">' +
              '<a href="#" rel="prev" title="PreviousPage">' + $.createIcon({ icon: 'previous-page' }) +
                '<span class="audible">' + Locale.translate('PreviousPage') + '</span>' +
              '</a>' +
            '</li>' +
            '<li class="pager-next">' +
              '<a href="#" rel="next" title="NextPage">' + $.createIcon({ icon: 'next-page' }) +
                '<span class="audible">' + Locale.translate('NextPage') + '</span>' +
              '</a>' +
            '</li>';

          if (this.settings.type === 'table') {
            buttons = '<li class="pager-first">' +
              '<a href="#" title="FirstPage">' + $.createIcon({ icon: 'first-page' }) +
                '<span class="audible">' + Locale.translate('FirstPage') + '</span>' +
              '</a>' +
            '</li>' +
            buttons +
            '<li class="pager-last">' +
              '<a href="#" title="LastPage">' + $.createIcon({ icon: 'last-page' }) +
                '<span class="audible">' + Locale.translate('LastPage') + '</span>' +
              '</a>' +
            '</li>';
          }

          this.pagerBar.html(buttons);

          this.pagerBar.children('li').children('a').button();
        }

        if (this.isTable) {
          this.mainContainer.after(this.pagerBar);
        } else {
          if (this.settings.position ==='bottom') {
            this.element.after(this.pagerBar);
          } else {
            this.element.before(this.pagerBar);
          }
        }

        // Inside of Listviews, place the pager bar inside of the card/widget footer
        var widgetContainer = this.element.closest('.card, .widget');
        if (widgetContainer.length) {
          var self = this,
            widgetTypes = ['widget', 'card'];

          widgetTypes.forEach(function(type) {
            var widgetContent = self.element.closest('.' + type + '-content');
            if (!widgetContent.length) {
              return;
            }

            var widgetFooter = widgetContent.next('.' + type + '-footer');
            if (!widgetFooter.length) {
              widgetFooter = $('<div class="'+ type +'-footer"></div>').insertAfter(widgetContent);
            }

            self.pagerBar.appendTo(widgetFooter);
          });
        }

        this.pagerBar.find('a').tooltip();
      },

      // Attach All relevant events
      handleEvents: function () {
        var self = this;

        // Set element to be focused after paging
        self.element.on('afterpaging.pager', function () {
          var isVisible = $('li[tabindex]:visible, td[tabindex]:visible', self.element);
          if (!isVisible.length) {
            $('li:visible:first, td:visible:first', self.element).attr('tabindex', '0');
          }

          // Fix: Firefox by default to not allow keyboard focus on links
          $('li a', self.pagerBar).each(function() {
            var a = $(this),
              li = a.closest('li');

            if (!a.is('[disabled]')) {
              li.attr('tabindex', '0').on('focus.pager', function() {
                $('a', this).focus();
              });
            }
          });
        });

        //Attach button click and touch
        this.pagerBar.onTouchClick('pager', 'a').on('click.pager', 'a', function (e) {
          var li = $(this).parent();
          e.preventDefault();

          if ($(this).attr('disabled')) {
            return;
          }

          if (li.is('.pager-prev')) {
            self.setActivePage(self.activePage - 1, false, 'prev');
            return false;
          }

          if (li.is('.pager-next')) {
            self.setActivePage((self.activePage === -1 ? 0 : self.activePage)  + 1, false, 'next');
            return false;
          }

          if (li.is('.pager-first')) {
            self.setActivePage(1, false, 'first');
            return false;
          }

         if (li.is('.pager-last')) {
            self.setActivePage(self.pageCount(), false, 'last');  //TODO Calculate Last Page?
            return false;
          }

          //Go to the page via the index of the button
          self.setActivePage($(this).parent().index() + (self.settings.type === 'table' ? -1 : 0), false, 'page');

          return false;
        })
        .on('focus.pager', 'a', function() {
          var li = $(this).parent('li');
          li.addClass('is-focused');
        })
        .on('blur.pager', 'a', function() {
          var li = $(this).parent('li');
          li.removeClass('is-focused');
        });

        //Toolbar functionality
        this.pagerBar.on('keydown.pager', 'a', function (e) {
          e = e || window.event;
          var key = e.which || e.keyCode || e.charCode || false,
            parent = $(this).parent(),
            btn = ((key === 37 || key === 9 && e.shiftKey) ? parent.prev() : (key === 39 ? parent.next() : $()));

          if (key === 9 && e.shiftKey && parent.prev().is('.pager-prev, .pager-first, .pager-count') ||
              key === 9 && e.shiftKey && parent.is('.pager-prev, .pager-first')) {
            parent.removeAttr('tabindex');
            setTimeout(function () {
              parent.attr('tabindex', '0');
            }, 0);
          }
          btn = $('a', btn).length ? btn : $(':text', btn);
          if (btn.length && !btn.is('[disabled]')) {
            btn.focus();
          }
        });
      },

      //Show page size selector
      showPageSizeSelector: function(toggleOption) {
        toggleOption = (toggleOption + '').toLowerCase() === 'true';
        this.settings.showPageSizeSelector = toggleOption;
        if (toggleOption) {
          this.isShowPageSizeSelectorCall = toggleOption;
          this.pageCount();
        } else {
          this.pagerBar.find('.pager-pagesize').remove();
        }
      },

      //Set or Get Current Page
      setActivePage: function(pagingInfo, force, op) {
        var lis = this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR),
          pageNum;

        // Backwards compatibility with having "pageNum" as the first argument
        // instead of "pagingInfo"
        if (!isNaN(pagingInfo)) {
          pageNum = pagingInfo;
          pagingInfo = {
            activePage: pageNum
          };
        }

        // Check to make sure our internal active page is set
        if (!this.activePage || isNaN(this.activePage)) {
          this.activePage = this.settings.activePage;
        }

        // If any of the following conditions are met, don't rerender the pages.
        // Only rerender the pager bar.
        if (pageNum === undefined ||
            pageNum === 0 ||
            isNaN(pageNum) ||
            pageNum > this.pageCount() ||
            (pageNum === this.activePage && !force)) {

          this.renderBar(pagingInfo);
          return this.activePage;
        }

        this.activePage = pageNum;

        //Remove selected
        if (!this.settings.source) {
          lis.filter('.selected').removeClass('selected').removeAttr('aria-selected')
            .find('a').removeAttr('aria-disabled')
              .find('.audible').html(Locale.translate('Page'));

          //Set selected Page
          lis.eq(pageNum-1).addClass('selected').attr('aria-selected', true)
            .find('a').attr('aria-disabled', true)
              .find('.audible').html(Locale.translate('PageOn'));
        }

        this.renderBar(pagingInfo);
        this.renderPages(op);
        if (this.settings.componentAPI) {
          this.settings.componentAPI.saveUserSettings();
        }
        return pageNum;
      },

      _pageCount: 0,

      //Get/Set Total Number of pages
      pageCount: function(pages) {
        var self = this,
          isShowPageSizeSelectorCall = this.isShowPageSizeSelectorCall;

        // Remove call, after cached
        delete this.isShowPageSizeSelectorCall;

        if (pages === undefined && this.settings.indeterminate) {
          this._pageCount = this.settings.pagesize;
        }

        if (pages === undefined && !this.settings.source && !isShowPageSizeSelectorCall) {
          return this._pageCount;
        }

        if (pages !== undefined) {
          this._pageCount = pages;
        }

        //Add in fake pages
        if (!this.isTable) {
          var i, thisClass, thisText, isAriaSelected, isAriaDisabled;
          this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR).remove();

          for (i = pages; i > 0; i--) {
            if (i === (this.activePage || 1)) {
              thisClass = 'class="selected"';
              thisText = Locale.translate('PageOn');
              isAriaSelected = 'aria-selected="true"';
              isAriaDisabled = 'aria-disabled="true"';
            } else {
              thisClass = '';
              thisText = Locale.translate('Page');
              isAriaSelected = '';
              isAriaDisabled = '';
            }

            $('<li '+ thisClass + isAriaSelected +'><a href="#" '+ isAriaDisabled +'><span class="audible">'+ thisText +' </span>'+ i +'</a></li>').insertAfter(this.pagerBar.find('.pager-prev'));
          }
        }

        if (this.isTable && !this.settings.indeterminate && this.pagerBar.find('.pager-count').length === 0) {
          var text = Locale.translate('PageOf');
          text = text.replace('{0}', '<input name="pager-pageno" value="' + this.activePage + '">');
          text = text.replace('{1}', '<span class="pager-total-pages">' + (pages || 1) + '</span>');
          $('<li class="pager-count"><label>'+ text +' </label>').insertAfter(this.pagerBar.find('.pager-prev'));

          //Setup interactivty with the numeric page input
          var lastValue = null;

          this.pagerBar.find('.pager-count input')
          .on('focus', function () {
            lastValue = $(this).val();
          }).on('blur', function () {
            if (lastValue !== $(this).val()) {
              $(this).val(self.setActivePage(parseInt($(this).val()), false, 'page'));
            }
          }).on('keydown', function (e) {
            if (e.which === 13) {
              self.setActivePage(parseInt($(this).val()), false, 'page');
            }
          });
        }

        //Add functionality to change page size.
        if (this.isTable && this.pagerBar.find('.btn-menu').length === 0 && self.settings.showPageSizeSelector) {
          var pageSize = $('<li class="pager-pagesize"></li>'),
            pageSizeButton = $('<button type="button" class="btn-menu">' +
              '<span>' + Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize) + '</span> ' +
              $.createIcon({ icon: 'dropdown' }) +
              ' </button>').appendTo(pageSize);

          pageSize.insertAfter(this.pagerBar.find('.pager-last'));

          var menu = $('<ul class="popupmenu has-icons"></ul>');

          for (var k = 0; k < self.settings.pagesizes.length; k++) {
            var size = self.settings.pagesizes[k];
            menu.append('<li '+ (size === self.settings.pagesize ? ' class="is-checked"' : '') +'><a href="#">' + size + '</a></li>');
          }

          pageSizeButton.after(menu);

          var popupOpts = {
            placementOpts: {
              parent: pageSizeButton,
              parentXAlignment: (this.isRTL ? 'left' : 'right'),
              strategies: ['flip']
            }
          };

          pageSizeButton.popupmenu(popupOpts).on('selected.pager', function (e, args) {
            var tag = args;
            tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
            tag.parent('li').addClass('is-checked');
            self.settings.pagesize = parseInt(tag.text());

            if (self.settings.componentAPI) {
              self.settings.componentAPI.settings.pagesize = self.settings.pagesize;
            }
            self.setActivePage(1, true, 'first');
          });
        }

        var pattern = (''+ this._pageCount).replace(/\d/g, '#');
        this.pagerBar.find('.pager-count input').attr('data-mask', '').mask({pattern: pattern, mode: 'number', processOnInitialize: false});

        this._pageCount = this._pageCount || 1;

        return this._pageCount;
      },

      // Reliably gets all the pre-rendered elements in the container and returns them for use.
      getPageableElements: function() {
        var elements = this.element.children().not('.datagrid-expandable-row');

        // Adjust for cases where the root is a <ul>
        if (elements.is('ul')) {
          elements = elements.children();
        }

        return elements;
      },

      /**
       * Renders the pager bar based on derived or forced settings.
       * @private
       * @param {SohoPagingInfo} pagingInfo - an object containing information on how to render the pager.
       * @returns {undefined}
       */
      renderBar: function(pagingInfo) {
        //How many can fit?
        var pb = this.pagerBar,
          elems, pc,
          width = (this.element.parent().width() / pb.find('li:first').width()),
          VISIBLE_BUTTONS = 3, // Take out the ones that should be visible (buttons and selected)
          howMany = Math.floor(width - VISIBLE_BUTTONS);

        if (!pagingInfo) {
          pagingInfo = {};
        }

        //Check Data Attr
        if (this.element.attr('data-pagesize')) {
          this.settings.pagesize = this.element.attr('data-pagesize');
        }

        //Adjust Page count numbers
        if (!this.settings.source) {
          var pageableLength = this.getPageableElements().not('.is-filtered').length;
          pc = Math.ceil(pageableLength/this.settings.pagesize);

          if (this.isTable) {
            var isFiltered = function(value) {
              return !value.isFiltered;
            },
            dataLength = this.settings.dataset.filter(isFiltered).length;

            pc = Math.ceil(dataLength/this.settings.pagesize);
          }
          this.pageCount(pc);
        }

        // Update the input field's number
        this.pagerBar
          .find('.pager-count input').val(this.activePage);

        // Update the total number of pages
        if (this._pageCount !== '0' && !isNaN(this._pageCount)) {
          this.pagerBar.find('.pager-total-pages').text(this._pageCount);
        }

        // Update the number of records per page
        this.pagerBar.find('.btn-menu span')
          .text(Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize));

        // Refresh Disabled
        var prev = pb.find('.pager-prev a'),
          next = pb.find('.pager-next a'),
          first = pb.find('.pager-first a'),
          last = pb.find('.pager-last a'),
          prevGroup = prev.add(first).add('.pager-prev').add('.pager-first'),
          nextGroup = next.add(last).add('.pager-next').add('.pager-last'),
          disabledAttrs = {'disabled': 'disabled', 'tabindex': -1};

        // Reset all pager buttons' disabled/focusable states
        this.pagerBar[0].classList.remove('hidden');
        prevGroup.add(nextGroup).removeAttr('disabled tabindex');

        // Explicit false turns buttons back on.
        if (pagingInfo.firstPage === false) {
          prevGroup.removeAttr('disabled').removeAttr('tabindex');
        }
        if (pagingInfo.lastPage === false) {
          nextGroup.removeAttr('disabled').removeAttr('tabindex');
        }

        // First page
        if (pagingInfo.firstPage === true || (pagingInfo.firstPage === undefined && this.activePage === 1)) {
          prevGroup.attr(disabledAttrs);

          if (pagingInfo.lastPage !== true) {
            nextGroup.attr({'tabIndex': 0});
          }
        }

        // Last page
        if (pagingInfo.lastPage === true || (pagingInfo.lastPage === undefined && this.activePage === this.pageCount())) {
          nextGroup.attr(disabledAttrs);

          if (pagingInfo.firstPage !== true) {
            prevGroup.attr({'tabindex': 0});
          }
        }

        // Hide the entire pager bar if we're only showing one page, if applicable
        if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
          this.pagerBar[0].classList.add('hidden');
        }

        // Hide the entire pager bar if both sides are disabled, if applicable
        if ((pagingInfo.firstPage === true && pagingInfo.lastPage === true) && pagingInfo.hideDisabledPagers) {
          this.pagerBar[0].classList.add('hidden');
        }

        // Remove from the front until selected is visible and we have at least howMany showing
        // rowTemplate
        if (!this.settings.source) {
          elems = pb.find(PAGER_NON_NUMBER_BUTTON_SELECTOR);
          elems.show();
          if (elems.length < howMany) {
            return;
          }

          elems.each(function () {
            var li = $(this);
            if (pb.find('.pager-next').offset().top - pb.offset().top > 1 && !li.is('.selected')) {
              $(this).hide();
            }
          });

        }
      },

      // Render Paged Items
      renderPages: function(op) {
        var expr,
          self = this,
          request = {
            activePage: self.activePage,
            pagesize: self.settings.pagesize,
            type: op,
            total: self.settings.componentAPI ? self.settings.componentAPI.settings.dataset.length : -1
          };

        //Make an ajax call and wait
        setTimeout(function () {
          var doPaging = self.element.triggerHandler('beforepaging', request);
          if (doPaging === false) {
            return;
          }

          if (self.settings.source && op) {
            var response;

            response = function(data, pagingInfo) {
              if (pagingInfo && pagingInfo.activePage) {
                if (pagingInfo.activePage > -1) {
                  self.activePage = pagingInfo.activePage;
                }
              }

              //Render Data
              pagingInfo.preserveSelected = true;

              // Call out to the component's API to pull in dataset information.
              // This method should also tell the Pager how to re-render itself.
              self.settings.componentAPI.loadData(data, pagingInfo, true);

              setTimeout(function () {
                self.element.trigger('afterpaging', pagingInfo);
              },1);
              return;
            };

            if (self.settings.componentAPI.sortColumn && self.settings.componentAPI.sortColumn.sortId) {
              request.sortAsc = self.settings.componentAPI.sortColumn.sortAsc;
              request.sortField = self.settings.componentAPI.sortColumn.sortField;
              request.sortId = self.settings.componentAPI.sortColumn.sortId;
            }

            if (self.settings.componentAPI.filterExpr) {
               request.filterExpr = self.settings.componentAPI.filterExpr;
            }
            self.settings.source(request, response);
          }

          //Make an ajax call and wait
          self.element.trigger('paging', request);
          var elements = self.getPageableElements();

          //Render page objects
          if (!self.settings.source) {
            var rows = self.settings.pagesize;

            self.updatePagingInfo(request);

            if (self.settings.componentAPI && typeof self.settings.componentAPI.renderRows === 'function') {
              self.settings.componentAPI.renderRows();
            }

            elements.hide();

            //collapse expanded rows
            self.element.children()
              .filter('.datagrid-expandable-row.is-expanded')
                .removeClass('is-expanded').hide()
                .prev().removeClass('.is-expanded')
                  .find('.plus-minus').removeClass('active');

            expr = (self.activePage === 1 ? ':not(".is-filtered"):lt('+ rows +')' : ':not(".is-filtered"):lt('+ ((self.activePage) * rows) +'):gt('+ (((self.activePage-1) * rows) -1) +')');

            elements.filter(expr).show();
          } else {
            elements.show();
          }

          if (!self.settings.source) {
            self.element.trigger('afterpaging', request);
          }

        }, 0);
      },

      /**
       * Updates this instance of pager with externally-provided settings.
       * @param {Object} pagingInfo - contains settings that will change buttons on the pager.
       * @param {number} pagingInfo.pagesize - the number of items visible per page
       * @param {number} pagingInfo.total - the total number of pages
       * @param {number} pagingInfo.activePage - the currently visible page
       * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the first one
       * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the last one
       * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely hidden if all buttons are disabled
       */
      updatePagingInfo: function(pagingInfo) {
        if (!pagingInfo) {
          return;
        }

        // Grab and retain the pagesize
        if (pagingInfo.pagesize) {
          this.settings.pagesize = pagingInfo.pagesize;
          if (this.isTable && this.settings.componentAPI) {
            this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
          }
        }

        // Set a default total if none are defined.
        if (!pagingInfo.total) {
          pagingInfo.total = 0;
        }

        if (this.settings.source) {
          this._pageCount = Math.ceil(pagingInfo.total/this.settings.pagesize);
          //Set first and last page if passed
          // If we get a page number as a result, rendering has already happened and
          // we should not attempt to re-render.
          return this.setActivePage(pagingInfo, false, 'pageinfo');
        }

        this.renderBar(pagingInfo);
      },

      /**
       * Tear down and detatch all events
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Pager(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.place = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'place',
        defaults = {
          bleedFromContainer: false, // If true, allows positioned content to bleed outside of a defined container.
          callback: null, // If defined, provides extra placement adjustments after the main calculation is performed.
          container: null, // If defined, contains the placement of the element to the boundaries of a specific container element.
          parent: null, // If defined, will be used as the reference element for placement this element.
          parentXAlignment: 'center',
          parentYAlignment: 'center', // Only used for parent-based placement. Determines the alignment of the placed element against its parent. value 0 === X, value 1 === Y
          placement: 'bottom', // If defined, changes the direction in which placement of the element happens
          strategies: ['nudge'] // Determines the "strategy" for alternatively placing the element if it doesn't fit in the defined boundaries.  Only matters when "parent" is a defined setting.  It's possible to define multiple strategies and execute them in order.
        },
        strategies = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'],
        placements = ['top', 'left', 'right', 'bottom', 'center'],
        xAlignments = ['left', 'center', 'right'],
        yAlignments = ['top', 'center', 'bottom'],
        settings = $.extend({}, defaults, options);

    /**
     * Object that contains coordinates along with temporary, changeable properties.
     * This object gets passed around the Place Behavior and modified during each phase of positioning.
     * This object is also passed to all callbacks and event listeners for further modification.
     * @constructor
     * @param {object} placementOptions
     */
    function PlacementObject(placementOptions) {
      var self = this,
        possibleSettings = [
          'x', 'y',
          'container', 'containerOffsetX', 'containerOffsetY',
          'callback',
          'parent', 'parentXAlignment', 'parentYAlignment',
          'useParentWidth', 'useParentHeight',
          'placement',
          'strategies'
        ];

      possibleSettings.forEach(function settingIterator(val) {
        if (placementOptions[val] === null) {
          return;
        }

        if (val === 'x' || val === 'y') {
          self.setCoordinate(val, placementOptions[val]);
          self['original' + val] = placementOptions[val];
          return;
        }

        self[val] = placementOptions[val];
      });

      this.modified = false;

      return this.sanitize();
    }

    PlacementObject.prototype = {
      isReasonableDefault: function(setting, limits) {
        return $.inArray(setting, limits) > -1;
      },

      sanitize: function() {
        var self = this;

        this.bleedFromContainer = this.bleedFromContainer === true;
        this.callback = (typeof this.callback === 'function') ? this.callback : settings.callback;
        this.container = (this.container instanceof $ && this.container.length) ? this.container : settings.container;
        this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX)) ? this.containerOffsetX : 0;
        this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY)) ? this.containerOffsetY : 0;
        this.parent = (this.parent instanceof $ && this.parent.length) ? this.parent : settings.parent;
        this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, xAlignments) ? this.parentXAlignment : settings.parentXAlignment;
        this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, yAlignments) ? this.parentYAlignment : settings.parentYAlignment;
        this.placement = this.isReasonableDefault(this.placement, placements) ? this.placement : settings.placement;
        this.useParentHeight = this.useParentHeight === true;
        this.useParentWidth = this.useParentWidth === true;

        if (!$.isArray(this.strategies) || !this.strategies.length) {
          this.strategies = ['nudge'];
        }
        this.strategies.forEach(function(strat, i) {
          self.strategies[i] = self.isReasonableDefault(strat, strategies) ? strat : self.strategies[i];
        });

      },

      setCoordinate: function(coordinate, value) {
        var coordinates = ['x', 'y'];
        if (!this.isReasonableDefault(coordinate, coordinates)) {
          return;
        }

        if (isNaN(value)) {
          value = 0;
        }

        this[coordinate] = parseInt(value, 10);
      }
    };

    // Place Behavior Constructor
    // This is the actual "thing" that is tied to a Placeable Element.
    function Place(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.init();
    }

    Place.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        if (!this.element.hasClass('placeable')) {
          this.element.addClass('placeable');
        }

        // Setup a hash of original styles that will retain width/height whenever
        // the placement for this element is recalculated.
        this.originalStyles = {};
        var h = this.element[0].style.height,
          w = this.element[0].style.width;

        if (h) {
          this.originalStyles.height = h;
        }
        if (w) {
          this.originalStyles.width = w;
        }

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('place.' + pluginName, function placementEventHandler(e, x, y) {
          self.place(new PlacementObject({ x: x, y: y }));
        }).on('updated.' + pluginName, function updatedEventHandler() {
          self.updated();
        });

        return this;
      },

      // Actually renders an element with coordinates inside the DOM
      render: function(placementObj) {
        var unitRegex = /(px|%)/i;

        this.element.offset({
          'left': placementObj.x,
          'top': placementObj.y
        });

        if (placementObj.height) {
          this.element[0].style.height = placementObj.height + (unitRegex.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          this.element[0].style.width = placementObj.width + (unitRegex.test(placementObj.width + '') ? '' : 'px');
        }
      },

      // Main placement API Method (external)
      // Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
      // will use the pre-defined settings.
      place: function(placementObj) {
        var curr = [
          this.element[0].style.left,
          this.element[0].style.top,
        ];

        // Cancel placement with return:false; from a "beforeplace" event
        var canBePlaced = this.element.trigger('beforeplace', [curr]);
        if (!canBePlaced) {
          return curr;
        }

        if (!(placementObj instanceof PlacementObject)) {
          placementObj = new PlacementObject(placementObj);
        }

        // If no values are defined, simply return the current coordinates with a warning.
        if (placementObj.x == null && placementObj.y == null) {
          // TODO: Log a warning about not positioning stuff?
          return curr;
        }

        // Remove any previous placement styles
        this.clearOldStyles();

        // Use different methods if placement against a parent, versus straight-up coordinate placement
        if (placementObj.parent) {
          return this._placeWithParent(placementObj);
        }

        return this._placeWithCoords(placementObj);
      },

      // Placement Routine that expects a parent to be used as a base placement marking.
      // In this case, "x" and "y" integers are "relative" adjustments to the original numbers generated by the parent.
      // Can be modified by using a callback in the settings.
      _placeWithParent: function(placementObj) {
        if (!placementObj.parent || !placementObj.parent.length) {
          return [undefined, undefined]; // can't simply return x and y here because they are not coordinates, they are offsets
        }

        var self = this,
          parentRect = Soho.DOM.getDimensions(placementObj.parent[0]),
          elRect = Soho.DOM.getDimensions(this.element[0]),
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

        if (placementObj.useParentWidth) {
          placementObj.width = parentRect.width;
        }
        if (placementObj.useParentHeight) {
          placementObj.height = parentRect.height;
        }

        function getCoordsFromPlacement(placementObj) {
          var cX, cY,
            p = placementObj.placement,
            aX = placementObj.parentXAlignment,
            aY = placementObj.parentYAlignment;

          // Set initial placements
          switch(p) {
            case 'top':
              cY = parentRect.top - elRect.height - placementObj.y + (containerIsBody ? scrollY : 0);
              break;
            case 'left':
              cX = parentRect.left - elRect.width - placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            case 'right':
              cX = parentRect.right + placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            default: // Bottom
              cY = parentRect.bottom + placementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }

          // Set X alignments on bottom/top placements
          if (p === 'top' || p === 'bottom') {
            switch(aX) {
              case 'left':
                cX = parentRect.left - placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              case 'right':
                cX = (parentRect.right - elRect.width) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              default: // center
                cX = (parentRect.left + ((parentRect.width - elRect.width) / 2)) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
            }
          }

          // Set Y alignments on left/right placements
          if (p === 'right' || p === 'left') {
            switch(aY) {
              case 'top':
                cY = parentRect.top - placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              case 'bottom':
                cY = (parentRect.bottom - elRect.height) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              default: // center
                cY = (parentRect.top + ((parentRect.height - elRect.height) / 2)) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
            }
          }

          return [cX, cY];
        }

        function doPlacementAgainstParent(placementObj) {
          var coords = getCoordsFromPlacement(placementObj);
          placementObj.setCoordinate('x', coords[0]);
          placementObj.setCoordinate('y', coords[1]);
          self.render(placementObj);
          placementObj = self._handlePlacementCallback(placementObj);
          return placementObj;
        }

        // Simple placement logic
        placementObj = doPlacementAgainstParent(placementObj);

        // Adjusts the placement coordinates based on a defined strategy
        // Will only adjust the current strategy if bleeding outside the viewport/container are detected.
        placementObj.strategies.forEach(function(strat) {
          placementObj = self.checkBleeds(placementObj);

          if (placementObj.bleeds) {
            placementObj = (function(self) {
              switch(strat) {
                case 'nudge':
                  return self.nudge(placementObj);
                case 'clockwise':
                  return self.clockwise(placementObj);
                case 'flip':
                  placementObj = self.flip(placementObj);
                  placementObj.setCoordinate('x', placementObj.originalx);
                  placementObj.setCoordinate('y', placementObj.originaly);
                  placementObj = doPlacementAgainstParent(placementObj);
                  return placementObj;
                case 'shrink':
                  return self.shrink(placementObj);
                case 'shrink-x':
                  return self.shrink(placementObj, 'x');
                case 'shrink-y':
                  return self.shrink(placementObj, 'y');
                default:
                  return placementObj;
              }
            })(self);

            self.render(placementObj);
          }
        });

        // Trigger an event to notify placement has ended
        this.element.trigger('afterplace', [placementObj]);

        return placementObj;
      },

      // Basic Placement Routine that simply accepts X and Y coordinates.
      // In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
      // Can be modified by using a callback in the settings.
      _placeWithCoords: function(placementObj) {
        this.render(placementObj);

        placementObj = this._handlePlacementCallback(placementObj);

        this.render(placementObj);

        // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).
        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.nudge(placementObj);
        }

        // Place again
        this.render(placementObj);

        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.shrink(placementObj);
        }

        this.render(placementObj);

        this.element.trigger('afterplace', [
          placementObj
        ]);

        return placementObj;
      },

      // Perform callback, if it exists
      // Callback should return an array containing the modified coordinate values: [x, y];
      // NOTE: These are actual coordinates in all cases.  They are not relative values - they are absolute
      _handlePlacementCallback: function(placementObj) {
        var cb = placementObj.callback || this.settings.callback;

        if (cb && typeof cb === 'function') {
          placementObj = cb(placementObj);
        }

        this.render(placementObj);
        return placementObj;
      },

      /**
       * Detects for elements with fixed positioning, or an absolutely-positioned containment.
       * If either condition is true, this placement should not account for container scrolling.
       * @private
       */
      _accountForScrolling: function(placementObj) {
        var container = placementObj.container,
          containerStyle,
          pos = window.getComputedStyle(this.element[0]).position;

        // fixed-positoned, placed elements don't account for scrolling
        if (pos === 'fixed') {
          return false;
        }

        // Check the container element. If we can't find a valid container element, do account for scrolling.
        if (!container || !container.length) {
          container = this.element.parents().filter(function() {
            var pos = window.getComputedStyle(this).position;
            return pos === 'absolute' || pos === 'fixed';
          });
        }
        if (!container || !container.length) {
          return true;
        }

        if (container[0] === document.body) {
          return false;
        }

        containerStyle = window.getComputedStyle(container[0]);
        pos = containerStyle.position;
        if (pos === 'fixed') {
          return false;
        }
        if (pos === 'absolute' && containerStyle.overflow === 'hidden') {
          return false;
        }
        return true;
      },

      // Gets a parent container element.
      getContainer: function(placementObj) {
        if (placementObj.container instanceof $ && placementObj.container.length) {
          return placementObj.container;
        }

        var modalParent = this.element.parents('.modal');
        if (modalParent.length) {
          return modalParent;
        }

        return $(document.body);
      },

      // Re-adjust a previously-placed element to account for bleeding off the edges.
      // Element must fit within the boundaries of the page or it's current scrollable pane.
      checkBleeds: function(placementObj) {
        var containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          BoundingRect = this.element[0].getBoundingClientRect(),
          rect = {},
          containerRect = container ? container[0].getBoundingClientRect() : {},
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          d;

          rect.width = BoundingRect.width;
          rect.height = BoundingRect.height;
          rect.top = BoundingRect.top;
          rect.right = BoundingRect.right;
          rect.bottom = BoundingRect.bottom;
          rect.left = BoundingRect.left;

        function getBoundary(edge) {
          switch(edge) {
            case 'top':
              return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1); // 0 === top edge of viewport
            case 'left':
              return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1); // 0 === left edge of viewport
            case 'right':
              return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);
            default: // bottom
              return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
          }
        }

        // If element width is greater than window width, shrink to fit
        var rightViewportEdge = getBoundary('right');
        if (rect.width >= rightViewportEdge) {
          d = rect.width - rightViewportEdge;
          var newWidth = rect.width - d;
          placementObj.width = newWidth;

          this.element[0].style.width = newWidth + 'px';
          rect.width = newWidth; // reset the rect because the size changed
        }

        // If element height is greater than window height, shrink to fit
        var bottomViewportEdge = getBoundary('bottom');
        if (rect.height >= bottomViewportEdge) {
          d = rect.height - bottomViewportEdge;
          var newHeight = rect.height - d;
          placementObj.height = newHeight;

          this.element[0].style.height = newHeight + 'px';
          rect.height = newHeight; // reset the rect because the size changed
        }

        // build conditions
        var offRightEdge = rect.right > getBoundary('right'),
            offLeftEdge = rect.left < getBoundary('left'),
            offTopEdge = rect.top < getBoundary('top'),
            offBottomEdge = rect.bottom > getBoundary('bottom');

        // Return if no bleeding is detected (no need to fix anything!)
        if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
          placementObj.bleeds = undefined;
          return placementObj;
        }

        // Keep a record of bleeds that need to be adjusted, and by what values
        placementObj.bleeds = {};
        placementObj.bleeds.right = offRightEdge ? (rect.right - getBoundary('right')) : null;
        placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
        placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
        placementObj.bleeds.bottom = offBottomEdge ? (rect.bottom - getBoundary('bottom')) : null;

        return placementObj;
      },

      // Bumps the element around in each direction
      nudge: function(placementObj) {
        if (!placementObj.nudges) {
          placementObj.nudges = {x: 0, y: 0};
        }

        var d = 0;
        if (placementObj.bleeds.right) {
          d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x - d);
          placementObj.nudges.x = placementObj.nudges.x - d;
        }
        if (placementObj.bleeds.left) {
          d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x + d);
          placementObj.nudges.x = placementObj.nudges.x + d;
        }
        if (placementObj.bleeds.top) {
          d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y + d);
          placementObj.nudges.y = placementObj.nudges.y + d;
        }
        if (placementObj.bleeds.bottom) {
          d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y - d);
          placementObj.nudges.y = placementObj.nudges.y - d;
        }

        placementObj.wasNudged = true;
        placementObj.bleeds = undefined;

        return placementObj;
      },

      flip: function(placementObj) {
        // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
        if (!placementObj.bleeds[placementObj.placement]) {
          return placementObj;
        }

        if (!placementObj.attemptedFlips) {
          placementObj.attemptedFlips = [];
        }
        placementObj.attemptedFlips.push(placementObj.placement);

        // If we've tried flipping in all directions, give up and use the default placement.
        if (placementObj.attemptedFlips.length > 3) {
          placementObj = this.giveup(placementObj);
          return placementObj;
        }

        var accountForScrolling = this._accountForScrolling(placementObj),
          isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1,
          containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          containerRect = container ? container[0].getBoundingClientRect() : {},
          parentRect = placementObj.parent[0].getBoundingClientRect(),
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

        function getOppositeDir(dir) {
          switch(dir) {
            case 'left':
              return 'right';
            case 'right':
              return 'left';
            case 'top':
              return 'bottom';
            default: // bottom
              return 'top';
          }
        }

        // Gets the distance between an edge on the target element, and its opposing viewport border
        function getDistance(dir) {
          var d = 0;

          switch (dir) {
            case 'left':
              d = (containerBleed ? 0 : containerRect.left) - (accountForScrolling ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
              break;
            case 'right':
              d = ((containerBleed ? windowW : containerRect.right) - (accountForScrolling ? scrollX : 0)) - parentRect.right - placementObj.containerOffsetX;
              break;
            case 'top':
              d = (containerBleed ? 0 : containerRect.top) - (accountForScrolling ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
              break;
            default: // bottom
              d = ((containerBleed ? windowH : containerRect.bottom) - (accountForScrolling ? scrollY : 0)) - parentRect.bottom - placementObj.containerOffsetY;
              break;
          }

          return Math.abs(d);
        }

        function tried(placement) {
          return $.inArray(placement, placementObj.attemptedFlips) > -1;
        }

        function performFlip(originalDir) {
          var newDir = getOppositeDir(originalDir),
            perpendicularDir = isXCoord ? 'top' : 'left',
            oppPerpendicularDir = getOppositeDir(perpendicularDir),
            originalDistance = getDistance(originalDir),
            targetDistance = getDistance(newDir);

          if (!tried(newDir)) {
            if (originalDistance >= targetDistance) {
              return originalDir;
            }

            placementObj.wasFlipped = true;
            return newDir;
          }

          // switch the coordinate definitions
          // since the axis for placement is flipped, our coordinate offsets should also flip
          var tmp = placementObj.originalx;
          placementObj.originalx = placementObj.originaly;
          placementObj.originaly = tmp;

          var perpendicularDistance = getDistance(perpendicularDir),
            oppPerpendicularDistance = getDistance(oppPerpendicularDir);

          if (!tried(perpendicularDir)) {
            if (perpendicularDistance >= oppPerpendicularDistance) {
              return perpendicularDir;
            }

            if (!tried(oppPerpendicularDir)) {
              return oppPerpendicularDir;
            }
          }

          return originalDir;
        }

        placementObj.placement = performFlip(placementObj.placement);

        return placementObj;
      },

      // TODO: Move Clockwise
      clockwise: function(placementObj) {
        return placementObj;
      },

      // If element height/width is greater than window height/width, shrink to fit
      shrink: function(placementObj, dimension) {
        var accountForScrolling = this._accountForScrolling(placementObj),
          containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerRect = container ? container[0].getBoundingClientRect() : {},
          containerIsBody = container.length && container[0] === document.body,
          rect = this.element[0].getBoundingClientRect(),
          useX = dimension === undefined || dimension === null || dimension === 'x',
          useY = dimension === undefined || dimension === null || dimension === 'y',
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          leftViewportEdge = (accountForScrolling ? scrollX: 0) + (containerBleed ? 0 : containerRect.left) + placementObj.containerOffsetX,
          topViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? 0 : containerRect.top) + placementObj.containerOffsetY,
          rightViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? windowW : containerRect.right) - placementObj.containerOffsetX,
          bottomViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? windowH : containerRect.bottom) - placementObj.containerOffsetY,
          d;

        // Shrink in each direction.
        // The value of the "containerOffsets" is "factored out" of each calculation, if for some reason the
        // element is larger than the viewport/container space allowed.
        placementObj.nudges = placementObj.nudges || {};

        if (useX) {
          // Left
          if (rect.left < leftViewportEdge) {
            d = Math.abs(leftViewportEdge - rect.left);
            if (rect.right >= rightViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
            placementObj.setCoordinate('x', placementObj.x + d);
            placementObj.nudges.x = placementObj.nudges.x + d;
          }

          // Right
          if (rect.right > rightViewportEdge) {
            d = Math.abs(rect.right - rightViewportEdge);
            if (rect.left <= leftViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
          }
        }

        if (useY) {
          // Top
          if (rect.top < topViewportEdge) {
            d = Math.abs(topViewportEdge - rect.top);
            if (rect.bottom >= bottomViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
            placementObj.setCoordinate('y', placementObj.y + d);
            placementObj.nudges.y = placementObj.nudges.y + d;
          }

          // Bottom
          if (rect.bottom > bottomViewportEdge) {
            d = Math.abs(rect.bottom - bottomViewportEdge);
            if (rect.top <= topViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
          }
        }

        return placementObj;
      },

      // Giving up causes all the placementObj settings to revert
      giveup: function(placementObj) {
        placementObj.giveup = true;
        placementObj.strategy = this.settings.strategy;
        placementObj.placement = this.settings.placement;
        return placementObj;
      },

      // Clears the old styles that may be present
      clearOldStyles: function() {
        this.element[0].style.left = '';
        this.element[0].style.top = '';
        this.element[0].style.width = '';
        this.element[0].style.height = '';

        var os = this.originalStyles;
        if (os) {
          if (os.width) {
            this.element[0].style.width = os.width;
          }

          if (os.height) {
            this.element[0].style.height = os.height;
          }
        }

        return this;
      },

      // Built-in method for handling positon of optional arrow elements.
      // Used for tooltip/popovers/popupmenus
      setArrowPosition: function(e, placementObj, element) {
        var target = placementObj.parent,
          arrow = element.find('div.arrow'),
          dir = placementObj.placement,
          isXCoord = ['left', 'right'].indexOf(dir) > -1,
          targetRect = {},
          elementRect = element[0].getBoundingClientRect(),
          arrowRect = {},
          newArrowRect = {},
          hideArrow = false;

        if (!target || !target.length || !arrow.length) {
          return;
        }

        arrow[0].removeAttribute('style');

        //if (placementObj.attemptedFlips) { TJM Removed for pager bug. Seems to work.
          element.removeClass('top right bottom left').addClass(dir);
        //}

        // Flip the arrow if we're in RTL mode
        if (this.isRTL && isXCoord) {
          var opposite = dir === 'right' ? 'left' : 'right';
          element.removeClass('right left').addClass(opposite);
        }

        // Custom target for some scenarios
        if (target.is('.colorpicker')) {
          target = target.next('.trigger');
        }
        if (target.is('.datepicker, .timepicker')) {
          target = target.next('.icon');
        }
        if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
          target = target.find('.icon').last();
        }
        if (target.is('.searchfield-category-button')) {
          target = target.find('.icon.icon-dropdown');
        }
        if (target.is('.colorpicker-editor-button')) {
          target = target.find('.trigger .icon');
        }

        // reset if we borked the target
        if (!target.length) {
          target = placementObj.parent;
        }

        targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
        arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
        newArrowRect = {};

        function getMargin(placement) {
          return (placement === 'right' || placement === 'left') ? 'margin-top' : 'margin-left';
        }

        function getDistance() {
          var targetCenter = 0,
            currentArrowCenter = 0,
            d = 0;

          if (dir === 'left' || dir === 'right') {
            targetCenter = targetRect.top + (targetRect.height/2);
            currentArrowCenter = arrowRect.top + (arrowRect.height/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.top = arrowRect.top + d;
            newArrowRect.bottom = arrowRect.bottom + d;

            if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
              hideArrow = true;
            }
          }
          if (dir === 'top' || dir === 'bottom') {
            targetCenter = targetRect.left + (targetRect.width/2);
            currentArrowCenter = arrowRect.left + (arrowRect.width/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.left = arrowRect.left + d;
            newArrowRect.right = arrowRect.right + d;

            if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
              hideArrow = true;
            }
          }

          return d;
        }

        // line the arrow up with the target element's "dropdown icon", if applicable
        var positionOpts = {};
        positionOpts[getMargin(dir)] = getDistance();
        if (hideArrow) {
          positionOpts.display = 'none';
        }
        arrow.css(positionOpts);
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.clearOldStyles();
        this.element.removeClass('placeable');

        this.element.off('updated.' + pluginName + ' place.' + pluginName);

        this.element.trigger('afterteardown');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Place(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.popdown = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'popdown',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Popdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Popdown.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var self = this;
        this.popdown = $();

        // Setup the proper trigger element to use
        this.trigger = this.element;
        if (this.trigger.is('.dropdown, .multiselect')) {
          this.trigger = $('#' + this.element.attr('id') + '-shdo');
        }

        // Find the correct element to use as the popdown's view.
        function tryPopdownElement(elem) {
          if (!elem) { return false; }

          if (typeof elem === 'string') {
            if (!elem.match('#') || elem.indexOf('#') !== 0) {
              elem = '#' + elem;
            }
            elem = $(elem);
          }

          if (elem.length) {
            self.popdown = elem;
            return true;
          }

          return false;
        }

        var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));
        if (!popdownElem) {
          tryPopdownElement(this.trigger.next('.popdown'));
        }

        // Setup an ID for this popdown if it doesn't already have one
        this.id = this.popdown.attr('id');
        if (!this.id) {
          this.id = 'popdown-' + $('body').find('.popdown').index(this.popdown);
          this.popdown.attr('id', this.id);
        }

        return this;
      },

      build: function() {
        // Ensure the popdown window is a popdown, and remove any hidden classes from it.
        this.popdown.addClass('popdown').removeClass('hidden');

        // Wrap the contents inside for spacing purposes
        var contents = this.popdown.children('.popdown-contents');
        if (!contents.length) {
          this.popdown.children().wrap('<div class="popdown-contents"></div>');
        }

        // Add the arrow markup if it doesn't already exist
        this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);

        this.place();

        // Expand if necessary
        var ariaExpanded = this.trigger.attr('aria-expanded');
        if (!ariaExpanded || ariaExpanded === undefined) {
          this.trigger.attr('aria-expanded', '');
        }
        if (ariaExpanded === 'true') {
          this.open();
        }

        // aria-controls for the trigger element
        this.trigger.attr('aria-controls', this.id);

        return this;
      },

      handleEvents: function() {
        var self = this;

        this.trigger
          .onTouchClick('popdown')
          .on('click.popdown', function() {
            self.toggle();
          })
          .on('updated.popdown', function() {
            self.updated();
          });

        return this;
      },

      isOpen: function() {
        return this.trigger.attr('aria-expanded') === 'true';
      },

      open: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this,
          setFocusinEvent = false;

        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'true');
        this.position();
        this.popdown.addClass('visible');

        // Setup events that happen on open
        // Needs to be on a timer to prevent automatic closing of popdown.
        setTimeout(function() {
          self.popdown.one('focusin.popdown', function() {
            if (!setFocusinEvent) {
              setFocusinEvent = true;
              $(document).on('focusin.popdown', function(e) {
                var target = e.target;
                if (!$.contains(self.popdown[0], target)) {
                  self.close();
                }
              });
            }
          });

          $('body').on('resize.popdown', function() {
            if (!$(document.activeElement).closest('.popdown').length) {
              self.close();
            }
          });

          $(document).on('click.popdown', function(e) {
            var target = $(e.target);

            if (!target.is('.popdown') && !target.closest('.popdown').length) {
              self.close();
            }
          });

          self.isAnimating = false;
        }, 400);
      },

      close: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this;
        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'false');
        this.popdown.removeClass('visible');

        // Turn off events
        this.popdown.off('focusin.popdown');
        $('body').off('resize.popdown');
        $(document).off('click.popdown focusin.popdown');

        // Sets the element to "display: none" to prevent interactions while hidden.
        setTimeout(function() {
          self.popdown[0].style.display = 'none';
          self.isAnimating = false;
        }, 400);
      },

      toggle: function() {
        if (this.isOpen()) {
          this.close();
          return;
        }
        this.open();
      },

      // Detaches Popdown Element and places at the body tag root, or at the root of the nearest
      // scrollable parent.
      place: function() {
        this.scrollparent = $('body');
        this.popdown.detach().appendTo(this.scrollparent);
      },

      position: function() {
        var parent = {
          offset: {
            left: 0,
            top: 0
          },
          scrollDistance: {
            left: 0,
            top: 0
          }
        },
        winH = window.innerHeight + $(document).scrollTop(),
        // subtract 2 from the window width to account for the tooltips
        // resizing themselves to fit within the CSS overflow boundary.
        winW = (window.innerWidth - 2) + $(document).scrollLeft();

        // Reset adjustments to panel and arrow
        this.popdown.removeAttr('style');
        this.arrow.removeAttr('style');

        // Add/subtract offsets if a scrollable parent element is involved
        if (this.scrollparent.length) {
          parent.offset = this.scrollparent.offset();
          parent.scrollDistance.top = this.scrollparent.scrollTop();
          parent.scrollDistance.left = this.scrollparent.scrollLeft();
          winH = winH - (parent.offset.top + parent.scrollDistance.top);
          winW = winW - (parent.offset.left + parent.scrollDistance.left);
        }

        var adjustX = false,
          adjustY = false,
          t = this.trigger,
          to = t.offset(), // Trigger offset
          arrowHeight = 11,
          XoffsetFromTrigger = 0,
          YoffsetFromTrigger = 0,
          po; // Popover offset

        // Place the popdown below to start
        this.popdown.addClass('bottom');

        this.popdown[0].style.left = to.left + 'px';
        this.popdown[0].style.top = (to.top + t.outerHeight(true) + arrowHeight) + 'px';

        this.arrow[0].style.left = (t.outerWidth(true)/2) + 'px';
        this.arrow[0].style.top = (0 - arrowHeight) + 'px';

        // Get the newly-set values for the popdown's offset
        po = this.popdown.offset();

        // Get deltas for popdown position if the button is off either X edge
        if (po.left < 0) { // Checking the left edge
          adjustX = true;
          XoffsetFromTrigger = 0 - po.left;
        }
        var rightEdgePos = po.left + this.popdown.outerWidth(true);
        if (rightEdgePos > winW) { // Checking the right edge
          adjustX = true;
          XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
        }

        if (adjustX) {
          // Adjust the X position based on the deltas
          this.popdown[0].style.left = (po.left + (XoffsetFromTrigger * -1)) + 'px';

          var popdownRect = this.popdown[0].getBoundingClientRect(),
            triggerRect = t[0].getBoundingClientRect(),
            deltaRightEdge = popdownRect.right - triggerRect.right + 10;

          this.arrow[0].style.left = 'auto';
          this.arrow[0].style.right = deltaRightEdge+ 'px';


          // Get the newly set values
          po = this.popdown.offset();
        }

        // Get the deltas for popdown position if the button is off either Y edge
        if (po.top < 0) { // Checking top edge
          adjustY = true;
          YoffsetFromTrigger = 0 - po.top;
        }
        var bottomEdgePos = po.top + this.popdown.outerHeight(true);
        if (bottomEdgePos > winH) { // Checking the bottom edge
          adjustY = true;
          YoffsetFromTrigger = bottomEdgePos - winH;
        }

        // Remove the arrow if we need to adjust this, since it won't line up anymore
        if (adjustY) {
          this.arrow[0].style.display = 'none';

          // Adjust the Y position based on the deltas
          this.popdown[0].style.top = (po.top + (YoffsetFromTrigger * -1)) + 'px';
          this.arrow[0].style.top = (parseInt(this.arrow[0].style.top) - (YoffsetFromTrigger * -1)) + 'px';

          // Get the values again
          po = this.popdown.offset();
        }

        // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
        // shrink the height of the popdown, as it's too tall for the viewport.
        if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
          this.popdown[0].style.top = 0;
          po = this.popdown.offset();

          bottomEdgePos = po.top + this.popdown.outerHeight(true);
          this.popdown[0].style.height = (parseInt(this.popdown[0].style.height) - (bottomEdgePos - winH)) + 'px';
        }
      },

      updated: function() {
        return this;
      },

      teardown: function() {
        if (this.isOpen()) {
          this.close();
        }

        this.trigger
          .offTouchClick('popdown')
          .off('updated.popdown click.popdown')
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded');

        if (this.originalParent && this.originalParent.length) {
          this.popdown.detach().appendTo(this.originalParent);
        }

        this.arrow.remove();

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Popdown(this, settings));
      }
    });
  };


  $.fn.popupmenu = function(options) {

    // Settings and Options
    var pluginName = 'popupmenu',
      defaults = {
        menu: null,
        trigger: 'click',
        autoFocus: true,
        mouseFocus: true,
        attachToBody: false,
        beforeOpen: null,
        ariaListbox: false,
        eventObj: undefined,
        placementOpts: {
          containerOffsetX: 10,
          containerOffsetY: 10,
          strategies: ['flip', 'shrink']
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      settings = $.extend({}, defaults, options);


    /**
    * Responsive Popup Menu Control aka Context Menu when doing a right click action.
    *
    * @class PopupMenu
    * @param {String} menu  &nbsp;-&nbsp; Menu's ID Selector, or a jQuery object representing a menu
    * @param {String} trigger  &nbsp;-&nbsp; Action on which to trigger a menu can be: click, rightClick, immediate ect
    * @param {Boolean} autoFocus  &nbsp;-&nbsp; If false the focus will not focus the first list element. (At the cost of accessibility)
    * @param {Boolean} attachToBody  &nbsp;-&nbsp; If true the menu will be moved out to the body. To be used in certin overflow situations.
    * @param {String} ariaListbox  &nbsp;-&nbsp;  Switches aria to use listbox construct instead of menu construct (internal)
    * @param {String} eventObj  &nbsp;-&nbsp; Can pass in the event object so you can do a right click with immediate
    * @param {Object} placementOpts  &nbsp;-&nbsp; Gets passed to this control's Place behavior
    * @param {Object} offset  &nbsp;-&nbsp; Can tweak the menu position in the x and y direction. Takes an object of form: `{x: 0, y: 0}`
    *
    */
    function PopupMenu(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.isOldIe  = $('html').is('.ie11, .ie10, .ie9');
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    PopupMenu.prototype = {
      init: function() {
        this.setup();
        this.addMarkup();
        this.handleEvents();
        this.iconFilteringSetup();

        // Allow for an external click event to be passed in from outside this code.
        // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.
        if (this.settings.trigger === 'immediate') {
          this.open(this.settings.eventObj);
        }

        // Use some css rules on submenu parents
        if (this.menu.find('.submenu').length) {
          this.menu.addClass('has-submenu');
        }
      },

      isRTL: function() {
        return $('html').attr('dir') === 'rtl';
      },

      setup: function() {
        if (this.element.attr('data-popupmenu') && !this.settings.menu) {
          this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
        }
        // Backwards compatibility for "menuId" menu options coming from other controls
        // that utilize the Popupmenu.
        if (this.settings.menuId) {
          this.settings.menu = this.settings.menuId;
          this.settings.menuId = undefined;
        }

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.popupmenu-wrapper').length, 10)+1).toString();
        }
      },

      //Add markip including Aria
      addMarkup: function () {
        var id,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        switch(typeof this.settings.menu) {
          case 'string': // ID Selector
            id = this.settings.menu;
            this.menu = $('#' + this.settings.menu);
            break;
          case 'object': // jQuery Object
            if (this.settings.menu === null) {
              this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
            } else {
              this.menu = $(this.settings.menu);
            }

            id = this.menu.attr('id');
            if (!id || id === '') {
              this.menu.attr('id', 'popupmenu-' + this.id);
              id = this.menu.attr('id');
            }
            break;
        }

        // If markup already exists for the wrapper, use that instead of rebuilding.
        if (this.menu.is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu;
          this.menu = this.wrapper.children('.popupmenu').first();
        }

        // Similar check as above, assuming the menu wasn't a popupmenu wrapper.
        if (this.menu.parent().is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu.parent();
        }

        // If we still don't have a menu reference at this point, fail gracefully by returning out
        // and simply acting like a button.
        if (this.menu.length === 0) {
          return false;
        }

        // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
        // to prevent containment issues. (Now a Preference)
        if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
          this.originalParent = this.menu.parent();
          this.menu.detach().appendTo('body');
        }

        if (!this.menu.is('.popupmenu')) {
          this.menu.addClass('popupmenu')
            .attr('role', (this.settings.ariaListbox ? 'listbox' : 'menu'));
        }

        // Always store a reference to the trigger element under jQuery data.
        this.menu.data('trigger', this.element);

        this.wrapper = this.menu.parent('.popupmenu-wrapper');
        if (!this.wrapper.length) {
          this.wrapper = this.menu.wrap('<div class="popupmenu-wrapper"></div>');
        }

        // Invoke all icons as icons
        this.wrapper.find('svg').each(function() {
          if (!$(this).data('icon')) {
            $(this).icon();
          }
        });

        //Enforce Correct Modality
        this.menu.parent('.popupmenu-wrapper').attr('role', 'application').attr('aria-hidden', 'true');

        // Use "absolute" positioning on the menu insead of "fixed", only when the
        // menu lives <body> tag and we have a <body> element that is tall enough to
        // scroll and is allowed to scroll.
        function scrollableFilter() {
          var c = this ? this.style.overflow : null;
          return c !== 'auto' && c !== 'visible' && c !== 'scroll';
        }
        if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
          this.wrapper[0].style.position = 'absolute';
        }

        // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.
        this.menu.find('.popupmenu').each(function(i, elem) {
          var popup = $(elem);

          if (!(popup.parent().hasClass('wrapper'))) {
            popup.wrap('<div class="wrapper"></div>');
          }
        });

        // If the trigger element is a button with no border append arrow markup
        var containerClass = this.element.parent().attr('class');
        if ((this.element.hasClass('btn-menu') ||
            this.element.hasClass('btn-actions') ||
            this.settings.menu === 'colorpicker-menu' ||
            this.element.closest('.toolbar').length > 0 ||
            this.element.closest('.masthead').length > 0 ||
            this.element.is('.searchfield-category-button') ||
            (containerClass && containerClass.indexOf('more') >= 0) ||
            containerClass && containerClass.indexOf('btn-group') >= 0)) {

          var arrow = $('<div class="arrow"></div>'),
            wrapper = this.menu.parent('.popupmenu-wrapper');

          wrapper.addClass('bottom').append(arrow);
        }

        // If inside of a ".field-short" container, make smaller
        var addFieldShort = this.element.closest('.field-short').length;
        this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short');

        // If button is part of a header/masthead or a container using the "alternate" UI color, add the "alternate" class.
        if (containerClass !== undefined &&
          (this.element.closest('.masthead').not('.search-results .masthead').length > 0)) {
          this.menu.parent('.popupmenu-wrapper').addClass('alternate');
        }

        this.element.attr('aria-haspopup', true);
        this.element.attr('aria-controls', id);

        this.markupItems();

        //Add an Audible Label
        if (!leftClick && !immediate) {
          var audibleSpanId = 'popupmenu-f10-label';
          if ($('#'+audibleSpanId).length === 0) {
            this.element.after('<span style="display:none;" id="' + audibleSpanId + '">' + Locale.translate('PressShiftF10') + '</span>');
          }
          //PressShiftF10
          this.element.attr('aria-describedby', audibleSpanId);
        }

        // Unhide the menu markup, if hidden
        if (this.menu.is('.hidden')) {
          this.menu.removeClass('hidden');
        }
      },

      markupItems: function () {
        var self = this,
          lis = this.menu.find('li:not(.heading):not(.separator)'),
          menuClassName = this.menu[0].className,
          isTranslatable = Soho.DOM.classNameHas(menuClassName, 'isTranslatable');

        lis.each(function(i, li) {
          var a = $(li).children('a')[0], // TODO: do this better when we have the infrastructure
            span = $(a).children('span')[0],
            submenuWrapper = $(li).children('.wrapper')[0];
          li.setAttribute('role', 'presentation');

          if (a) {
            a.setAttribute('tabindex', '-1');
            a.setAttribute('role', (self.settings.ariaListbox ? 'option' : 'menuitem'));

            // Should be translated
            if (isTranslatable) {
              span.innerText = Locale.translate(span.innerText) || span.innerText;
            }

            // disabled menu items, by prop and by className
            var $a = $(a),
              $li = $(li);

            if (a.hasAttribute('disabled') || $li.hasClass('is-disabled')) {
              Soho.DOM.addClass(li, 'is-disabled');
              a.setAttribute('aria-disabled', 'true');
              a.disabled = true;
            } else {
              $li.removeClass('is-disabled');
              $a.prop('disabled', false).removeAttr('aria-disabled');
            }

            // menu items that contain submenus
            if (submenuWrapper instanceof HTMLElement) {
              li.className += (Soho.DOM.classNameExists(li) ? ' ' : '') + 'submenu';
            }
            if (Soho.DOM.classNameHas(li.className, 'submenu')) {

              // Add a span
              if (!span) {
                a.innerHTML = '<span>' + a.innerHTML + '</span>';
                span = $a.children('span')[0];
              }

              if ($a.find('svg.arrow').length === 0) {
                $a.append($.createIconElement({ classes: ['arrow', 'icon-dropdown'], icon: 'dropdown' }));
              }
              a.setAttribute('aria-haspopup', 'true');
            }

            // is-checked
            if (Soho.DOM.classNameHas(li.className, 'is-checked')) {
              a.setAttribute('role', 'menuitemcheckbox');
              a.setAttribute('aria-checked', true);
            }

            // is-not-checked
            if (Soho.DOM.classNameHas(li.className, 'is-not-checked')) {
              li.className = li.className.replace('is-not-checked', '');
              a.setAttribute('role', 'menuitemcheckbox');
              a.removeAttribute('aria-checked');
            }
          }
        });
      },

      handleEvents: function() {
        var self = this,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        function disableBrowserContextMenu(e) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        function doOpen(e) {
          var rightClick = self.settings.trigger === 'rightClick';

          e.stopPropagation();
          e.preventDefault();

          if (rightClick && self.menu.hasClass('is-open')) {
            self.close();
            self.open(e);
            return;
          }

          if (self.menu.hasClass('is-open')){
            self.close();
          } else {
            self.open(e);
          }
        }

        function contextMenuHandler(e, isLeftClick) {
          e.preventDefault();

          if (self.keydownThenClick) {
            self.keydownThenClick = undefined;
            return;
          }

          var btn = isLeftClick === true ? 0 : 2;
          if (e.button > btn || self.element.is(':disabled')) {
            return;
          }

          doOpen(e);
        }

        if (!immediate) {
          // Left-Click activation
          if (leftClick) {
            this.element
              .on('click.popupmenu', function (e) {
                contextMenuHandler(e, true);
              });
          }

          // Right-Click activation
          if (!leftClick) {
            this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);
            this.element
              .on('contextmenu.popupmenu', function(e) {
                disableBrowserContextMenu(e);
                contextMenuHandler(e);
              });
          }
        }

        // Setup these next events no matter what trigger type is
        this.element.not('.autocomplete')
          .on('keydown.popupmenu', function (e) {
            switch(e.which) {
              case 13:
              case 32:
                if (self.settings.trigger === 'click') {
                  self.keydownThenClick = true;
                  self.open(e);
                }
                break;
              case 121:
                if (e.shiftKey) { //Shift F10
                  self.open(e);
                }
                break;
            }
          })
          .off('updated.popupmenu')
          .on('updated.popupmenu', function(e) {
            e.stopPropagation();
            self.updated();
          });

          // Media Query Listener to detect a menu closing on mobile devices that change orientation.
          if (window.matchMedia) {
            this.matchMedia = window.matchMedia('(orientation: landscape)');
            this.mediaQueryListener = function() {
              // Match every time.
              if (!self.menu.hasClass('is-open')) {
                return;
              }
              self.close();
            };
            this.matchMedia.addListener(this.mediaQueryListener);
          }
      },

      handleKeys: function () {
        var self = this;
        //http://access.aol.com/dhtml-style-guide-working-group/#popupmenu

        //Handle Events in Anchors
        this.menu.onTouchClick('popupmenu', 'a')
          .on('click.popupmenu', 'a', function(e) {
            self.handleItemClick(e, $(this));
          });

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';

        //Select on Focus
        if (this.settings.mouseFocus) {
          this.menu.on('mouseenter.popupmenu', 'li', function () {
            self.highlight($(this).children('a'));
          });
        }

        setTimeout(function() {
          $(document).off('keydown.popupmenu.' + this.id).on('keydown.popupmenu.' + this.id, function (e) {
            var key = e.which,
              focus;

            //Close on escape
            if (key === 27) {
              e.stopPropagation();
              e.stopImmediatePropagation();
              self.close(true);
              return false;
            }

            //Close on tab
            if (key === 9) {
              e.stopPropagation();
              self.close(true);
            }

            //Select Checkboxes
            if (key === 32) {
              e.stopPropagation();

              var target = $(e.target),
                checkbox = target.find('input:checkbox');
              if (checkbox.length) {
                checkbox.trigger('click');
                return;
              }

              var a = $();

              // Return here and let Tabs control handle the spacebar
              if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
                // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
                e.preventDefault();
                return;
              }

              if (target.is('li')) {
                a = target.children('a');
              }

              if (target.is('a')) {
                a = target;
              }

              if (a.length) {
                a.trigger('click');
                return;
              }
            }

            focus = self.menu.find(':focus');

            var isPicker = (self.settings.menu === 'colorpicker-menu'),
              isAutocomplete = self.element.is('.autocomplete');

            // Close Submenu
            if (key === 37 && !isAutocomplete) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
                focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
                self.highlight(focus.closest('.popupmenu').parent().prev('a'));
              }
            }

            //Up on Up
            if ((!isPicker && key === 38) || (isPicker && key === 37)) {
               e.stopPropagation();
               e.preventDefault();

              //Go back to Top on the last one
              if (focus.parent().prevAll(excludes).length === 0) {
                if (focus.length === 0) {
                  self.highlight(self.menu.children(excludes).last().find('a'));
                } else {
                  self.highlight(focus.closest('.popupmenu').children(excludes).last().find('a'));
                }
                return;
              }
              self.highlight(focus.parent().prevAll(excludes).first().find('a'));
            }

            //Up a square
            if (isPicker && key === 38) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().prevAll(excludes).length > 0) {
                self.highlight($(focus.parent().prevAll(excludes)[9]).find('a'));
              }
            }

            //Right Open Submenu
            if (key === 39  && !isAutocomplete) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().hasClass('submenu')) {
                self.showSubmenu(focus.parent());
                self.highlight(focus.parent().find('.popupmenu a:first'));
              }
            }

            //Down
            if ((!isPicker && key === 40) || (isPicker && key === 39 && !isAutocomplete)) {
              e.stopPropagation();
              e.preventDefault();

              //Go back to Top on the last one
              if (focus.parent().nextAll(excludes).length === 0) {
                if (focus.length === 0) {
                  self.highlight(self.menu.children(excludes).first().find('a'));
                } else {
                  self.highlight(focus.closest('.popupmenu').children(excludes).first().find('a'));
                }
                return;
              }
              self.highlight(focus.parent().nextAll(excludes).first().find('a'));
            }

            //Down a square
            if ((isPicker && key === 40)) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().nextAll(excludes).length > 0) {
                self.highlight($(focus.parent().nextAll(excludes)[9]).find('a'));
              }
            }

          });
        }, 1);
      },

      /**
       * Handles the action of clicking items in the popupmenu.
       * @private
       */
      handleItemClick: function(e, anchor) {
        var href = anchor.attr('href'),
          selectionResult = [anchor];

        if (!e && !anchor) {
          return;
        }

        if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
          //Do not close parent items of submenus on click
          e.preventDefault();
          return;
        }

        if (anchor.find('input[checkbox]').length > 0) {
          return;
        }

        if (this.element.hasClass('btn-filter')) {
          this.iconFilteringUpdate(anchor);
          e.preventDefault();
        }

        if (this.isInSelectableSection(anchor) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable')) {
          selectionResult = this.select(anchor);
        }

        // Single toggle on off of checkbox class
        if (anchor.parent().hasClass('is-toggleable')) {
          anchor.parent().toggleClass('is-checked');
        }

        // Trigger a selected event containing the anchor that was selected
        // If an event object is not passed to `handleItemClick()`, assume it was due to this
        // event being triggered already, making it not necessary to re-trigger it.
        if (e) {
          if (selectionResult.length === 1) {
            selectionResult.push(undefined);
          }

          selectionResult.push(true);
          this.element.triggerHandler('selected', selectionResult);
        }

        // MultiSelect Lists should act like other "multiselect" items and not close the menu when options are chosen.
        if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
          return;
        }

        this.close();

        if (this.element.is('.autocomplete')) {
          return;
        }

        if (href && href.charAt(0) !== '#') {
          if (anchor.attr('target') === '_blank') {
            window.open(href, '_blank');
          } else {
            window.location.href = href;
          }
          return true;
        }

        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
      },

      // Filtering icon initial setup
      iconFilteringSetup: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var svg = this.element.find('svg.icon-dropdown'),
            link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          if (svg.length === 1) {
            this.element.append($.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }));
          }

          svg.first().changeIcon(link.find('svg').getIconName());
          this.element.find('.audible').text(audibleText);
        }
      },

      // Filtering icon update
      iconFilteringUpdate: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          this.element.find('.audible').text(audibleText);
          this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
        }
      },

      // Get the event position, handling browser cases (IE,FF) as well as SVG
      getPositionFromEvent: function (e) {
        var x = 0, y = 0;

        if (!e) {
          e = window.event;
        }

        if (!e) {
          return {};
        }

        if (e.pageX || e.pageY) {
          x = e.pageX;
          y = e.pageY;
        } else if (e.clientX || e.clientY) {
          x = e.clientX + document.body.scrollLeft +
                             document.documentElement.scrollLeft;
          y = e.clientY + document.body.scrollTop +
                             document.documentElement.scrollTop;
        }

        return {
          x: x,
          y: y
        };
      },

      position: function(e) {
        var self = this,
          target = this.element,
          isRTL = this.isRTL(),
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          mouse =  this.getPositionFromEvent(e),
          menuDimensions = {
            width: this.menu.outerWidth(),
            height: this.menu.outerHeight()
          };

        if (!wrapper.length) {
          return;
        }

        var elemWidth = this.element.outerWidth();
        if (elemWidth > menuDimensions.width) {
          this.menu.width(elemWidth);
        }


        if (target.is('svg, .icon') && target.closest('.tab').length) {
          target = target.closest('.tab');
        }

        function getCoordinates(e, axis) {
          axis = ((axis === 'x' || axis === 'y') ? axis : 'x');
          return mouse[axis]; // use mouseX/mouseY if this doesn't work
        }

        // Reset the arrow
        wrapper.find('.arrow').removeAttr('style');

        var opts = $.extend({}, this.settings.placementOpts),
          strategies = ['flip'];

        /*
        if (!target.is('.autocomplete, .searchfield')) {
          strategies.push('nudge');
        }
        */
        strategies.push('shrink-y');

        // If right-click or immediate (with an incoming event object), use coordinates from the event
        if ((this.settings.trigger === 'immediate' && this.settings.eventObj) || this.settings.trigger === 'rightClick') {
          opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + ((isRTL ? -1 : 1) * this.settings.offset.x);
          opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

          if (opts.x === 0 && opts.y === 0) {
            opts.x = this.settings.offset.x || 0;
            opts.y = this.settings.offset.y || 0;
            opts.parent = this.element;
            opts.placement = 'bottom';
            opts.parentXAlignment = isRTL ? 'right' : 'left';
          }

        } else {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
        }
        opts.strategies = strategies;

        //=======================================================
        // BEGIN Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        var toolbarParent = target.parents('.toolbar'),
          insideToolbar = toolbarParent.length > 0,
          insideToolbarTitle = target.parents('.title').length > 0,
          isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1,
          isPagerMenu = target.parents('.pager-pagesize').length > 0;

        function alignLeft() {
          opts.parentXAlignment = (isRTL ? 'right': 'left');
        }

        function alignRight() {
          opts.parentXAlignment = (isRTL ? 'left' : 'right');
        }

        function shiftDown() {
          opts.y = opts.y + 15;
        }

        // Change the alignment of the popupmenu based on certain conditions
        (function doAlignment() {
          if (target.is('.btn-menu')) {
            if (isPagerMenu) {
              return alignRight();
            }

            if (insideToolbar) {
              if (!isNotFullToolbar) {
                return alignLeft();
              }
              if (insideToolbarTitle) {
                return alignLeft();
              }
              return alignRight();
            }

            return alignLeft();
          }

          if (target.is('.btn-actions')) {
            return alignRight();
          }

          if (target.is('.tab-more')) {
            return alignRight();
          }

          if ((target.is('.btn-split-menu, .tab, .searchfield-category-button') &&
            !target.parent('.pager-pagesize').length)) {
              return alignLeft();
            }
        })();

        if (target.parents('.masthead').length > 0) {
          shiftDown();
        }

        // If inside a "page-container" element, constrain the popupmenu to that element
        // (fixes SOHO-6223)
        var container = this.element.parents('.page-container');
        if (container.length) {
          opts.container = container.first();
        }

        //=======================================================
        // END Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        wrapper.one('afterplace.popupmenu', function(e, positionObj) {
          self.handleAfterPlace(e, positionObj);
        });

        wrapper.place(opts);
        wrapper.data('place').place(opts);
      },

      handleAfterPlace: function(e, placementObj) {
        var wrapper = this.menu.parent('.popupmenu-wrapper');
        wrapper.data('place').setArrowPosition(e, placementObj, wrapper);

        if (placementObj.height) {
          wrapper[0].style.height = '';
          this.menu[0].style.height = (placementObj.height) + (/(px|%)/i.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          wrapper[0].style.width = '';
          this.menu[0].style.width = (placementObj.width) + (/(px|%)/i.test(placementObj.width + '') ? '' : 'px');
        }

        wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
        return placementObj;
      },

      /**
       * Calls an external source.
       * @private
       */
      callSource: function (e, doOpen) {
        if (typeof this.settings.beforeOpen !== 'function') {
          return;
        }

        var self = this;
        var response = function(content) {
          if (self.ajaxContent instanceof $) {
            self.ajaxContent.off().remove();
          }
          self.ajaxContent = $(content);
          self.menu.append(self.ajaxContent);

          self.wrapper.removeAttr('style');
          self.markupItems();

          if (doOpen) {
            self.open(e, true);
          }
        };

        if (typeof this.settings.beforeOpen === 'string') {
          window[this.settings.beforeOpen](response);
          return;
        }

        this.settings.beforeOpen(response);
        return;
      },

      open: function(e, ajaxReturn) {
        var self = this;

        var canOpen = this.element.triggerHandler('beforeopen', [this.menu]);
        if (canOpen === false) {
          return;
        }

        // Check external AJAX source, if applicable
        if (!ajaxReturn) {
          this.callSource(e, true);
        }

        var otherMenus = $('.popupmenu.is-open').filter(function() {
          return $(this).parents('.popupmenu').length === 0;
        }).not(this.menu);  //close others.

        otherMenus.each(function() {
          var trigger = $(this).data('trigger');
          if (!trigger || !trigger.length) {
            return;
          }

          var api = $(this).data('trigger').data('popupmenu');
          if (api && typeof api.close === 'function') {
            api.close();
          }
        });

        this.element.addClass('is-open');
        this.menu.addClass('is-open').attr('aria-hidden', 'false');

        this.position(e);

        if (this.element.closest('.header').length > 0) {
          this.menu.parent()[0].style.zIndex =  '9001';
        }

        //Close on Document Click ect..
        setTimeout(function () {
          $(document).on('touchend.popupmenu.' + self.id +' click.popupmenu.' + self.id, function (e) {
            if (e.button === 2) {
              return;
            }

            //Click functionality will toggle the menu - otherwise it closes and opens
            if ($(e.target).is(self.element)) {
              return;
            }

            if ($(e.target).closest('.popupmenu').length === 0) {
              self.close(true, self.settings.trigger ==='rightClick');
            }
          });

          if (window.orientation === undefined) {
            $('body').on('resize.popupmenu', function() {
              self.close();
            });
          }

          $(window).on('scroll.popupmenu', function () {
            self.close();
          });

          $('.scrollable').on('scroll.popupmenu', function () {
            self.close();
          });

          self.element.triggerHandler('open', [self.menu]);

          if (self.settings.trigger === 'rightClick') {
            self.element.on('click.popupmenu touchend.popupmenu', function () {
              self.close();
            });
          }
        }, 300);

        //Hide on iFrame Clicks - only works if on same domain
        $('iframe').each(function () {
          var frame = $(this);
          frame.ready(function () {

            try {
              frame.contents().find('body').on('click.popupmenu', function () {
                self.close();
              });
            } catch (e)  {
              //Ignore security errors on out of iframe
            }

          });
        });

        this.handleKeys();

        //hide and decorate submenus - we use a variation on
        var tracker = 0, startY, menuToClose, timeout;

        self.menu.find('.popupmenu').removeClass('is-open');
        self.menu.on('mouseenter.popupmenu touchstart.popupmenu', '.submenu', function (e) {
          var menuitem = $(this);
          startY = e.pageX;

          clearTimeout(timeout);
          timeout = setTimeout(function () {
            self.showSubmenu(menuitem);
          }, 300);

          $(document).on('mousemove.popupmenu.' + this.id, function (e) {
            tracker = e.pageX;
          });
        }).on('mouseleave.popupmenu', '.submenu', function () {
          $(document).off('mousemove.popupmenu.' + this.id);

          menuToClose = $(this).find('ul');

          var isLeft = parseInt(menuToClose.parent('.wrapper')[0].style.left) < 0,
            canClose = (tracker - startY) < 3.5;

          if (isLeft) {
            canClose = (tracker - startY) >= 0;
          }

          if (canClose) { //We are moving slopie to the menu
            menuToClose.removeClass('is-open').removeAttr('style');
            menuToClose.parent('.wrapper').removeAttr('style');
            menuToClose.parent().parent().removeClass('is-submenu-open');
            menuToClose = null;
          }
          clearTimeout(timeout);
        });

        if (self.settings.autoFocus) {
          setTimeout(function () {
            var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
              selection = self.menu.children(excludes).find('.is-selected').children('a');

            if (!selection.length) {
              selection = self.menu.children(excludes).first().children('a');
            }

            self.highlight(selection);
            self.element.triggerHandler('afteropen', [self.menu]);
          }, 1);
        }
      },

      showSubmenu: function (li) {
        if (Soho.DOM.classNameHas(li[0].className, 'is-disabled') || li[0].disabled) {
          return;
        }

        // Trigger an event so other components can listen to this element as a popupmenu trigger.
        this.element.triggerHandler('show-submenu', [li]);

        var wrapper = li.children('.wrapper').filter(':first'),
          isRTL = this.isRTL(),
          rtlPadding = 30;

        // Wrap if not wrapped (dynamic menu situation)
        if (wrapper.length === 0) {
          var ul = li.children('ul').filter(':first');
          ul.wrap('<div class="wrapper"></div>');
          wrapper = ul.parent();
        }

        var menu = wrapper.children('.popupmenu'),
          mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top,
          wrapperLeft = li.position().left + li.outerWidth();
        li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');

        if (isRTL) {
          wrapperLeft = li.position().left - li.outerWidth() + rtlPadding;
        }
        wrapper[0].style.left = wrapperLeft + 'px';
        wrapper[0].style.top = (parseInt(li.position().top) - 5) + 'px';

        wrapper.children('.popupmenu').addClass('is-open');

        //Handle Case where the menu is off to the right
        var menuWidth = menu.outerWidth();
        if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()) || (isRTL && wrapper.offset().left < 0)) {
          wrapper[0].style.left = '-9999px';
          menuWidth = menu.outerWidth();
          wrapperLeft = li.position().left - menuWidth;
          if (isRTL) {
            wrapperLeft = li.position().left + menuWidth + rtlPadding;
          }
          wrapper[0].style.left = wrapperLeft + 'px';
          //Did it fit?
          if (wrapper.offset().left < 0 || (isRTL && (wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()))) {
            //No. Push the menu's left offset onto the screen.
            wrapperLeft = li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40;
            if (isRTL) {
              wrapperLeft = li.position().left - menuWidth - rtlPadding - 40;
            }
            wrapper[0].style.left = wrapperLeft + 'px';
            menuWidth = menu.outerWidth();
          }
          // Do one more check to see if the right edge bleeds off the screen.
          // If it does, shrink the menu's X size.
          if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()) || (isRTL && wrapper.offset().left < 0)) {
            var differenceY = (wrapper.offset().left + menuWidth) - ($(window).width() + $(document).scrollLeft());
            menuWidth = menuWidth - differenceY;
            menu[0].style.width = menuWidth + 'px';
          }
        }

        //Handle Case where menu is off bottom
        var menuHeight = menu.outerHeight();
        if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
          // First try bumping up the menu to sit just above the bottom edge of the window.
          var bottomEdgeCoord = wrapper.offset().top + menuHeight,
            differenceFromBottomY = bottomEdgeCoord - ($(window).height() + $(document).scrollTop());

          wrapper[0].style.top = (wrapper.position().top - differenceFromBottomY) + 'px';

          // Does it fit?
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            // No. Bump the menu up higher based on the menu's height and the extra space from the main wrapper.
            wrapper[0].style.top = (($(window).height() + $(document).scrollTop()) - menuHeight - mainWrapperOffset) + 'px';
          }

          // Does it fit now?
          if ((wrapper.offset().top - $(document).scrollTop()) < 0) {
            // No. Push the menu down onto the screen from the top of the window edge.
            wrapper[0].style.top = 0;
            wrapper[0].style.top = (wrapper.offset().top * -1) + 'px';
            menuHeight = menu.outerHeight();
          }

          // Do one more check to see if the bottom edge bleeds off the screen.
          // If it does, shrink the menu's Y size and make it scrollable.
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            var differenceX = (wrapper.offset().top + menuHeight) - ($(window).height() + $(document).scrollTop());
            menuHeight = menuHeight - differenceX - 32;
            menu[0].style.height = menuHeight + 'px';
          }
        }

        li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
        li.addClass('is-submenu-open');
      },

      highlight: function(anchor) {
        if (!anchor || !anchor.length) {
          return false;
        }

        var li = anchor.parent();

        li.parent().children('li').removeClass('is-focused');
        li.addClass('is-focused');

        //Prevent chrome from scrolling - toolbar
        anchor.focus();
        li.closest('.header').scrollTop(0);

      },

      // adds/removes checkmarks that are in selectable groups inside the popupmenu
      select: function(anchor) {
        var singleMenu = this.menu.is('.is-selectable'),
          multipleMenu = this.menu.is('.is-multiselectable'),
          singleSection = this.isInSingleSelectSection(anchor),
          multipleSection = this.isInMultiselectSection(anchor),
          parent = anchor.parent(),
          returnObj = [anchor, 'selected'];

        if (!singleMenu && !multipleMenu && !singleSection && !multipleSection) {
          return;
        }

        // If the entire menu is "selectable", place the checkmark where it's supposed to go.
        if (singleMenu || singleSection) {
          parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
          parent.addClass('is-checked');
          return returnObj;
        }

        if (multipleMenu || multipleSection) {
          if (parent.hasClass('is-checked')) {
            returnObj[1] = 'deselected';
            parent.removeClass('is-checked');
            return returnObj;
          }
          parent.addClass('is-checked');
          return returnObj;
        }
      },

      getSelected: function() {
        if (!this.menu.is('.is-selectable, .is-multiselectable')) {
          return $();
        }

        return this.menu.children('.is-checked').children('a');
      },

      isInSelectableSection: function(anchor) {
        var separator = anchor.parent().prevAll().filter('.separator').first();
        return (separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section'));
      },

      isInSingleSelectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
      },

      isInMultiselectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
      },

      detach: function () {
        $(document).off('touchend.popupmenu.' + this.id +' click.popupmenu.' + this.id +' keydown.popupmenu');
        $(window).off('scroll.popupmenu orientationchange.popupmenu');
        $('body').off('resize.popupmenu');
        $('.scrollable').off('scroll.popupmenu');

        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');

        if (this.settings.trigger === 'rightClick') {
          this.element.off('click.popupmenu touchend.popupmenu');
        }

        $('iframe').each(function () {
          var frame = $(this);
          try {
            frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
          } catch (e) {
            //Ignore security errors on out of iframe
          }
        });
      },

      /**
       * Close the open menu
       * @param {Boolean} isCancelled  &nbsp;-&nbsp; Internally set option used if the operation is a cancel. Wont matter for manual api call.
       * @param {Boolean} noFocus  &nbsp;-&nbsp; Do not return focus to the calling element (fx a button)
       */
      close: function (isCancelled, noFocus) {
        if (!isCancelled || isCancelled === undefined) {
          isCancelled = false;
        }

        if (!this.menu.hasClass('is-open')) {
          return;
        }

        var self = this,
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          menu = this.menu.find('.popupmenu');

        this.menu.removeClass('is-open').attr('aria-hidden', 'true');
        if (this.menu[0]) {
          this.menu[0].style.height = '';
          this.menu[0].style.width = '';
        }

        if (wrapper[0]) {
          wrapper[0].style.left = '-999px';
          wrapper[0].style.height = '';
          wrapper[0].style.width = '';
        }

        this.menu.find('.submenu').off('mouseenter mouseleave').removeClass('is-submenu-open');
        if (menu[0]) {
          menu[0].style.left = '';
          menu[0].style.top = '';
          menu[0].style.height = '';
          menu[0].style.width = '';
        }

        this.menu.find('.is-focused').removeClass('is-focused');

        // Close all events
        $(document).off('keydown.popupmenu.' + this.id + ' click.popupmenu.' + this.id + ' mousemove.popupmenu.' + this.id);
        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu mouseenter.popupmenu mouseleave.popupmenu');

        this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
        this.detach();

        if (this.settings.trigger === 'immediate') {
          this.destroy();
        }

        if (noFocus) {
          return;
        }

        self.element.removeClass('hide-focus').focus();
      },

      teardown: function() {
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        if (this.ajaxContent) {
          this.ajaxContent.off().remove();
        }

        this.menu.parent().off('contextmenu.popupmenu');
        if (this.element.hasClass('btn-actions')) {
          this.menu.parent().removeClass('bottom').find('.arrow').remove();
        }

        if (this.originalParent) {
          this.menu.appendTo(this.originalParent);
        } else {
          // TODO: Fix when we have time - shouldn't be referencing other controls here
          var insertTarget = this.element,
            searchfield = this.element.parent().children('.searchfield');
          if (searchfield.length) {
            insertTarget = searchfield.first();
          }

          this.menu.insertAfter(insertTarget);
        }

        this.menu.find('.submenu').children('a').each(function(i, item) {
          var text = $(item).find('span').text();
          $(item).find('span, svg').remove();
          $(item).text(text);
        });

        function unwrapPopup(menu) {
          var wrapper = menu.parent();
          if (wrapper.is('.popupmenu-wrapper, .wrapper')) {
            if (wrapper.data('place')) {
              wrapper.data('place').destroy();
            }
            menu.unwrap();
          }
        }

        // Unwrap submenus
        this.menu.find('.popupmenu').each(function() {
          unwrapPopup($(this));
        });

        if (wrapper.data('place')) {
          wrapper.data('place').destroy();
        }
        wrapper.off().remove();

        if (this.matchMedia) {
          this.matchMedia.removeListener(this.mediaQueryListener);
        }

        if (this.menu[0]) {
          $.removeData(this.menu[0], 'trigger');
        }

        this.detach();
        this.element
          .removeAttr('aria-controls')
          .removeAttr('aria-haspopup')
          .off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keypress.popupmenu contextmenu.popupmenu');

        return this;
      },

      updated: function() {
        this.teardown().init();
      },

      /**
       * Teardown markup and detach all events.
       */
      destroy: function() {
        this.teardown();
        this.menu.trigger('destroy');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new PopupMenu(this, settings));
      }
    });
  };


  $.fn.progress = function(options) {

    // Settings and Options
    var pluginName = 'progress',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Progress Component displays loading information.
    *
    * @class Progress
    * @param None
    */
    function Progress(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Progress Code
    Progress.prototype = {

      init: function() {
        var self = this;
        self.update();

        this.element.off('updated.progress').on('updated.progress', function (e) {
          e.stopPropagation();
          self.update();
        });
      },

      updateAria: function (value) {
        this.element.attr({'role': 'progressbar', 'aria-valuenow': value, 'aria-maxvalue':'100'});

        var container = this.element.parent();
        if (container.data('tooltip')) {
          container.data('tooltip').content = value + '%';
        } else {
          container.attr('title', value + '%').tooltip();
        }
      },

      /**
      * Update the progress bar.
      *
      * @param {String} value  &nbsp;-&nbsp; The percent value to use to fill. 0-100
      */
      update: function (value) {

        var perc = this.element.attr('data-value');

        if (value) {
          perc = value;
          this.element.attr('data-value', value);
        }

        this.element[0].style.width = perc + '%';
        this.updateAria(perc);
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('updated.progress');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Progress(this, settings));
      }
    });
  };


  var DECIMAL_SYMBOL = '.';
  var THOUSANDS_SEPARATOR = ',';

  $.fn.mask = function(options) {

    // Tab Settings and Options
    var pluginName = 'mask',
        defaults = {
          pattern: '',
          placeholder: '_',
          definitions: {
            '#': /[0-9]/,
            '0': /[0-9]/,
            'x': /[\u00C0-\u017Fa-zA-Z]/,
            '*': /[\u00C0-\u017Fa-zA-Z0-9]/,
            '?': /./,
            '~': /[-0-9]/,
            'a': /[APap]/,
            'm': /[Mm]/
          },
          groupComplete: false,
          mode: undefined,
          mustComplete: false,
          negative: false,
          number: false,
          processOnInitialize: true,
          processOnBlur: true,
          thousandsSeparator: false,
          showSymbol: undefined,
        },
        maskModes = ['group', 'number', 'date', 'time'],
        symbols = ['currency', 'percent'],
        settings = $.extend({}, defaults, options);

    /**
    * The Mask Component limits and aids user input.
    *
    * @class Mask
    * @param {String} pattern  &nbsp;-&nbsp; The mask regex pattern to use
    * @param {Array} definitions  &nbsp;-&nbsp; An extendable array of letters matching regex expressions.
    * @param {String} mode  &nbsp;-&nbsp; Hints for specific types, can be number, group, time
    * @param {Boolean} mustComplete  &nbsp;-&nbsp; Whether or not the entire mask must be typed to be valid or if partial is accepted
    * @param {Boolean} negative  &nbsp;-&nbsp; If true negative numbers are accepted.
    * @param {Boolean} processOnInitialize  &nbsp;-&nbsp; If set to false, will not initialially mask the value of the input field.
    * @param {Boolean} processOnBlur  &nbsp;-&nbsp; If set to false, will not mask the value of the input field upon blur.
    * @param {Boolean} thousandsSeparator  &nbsp;-&nbsp; If the mask should use the thousands separator or not.
    * @param {Boolean} showSymbol  &nbsp;-&nbsp; If a non-editable symbol should be inserted can be 'currency', 'percent'
    *
    */
    function Mask(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Mask.prototype = {
      init: function(){
        var self = this;
        self.buffer = '';

        this.element.addClass('is-mask');

        // Order of operations when choosing pattern strings:
        // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
        //
        // if no pattern is provided in settings, use a pre-determined pattern based
        // on element type, or grab the pattern from the element itself.
        var html5DataMask = this.element.attr('data-mask') || false;
        if (html5DataMask) {
          this.settings.pattern = html5DataMask;
        }

        // If a "mode" is defined, special formatting rules may apply to this mask.
        // Otherwise, the standard single-character pattern match will take place.
        var html5DataMaskMode = this.element.attr('data-mask-mode') || false;
        if (html5DataMaskMode) {
          this.settings.mode = html5DataMaskMode;
        }
        if (this.settings.mode) {
          if ($.inArray(this.settings.mode, maskModes) === -1) {
            this.settings.mode = 'group';
          }
        }

        // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.
        var html5DataThousands = this.element.attr('data-thousands') || false;
        if (html5DataThousands) {
          this.settings.thousandsSeparator = (html5DataThousands === 'true');
        }

        // If "negative" is defined, you can type the negative symbol in front of the number.
        // Will automatically set to "true" if a negative symbol is detected inside the mask.
        this.settings.negative = this.settings.mode === 'number' && this.settings.pattern.indexOf('-') !== -1;

        // If 'mustComplete' is defined, you MUST complete the full mask, or the mask will revert to empty
        // once the field is blurred.
        var html5DataMustComplete = this.element.attr('data-must-complete') || false;
        if (html5DataMustComplete) {
          this.settings.mustComplete = html5DataMustComplete;
        }

        // If 'showCurrency' is defined and the mask mode is 'number', a span will be drawn that will show the
        // localized currency symbol.
        var symbolType = this.settings.showSymbol,
          symbol;

        // Backwards compat with the old "data-show-currency"
        if (symbolType === true) {
          symbolType = 'currency';
        }

        if (symbolType && symbolType !== undefined && symbols.indexOf(symbolType) !== -1 && this.settings.mode === 'number') {
          switch(symbolType) {
            case 'currency':
              symbol = (Locale.currentLocale.data ? Locale.currentLocale.data.currencySign : '$');
              break;
            case 'percent':
              symbol = '%';
              break;
          }

          $('<span class="audible ' + symbolType + '"></span>').text(' ' + symbol).appendTo(self.element.prev('label'));
          this.element.parent('.field, .datagrid-filter-wrapper')
            .attr('data-currency-symbol', '' + symbol)
            .addClass(symbolType);
        }

        // If we are doing a grouped pattern match (for dates/times/etc), we need to store an object that contains
        // separated pieces of "editable" and "literal" parts that are used for checking validity of mask pieces.
        var modeClassMethod = 'addClass';
        if (self.settings.mode !== 'number') {
          self.maskParts = self.getPatternParts();
          modeClassMethod = 'removeClass';
        }
        this.element[modeClassMethod]('is-number-mask');

        // If 'self.groupComplete' is active, each section of the group pattern match must be full in order for the
        // literals in-between each section to be automatically added (meaning, you can't type a literal to end that
        // group until all characters in that group are entered).  This is used for some group matching and for time.
        var html5DataGroupComplete = self.element.attr('data-group-complete');
        if (html5DataGroupComplete) {
          this.settings.groupComplete = true;
        }
        // Backwards Compat with the old "time" mode
        if (this.settings.mode === 'time') {
          this.settings.mode = 'group';
        }

        // Point all keyboard related events to the handleKeyEvents() method, which knows how to
        // deal with key syphoning and event propogation.
        self.element.on('keypress.mask keydown.mask keyup.mask ' + self.getPasteEvent(), function(e) {
          if (self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }
          self.handleKeyEvents(self, e);
        });

        // when the element is focused, store its initial value.
        self.element.on('focus.mask', function(e) {
          if (self.element.prop('disabled') || self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }
          self.initValue = self.element.val();
        });

        // listen for an event called "updated" that can be triggered by other plugins, that forces the mask
        // to completely re-evaluate itself.
        self.element.on('updated.mask', function(e) {
          self.evaluateCurrentContents(undefined, e);
        });

        function reprocess(isRemask) {
          var val = self.element.val();

          if (self.settings.mustComplete) {
            self.checkCompletion();
          }
          if (val && self.initValue !== val) {
            if (isRemask || self.settings.processOnBlur) {
              self.remask( !isRemask );
            }
            self.element.trigger('change');
          }
        }

        // custom event that can be triggered for forcing a remasking of the input field
        self.element.on('remask.mask', function() {
          reprocess(true);
        });

        // remove the value when blurred
        self.element.on('blur.mask', function(e) {
          if (self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }

          reprocess();
          self.initValue = null;
          return true;
        });

        // Don't continue if the field is hidden -OR- we disallow the masking of contents during initialization.
        if (this.element.is(':hidden') || !this.settings.processOnInitialize) {
          return this;
        }

        // Test contents of the input field.  If there are characters, run them
        // against the mask and fill them in as necessary.
        var val = self.element.val();
        if (val.length > 0) {
          self.element.val('');
          self.processStringAgainstMask(val);
        }

        return this;
      },

      // Builds a fake element and gets the name of the event that will be used for "paste"
      // Used for cross-browser compatability.
      getPasteEvent: function() {
        return window.Soho.env.pasteEvent + '.mask';
      },

      // Gets rid of event firing and bubbling in all browsers.
      killEvent: function(e) {
        if (e) {
          e.returnValue = false;
          if (e.preventDefault) {
            e.preventDefault();
          }
        }
        return false;
      },

      // Helper Function for Caret positioning.  If you provide "begin" and "end" arguments, the caret position
      // will change.  If you simply call the method with no arguments, it returns an object containing the cursor's
      // beginning and ending posititons.
      caret: function(begin, end) {
        var self = this,
          range;
        if (self.element.val().length === 0 || self.element.is(':hidden')) {
          return {
            begin: 0,
            end: 0
          };
        }
        if (typeof begin === 'number') {
          end = (typeof end === 'number') ? end : begin;
          return self.element.each(function() {
            if (this.setSelectionRange) {
              this.setSelectionRange(begin, end);
            } else if (this.createTextRange) {
              range = this.createTextRange();
              range.collapse(true);
              range.moveEnd('character', end);
              range.moveStart('character', begin);
              range.select();
            }
          });
        } else {
          if (self.element[0].setSelectionRange) {
            begin = self.element[0].selectionStart;
            end = self.element[0].selectionEnd;
          } else if (document.selection && document.selection.createRange) {
            range = document.selection.createRange();
            begin = 0 - range.duplicate().moveStart('character', -100000);
            end = begin + range.text.length;
          }
          return {
            begin: begin,
            end: end
          };
        }
      },

      // Moves the text input cursor a specified distance in a specified direction
      moveCursor: function(direction, distance) {
        var self = this,
          pos = self.caret();

        direction = self.evaluateDirecton(direction);
        distance = distance || 1;

        switch(direction) {
          case 'next':
            self.caret(pos.begin + distance);
            break;
          case 'prev':
            self.caret(pos.begin - distance);
            break;
          default:
            break;
        }
      },

      // Get the direction in which to position the cursor (if necessary)
      // defaults to 'current', which will not move the cursor.
      evaluateDirecton: function(direction) {
        if (!direction) {
          return 'current';
        }
        var directions = ['current', 'next', 'prev'],
          i = $.inArray(direction, directions);
        return directions[i];
      },

      // If the mask isn't completed to the end, erase the contents of the input field
      // Used on Blur if the "mustComplete" flag is set
      checkCompletion: function() {
        var inputLength = this.element.val().length,
          maskLength = this.settings.pattern.length;

        if (maskLength !== inputLength) {
          this.element.val('');
        }
      },

      // Evaluates the entire current contents of the input field against its mask.
      // Used when the field is blurred, and after a Backspaced character is removed
      evaluateCurrentContents: function(newValue, e) {
        if (newValue === null || newValue === undefined) {
          newValue = this.element.val();
        }
        if (!e) {
          e = $.Event();
        }

        this.element.val('');

        if (document.activeElement === e.target) {
          this.caret(0);
        }
        this.processStringAgainstMask(newValue, e);
      },

      // The catch-all event for handling keyboard events within this input field. Grabs information about the keys
      // being pressed, event type, matching pattern characters, and determines what to do with them.
      handleKeyEvents: function(self, e) {
        var evt = e || window.event,
          eventType = evt.originalEvent.type,
          key = e.which,
          typedChar = $.actualChar(e);

        // Remove modifiers on "keyup"
        if (eventType === 'keyup') {
          if (key === 8) {
            return this.handleBackspace(e);
          }

          return;
        }

        // Handle most input on "keypress"
        if (eventType === 'keypress') {
          // Ignore all of these keys or combinations containing these keys
          if (evt.ctrlKey || evt.metaKey || key < 32) {
            return;
          // Never allow any combinations with the alt key, since on Mac OSX it's used to create special characters
          } else if (evt.altKey) {
            self.killEvent(e);
          }

          if (self.settings.mode === 'number') {
            self.processNumberMask(typedChar, evt);
          } else {
            self.processMask(typedChar, evt);
          }

        }

        if (eventType === 'paste') {
          self.handlePaste(evt);
        }
      },

      // When using Backspace, correctly remove the intended text content and place the caret
      // in the correct place.
      handleBackspace: function() {
        var val = this.element.val();
        this.element.trigger('write.mask', [val]);
        return;
      },

      // When escaping from a modified field, place the initial value of the field
      // back in place of the discarded edits.
      handleEscape: function(e) {
        var self = this;
        self.element.val(self.initValue);
        self.caret(0, self.initValue.length);
        self.initValue = null;
        return self.killEvent(e);
      },

      // Pressing Tab changes field focus, but we run a check on the field beforehand to fix any mask errors.
      // Similar to running on "blur" but prevents issues in IE where focus traps would happen.
      handleTab: function(e) {
        return this.evaluateCurrentContents(undefined, e);
      },

      // Intercepts the Paste event, modifies the contents of the clipboard to fit within the size
      // and character limits of the mask, and writes the result to the input field.
      handlePaste: function(e) {
        var paste = e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData ?
          e.originalEvent.clipboardData.getData('text/plain') : // Standard
          window.clipboardData && window.clipboardData.getData ?
          window.clipboardData.getData('Text') : // MS
          false;

        if (paste) {
          // cut down the total size of the paste input to only be as long as the pattern allows * 2.
          var pasteLimiter = (this.settings.pattern.length * 2) > paste.length ? paste.length : this.settings.pattern.length * 2,
            maxPasteInput = paste.substring(0, pasteLimiter);
          this.processStringAgainstMask(maxPasteInput, e);
        }
        this.element.trigger('afterpaste.mask');
        this.killEvent(e);
      },

      // Attempts to match the character provided from a pattern against the array of
      // pattern matching characters ("definitions"). If the character is not in the array,
      // it is considered "literal", and will be placed into the input field as part of the mask.
      isCharacterLiteral: function(patternChar) {
        return $.inArray(patternChar, Object.keys(this.settings.definitions)) === -1;
      },

      // Tests the character provided against the current langauge's decimal selector
      // TODO: Add globalization support for the decimal selector
      isCharacterDecimal: function(patternChar) {
        return patternChar === '.';
      },

      // The following methods are used for modifying the contents of strings based on caret position.
      // TODO: Move these to a more global space for use in other plugins?
      insertAtIndex: function(string, value, index) {
          return string.substring(0, index) + value + string.substring(index);
      },
      replaceAtIndex: function(string, value, indexStart, indexEnd) {
        return string.substr(0, indexStart) + value + string.substr(isNaN(indexEnd) ? (indexStart + value.length) : indexEnd);
      },
      deleteAtIndex: function(string, value, index) {
        return string.substr(0, index) + string.substr(index + value.length);
      },

      getCharacterAtIndex: function(string, index) {
        return string.substr(index, 1);
      },

      // Resets properties used for internal storage between keypresses to their default values
      resetStorage: function() {
        this.originalPos = null;
        this.currentMaskBeginIndex = null;
        this.buffer = '';
      },

      // Writes the current value of the internal text buffer out to the Input Field.
      // Additionally, resets the Caret to the right position.
      writeInput: function(reprocess) {
        var self = this,
          val = this.element.val(),
          pos = this.originalPos,
          buffer = reprocess === true ? '' : this.buffer,
          buffSize = reprocess === true ? 0 : buffer.length,
          workingPattern = '' + this.settings.pattern, // copy the pattern, don't reference it
          pattSize = workingPattern.length,
          isNumberMask = (this.settings.mode === 'number'),
          replaceAtIndex = this.replaceAtIndex;

        var DASH_SYMBOL = '-';
        var DASH_REGEX = new RegExp(DASH_REGEX, 'g'); // original: \-\g
        var DECIMAL_REGEX = new RegExp('\\' + DECIMAL_SYMBOL, 'g'); // original: /\./g
        var LEADING_ZERO_REGEX = new RegExp('^0+(?!\\'+ DECIMAL_SYMBOL +'|$)'); // original: /^0+(?!\.|$)/
        var THOUSANDS_SEP_REGEX = new RegExp(THOUSANDS_SEPARATOR, 'g');
        var PUNCTUATION_REGEX = new RegExp('(\\' + DECIMAL_SYMBOL + '|' + THOUSANDS_SEPARATOR + ')', 'g'); // original: /(\.|,)/g

        function moveCaret(amount) {
          pos.begin = pos.begin + amount;
          pos.end = pos.end + amount;
        }

        function stripSelection() {
          if (reprocess === true) {
            return;
          }

          var selection = val.substring(pos.begin, pos.end);
          val = replaceAtIndex(val, '', pos.begin, pos.end);
          pos.end = pos.end - selection.length;
        }

        function insertBuffer() {
          if (reprocess === true) {
            return;
          }

          val = self.insertAtIndex(val, buffer, pos.begin);
          moveCaret(buffSize);
        }

        // Remove the thousands separator from the working pattern if its setting is disabled
        if (!this.settings.thousandsSeparator) {
          workingPattern = workingPattern.replace(THOUSANDS_SEP_REGEX, '');
          pattSize = workingPattern.length;
        }

        if (!isNumberMask) {
          // strip out the portion of the text that would be selected by the caret
          stripSelection();

          // insert the buffer's contents
          insertBuffer();

          // cut down the total length of the string to make it no larger than the pattern mask
          val = val.substring(0, pattSize);

          // put it back!
          this.element.val(val);

          // reposition the caret to be in the correct spot (after the content we just added).
          if (reprocess !== true) {
            this.caret(pos.begin >= pattSize ? pattSize : pos.begin);
          }

          // trigger the 'write' event
          this.element.trigger('write.mask', [val]);
          return;
        }

        //================================================
        // Handle Number Inputs with a bit more scaffolding

        stripSelection();

        var originalVal = val,
          patternHasDecimal = workingPattern.indexOf(DECIMAL_SYMBOL) > -1,
          currentDecimalIndex = val.indexOf(DECIMAL_SYMBOL),
          decimalInBuffer = buffer.indexOf(DECIMAL_SYMBOL) > -1,
          insertBufferBeforeDecimal = true,
          decimalAlreadyExists = false;

        // Does it already exist?
        decimalAlreadyExists = currentDecimalIndex !== -1;

		if (decimalAlreadyExists) {
          // Are we placing the new content after the decimal?
          insertBufferBeforeDecimal = currentDecimalIndex >= pos.begin;
        }

        // insert the buffer's contents
        insertBuffer();

        // If the mask supports negative numbers, but a positive number is present,
        // don't calculate the negative symbol as part of the current pattern.
        // Also, Reduce the size of the buffer to the new maximum (pattern size minus one, representing the newly removed minus)
        if (this.settings.negative && val.indexOf(DASH_SYMBOL) === -1) {
          workingPattern = workingPattern.substring(1);
          pattSize = workingPattern.length;
          val = val.substring(0, pattSize);
        }

        // cut all but the first occurence of the negative symbol and decimal
        val = this.replaceAllButFirst(DASH_REGEX, val, '');
        val = this.replaceAllButFirst(DECIMAL_REGEX, val, '');

        // cut any extra leading zeros.
        var valWithoutLeadZeros = val.replace(LEADING_ZERO_REGEX, ''),
          numLeadingZeros = val.length - valWithoutLeadZeros.length;

        val = valWithoutLeadZeros;
        moveCaret(-(numLeadingZeros));

        var maskParts = workingPattern.replace(THOUSANDS_SEP_REGEX, '').split(DECIMAL_SYMBOL),
          totalLengthMinusSeparators = maskParts[0].length + (maskParts[1] ? maskParts[1].length : 0),
          separatorLength;

        // move the caret backward only the number of punctuation marks that were removed
        // up to the current caret position.
        var currentSliceUpToCaret = val.substring(0, pos.begin),
          commasUpToCaret = currentSliceUpToCaret.length - currentSliceUpToCaret.replace(THOUSANDS_SEP_REGEX, '').length;

        moveCaret(-(commasUpToCaret));

        // strip out the decimal and any commas from the current value
        val = val.replace(PUNCTUATION_REGEX, '');
        separatorLength = originalVal.length - val.length;

        // cut down the total length of the number if it's longer than the total number of integer
        // and decimal places
        if (val.length > totalLengthMinusSeparators) {
          val = val.substring(0, totalLengthMinusSeparators);
        }

        // if the original value had a decimal point, place it back in the right spot
        if (patternHasDecimal) {
          if (decimalAlreadyExists) {
            var inputParts = originalVal.replace(THOUSANDS_SEP_REGEX, '').split(DECIMAL_SYMBOL),
              targetDecimalIndex;


            // reposition the decimal in the correct spot based on total number of characters
            // in either part of the mask.
            if (inputParts[1].length < maskParts[1].length) {
              if (inputParts[0].length >= maskParts[0].length) {
                targetDecimalIndex = maskParts[0].length;
              } else {
                targetDecimalIndex = inputParts[0].length;
              }
            } else if (inputParts[1].length === maskParts[1].length) {
			  if (!insertBufferBeforeDecimal) {
			    val = val.substring(0, inputParts[0].length + maskParts[1].length);
			  }
			  targetDecimalIndex = (val.length - maskParts[1].length);
            } else {
              targetDecimalIndex = (val.length - maskParts[1].length);
            }

            val = this.insertAtIndex(val, DECIMAL_SYMBOL, targetDecimalIndex);
          } else {
            // The decimal doesn't already exist in the value string.
            // if the current value has more characters than the "integer" portion of the mask,
            // automatically add the decimal at index of the last pre-decimal pattern character.
			if (decimalInBuffer){
				if ((val.length - (pos.begin - 1)) > maskParts[1].length) {
				  val = val.substring(0, (pos.begin - 1) + maskParts[1].length);
				}
				if (buffer.indexOf(DECIMAL_SYMBOL) === 0) {
				  val = this.insertAtIndex(val, DECIMAL_SYMBOL, pos.begin - 1);
				}
				else
				{
				  val = this.insertAtIndex(val, DECIMAL_SYMBOL, buffer.indexOf(DECIMAL_SYMBOL));
				}
			}
            else if (val.length > maskParts[0].length) {
              val = this.insertAtIndex(val, DECIMAL_SYMBOL, maskParts[0].length);
              if (pos.begin === maskParts[0].length) {
                moveCaret(1);
              }
            }
          }
        }

        // Only do this part if the thousands separator should be present.
        if (this.settings.thousandsSeparator) {
          // Reposition all the commas before the decimal point to be in the proper order.
          // Store the values of "added" and "removed" commas.
          var valHasDecimal = val.length - val.replace(DECIMAL_REGEX, '').length > 0,
            parts = valHasDecimal ? val.split(DECIMAL_SYMBOL) : [val],
            reAddTheCommas = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, THOUSANDS_SEPARATOR);

          // add the commas back in
          parts[0] = reAddTheCommas;
          val = valHasDecimal ? parts.join(DECIMAL_SYMBOL) : parts[0] + (valHasDecimal ? DECIMAL_SYMBOL : '');

          currentSliceUpToCaret = reAddTheCommas.substring(0, this.originalPos.begin + separatorLength);
          commasUpToCaret = currentSliceUpToCaret.length - currentSliceUpToCaret.replace(THOUSANDS_SEP_REGEX, '').length;

          if (commasUpToCaret > 0) {
            moveCaret(commasUpToCaret);
          }

          // Manual adjustment for situations where the cursor won't move if you type a number while the
          // cursor sits in the position immediately after a thousands separator.
          if (val.substring(pos.begin - 1, pos.begin) === THOUSANDS_SEPARATOR && val.substr(pos.begin, buffSize) === buffer) {
            moveCaret(buffSize);
          }
        }

        // put it back!
        this.element.val(val);

        // reposition the caret to be in the correct spot (after the content we just added).
        if (reprocess !== true) {
          this.caret(pos.end >= pattSize ? pattSize : pos.end);
        }

        // trigger the 'write' event
        this.element.trigger('write.mask', [val]);
      },

      // Method for processing number masks
      // TODO:  Flesh out content and docs
      processNumberMask: function(typedChar, e) {
        var self = this,
          val = self.element.val(),
          maskWithoutInts = self.settings.pattern.replace(/#/g, ''),
          numMaskInts = self.settings.pattern.length - maskWithoutInts.length,
          match,
          patternChar;

        self.originalPos = self.caret();
        self.currentMaskBeginIndex = self.currentMaskBeginIndex || self.originalPos.begin;

        // don't do anything if you're at the end of the pattern.  You can't type anymore.
        if (self.currentMaskBeginIndex >= self.settings.pattern.length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // Get the currently typed string up to the beginning of the caret.
        var sliceUpToCaret = val.substring(0, self.originalPos.begin),
          sliceHasDecimal = sliceUpToCaret.length !== sliceUpToCaret.replace(/\./g, '').length,
          inputWithoutDec = val.replace(/\./g, ''),
          valHasDecimal = val.length !== inputWithoutDec.length,
        // Do a check to see if the character typed matches the mask pattern character.
        // This is done against the mask WITHOUT COMMAS.  The caret's position is adjusted
        // for the difference in position.
          commasUpToCaret = sliceUpToCaret.length - sliceUpToCaret.replace(/,/g, '').length,
          trueMaskIndex = sliceUpToCaret.length - commasUpToCaret;
        patternChar = self.getCharacter('current', trueMaskIndex);

        // Is the decimal already in the slice up to the caret?
        // If it is, only work with the "post-decimal" portion of the mask
        if (sliceHasDecimal) {
          var postDecMask = self.settings.pattern.split('.')[1],  // tests all mask characters after the decimal
            postDecSlice = sliceUpToCaret.split('.')[1], // tests only typed characters after the decimal up to the caret
            distanceFromDec = (self.originalPos.begin - 1) - sliceUpToCaret.indexOf('.');
          patternChar = postDecMask.charAt(distanceFromDec);

          // if there are as many or more characters in the slice as the mask, don't continue.
          // The decimal place maximum has been hit.  Only do this if the "entire" mask isn't selected.
          var selectedChars = val.substring(self.originalPos.begin, self.originalPos.end);
          if (selectedChars.length < val.length && postDecSlice.length >= postDecMask.length) {
            self.resetStorage();
            return self.killEvent(e);
          }

          // Test the correct pattern character against the typed character
          match = self.testCharAgainstRegex(typedChar, patternChar);
          if (!match) {
            self.resetStorage();
            return self.killEvent(e);
          }

          // The character belongs in the post-decimal portion of the mask.  Add it and move on.
          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // The decimal point is not currently in the portion of the string we're working with.
        var patternHasDecimal = self.settings.pattern.length !== self.settings.pattern.replace(/\./g, '').length;

        // Check the character to see if it's a decimal
        if (self.isCharacterDecimal(typedChar)) {
          // Don't allow the decimal to be added if the pattern doesn't contain one.
          if (!patternHasDecimal) {
            self.resetStorage();
            return self.killEvent(e);
          }
          if (valHasDecimal) {
            var caretSlice = val.substring(self.originalPos.begin, self.originalPos.end),
              caretSliceHasDecimal = caretSlice.length !== caretSlice.replace(/\./g, '').length;
            if (caretSliceHasDecimal) {
              if (caretSlice.length === val.length) {
                self.buffer += '0';
              }
              self.buffer += typedChar;
              self.writeInput();
            }
            self.resetStorage();
            return self.killEvent(e);
          }

          // The decimal is OK to add to the string.
          // if the current input is empty or if the caret position is at the beginning, add a leading zero
          if (val.length === 0 || self.originalPos.begin === 0) {
            self.buffer += '0';
          }
          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If the new pattern char is the decimal, add it.
        if (self.isCharacterDecimal(patternChar)) {
          if (!valHasDecimal) {
            self.buffer += patternChar;
          }
          // Test the next character in the mask to see
          patternChar = self.getCharacter('next', trueMaskIndex);
          match = self.testCharAgainstRegex(typedChar, patternChar);
          if (match) {
            self.buffer += typedChar;
          }
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // Test to see if the character is the negative symbol
        if (typedChar === '-') {
          if (!self.settings.negative || self.originalPos.begin > 0) {
            self.resetStorage();
            return self.killEvent(e);
          }

          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        var inputParts = val.split('.'),
          inputWithoutCommas = inputParts[0].replace(/,/g, ''),
          inputWithoutOperators = inputWithoutCommas.replace(/-/g, ''),
          numInputInts = inputWithoutOperators.length;

        // Actually test the typed character against the correct pattern character.
        match = self.testCharAgainstRegex(typedChar, patternChar);
        if (!match) {
          if (self.settings.negative && self.testCharAgainstRegex(typedChar, '~')) {
            // Let it go
          } else {
            self.resetStorage();
            return self.killEvent(e);
          }
        }

        // Is the "integer" portion of the mask filled?
        if (numInputInts >= numMaskInts) {
          // Add the decimal if the value doesn't already have it
          self.buffer += !valHasDecimal && patternHasDecimal ? '.' + typedChar : typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // Add the character to the "integer" part of the mask
        // Get the current value of the pre-decimal mask, strip out commas, add them back in the
        // Appropriate spots, and move the caret position appropriately.
        self.buffer += typedChar;
        self.writeInput();
        self.resetStorage();
        return self.killEvent(e);
      },

      // Processes the pattern string and returns an object that contains that string's sections of matchable patterns
      // and its unmatchable literals.
      getPatternParts: function() {
        var self = this,
          defKeys = Object.keys(this.settings.definitions),
          patternEditableParts = [],
          patternLiteralParts = [],
          patternStartsWithLiteral = false,
          i = 0,
          regexString = '',
          regexObj;

        // Build the string of "editable" matches dynamically from settings,
        // and match it against the incoming pattern to determine each editable group.
        $.each(defKeys, function(i, def) {
          regexString += def;
        });
        regexString = '[' + regexString + ']+';
        regexObj = new RegExp(regexString, 'g');
        patternEditableParts = self.settings.pattern.match(regexObj) || [];

        // check for literal characters at the beginning of the string before the first matchable pattern
        if (patternEditableParts[0] && self.settings.pattern.substring(0, 1) !== patternEditableParts[0].substring(0, 1)) {
          patternLiteralParts.push( self.settings.pattern.substring( 0, self.settings.pattern.indexOf( patternEditableParts[0] )));
          patternStartsWithLiteral = true;
        }

        // set a starting index for our literal checking... may not be 0 if there were literals before the first match
        var prevLiteralEndIndex = (patternLiteralParts && patternLiteralParts[0]) ? (self.settings.pattern.indexOf(patternLiteralParts[0]) + patternLiteralParts[0].length) : 0;

        // get all sets of literal characters in the pattern and store them
        while (i < patternEditableParts.length) {
          // start cutting the string here
          var currLiteralStartIndex = prevLiteralEndIndex + patternEditableParts[i].length,
            // get a fresh cut of the pattern minus the parts we've already dealt with
            nextCut = self.settings.pattern.substring(currLiteralStartIndex, self.settings.pattern.length),
            cutChars = self.settings.pattern.length - nextCut.length,
            // finish cutting the string at the end of the next piece of editable pattern OR the end of the pattern
            currLiteralEndIndex = cutChars + (patternEditableParts[i+1] ? nextCut.indexOf(patternEditableParts[i+1]) : nextCut.length),
            // should contain the next literal
            currLiteral = self.settings.pattern.substring(currLiteralStartIndex, currLiteralEndIndex);
          if (currLiteral !== '') {
            patternLiteralParts.push(currLiteral);
          }
          prevLiteralEndIndex = currLiteralEndIndex;
          i++;
        }

        // build an array that contains one of each character in the literals sections for testing
        var allLiterals = '';
        for (var a = 0; a < patternLiteralParts.length; a++) {
          allLiterals += patternLiteralParts[a];
        }
        var containedLiterals = self.removeDuplicates(allLiterals);

        var allEditables = '';
        for (var b = 0; b < patternEditableParts.length; b++) {
          allEditables += patternEditableParts[b];
        }
        var containedEditables = self.removeDuplicates(allEditables);

        return {
          editable: patternEditableParts,
          literal: patternLiteralParts,
          allLiterals: allLiterals,
          allEditables: allEditables,
          containedLiterals: containedLiterals,
          containedEditables: containedEditables,
          startsWithLiteral: patternStartsWithLiteral
        };
      },

      // Processes the current input value against the pre-processed mask, and returns an array containing the values
      // inside of each editable piece of the group pattern.
      analyzeInput: function(inputSlice) {
        var self = this,
          val = inputSlice !== undefined ? inputSlice : self.element.val(),
          currentMaskPartIsLiteral = false,
          editables = self.maskParts.editable,
          literals = self.maskParts.literal,
          totalMaskParts = editables.length + literals.length,
          editableParts = [],
          literalParts = [],
          valFromLastIndex = '',
          allEditables = '',
          allLiterals = '',
          nextLiteralIndex = 0,
          nextEditableIndex = 0,
          editablePart = '',
          literalPart = '',
          valIndex = 0,
          editableCount = 0,
          literalCount = 0,
          i = 0,
          a = 0;

        // More literals than editables means that there is a literal pattern BEFORE the first editable pattern.
        if (self.maskParts.startsWithLiteral) {
          currentMaskPartIsLiteral = true;
        }

        // Loop through all parts, and retrieve the values inside the editable parts.
        for (i; i < totalMaskParts; i++) {
          if (currentMaskPartIsLiteral) {
            valFromLastIndex = val.substring(valIndex, val.length);
            nextEditableIndex = valIndex + valFromLastIndex.length;
            literalPart = '';

            // find next literal character and grab its index.
            for (a = 0; a < valFromLastIndex.length; a++) {
              if ($.inArray(valFromLastIndex[a], self.maskParts.containedLiterals) === -1) {
                nextEditableIndex = valIndex + a;
                break;
              }
            }

            literalPart = val.substring(valIndex, nextEditableIndex);
            if (literalPart.length > 0) {
              literalParts.push(literalPart);
            }

            allLiterals += literalPart;
            valIndex = valIndex + literalPart.length;
            currentMaskPartIsLiteral = false;
            literalCount++;
          } else {
            valFromLastIndex = val.substring(valIndex, val.length);
            nextLiteralIndex = valIndex + valFromLastIndex.length;
            editablePart = '';

            // find next literal character and grab its index.
            for (a = 0; a < valFromLastIndex.length; a++) {
              if ($.inArray(valFromLastIndex[a], self.maskParts.containedLiterals) !== -1) {
                nextLiteralIndex = valIndex + a;
                break;
              }
            }

            editablePart = val.substring(valIndex, nextLiteralIndex);
            if (editablePart.length > 0) {
              editableParts.push(editablePart);
            }

            allEditables += editablePart;
            valIndex = valIndex + editablePart.length;
            currentMaskPartIsLiteral = true;
            editableCount++;
          }
        }

        // make sure there is at least one empty entry in the array.
        if (editableParts.length === 0) {
          editableParts.push('');
        }

        return {
          editables: editableParts,
          allEditables: allEditables,
          literals: literalParts,
          allLiterals: allLiterals
        };
      },

      // Returns a reconstructed pattern based on the parts dissected from the getPatternParts() method.
      // Used for testing and sanity-checking.
      buildPatternFromParts: function() {
        var parts = this.getPatternParts(),
          pattern = '',
          literalCount = 0,
          editableCount = 0;

        // there is a literal BEFORE and AFTER the first match.
        if (parts.startsWithLiteral) {
          pattern += parts.literal[0];
          literalCount++;
        }
        // there are no literals BEFORE the first match, but there is a literal AFTER the last match.
        if (parts.literal === parts.editable) {}
        while (editableCount < parts.editable.length) {
          pattern += parts.editable[editableCount];
          if (parts.literal[literalCount]) {
            pattern += parts.literal[literalCount];
          }
          editableCount++;
          literalCount++;
        }

        return pattern;
      },

      // takes a string of character literals and returns an array containing each unique literal found.
      removeDuplicates: function(string) {
        var unique = [];
        for (var i = 0; i < string.length; i++) {
          if ($.inArray(string[i], unique) === -1) {
            unique.push(string[i]);
          }
        }
        return unique;
      },

      processMask: function(typedChar, e) {
        var self = this,
          maskEditables = self.maskParts.editable,
          maskLiterals = self.maskParts.literal,
          match,
          i = 0;

        self.originalPos = self.caret();
        self.currentMaskBeginIndex = self.currentMaskBeginIndex || self.originalPos.begin;

        var val = self.element.val().substring(0, self.originalPos.begin),
          input = self.analyzeInput(val);

        // If the input is full, don't continue.
        if (self.originalPos.begin === self.originalPos.end && input.allEditables.length >= self.maskParts.allEditables.length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // don't continue at all if the character typed isn't a valid editable or literal in this pattern
        for (var b = 0; b < self.maskParts.containedEditables.length; b++) {
          match = self.testCharAgainstRegex(typedChar, self.maskParts.containedEditables[b]);
          if (match) {
            break;
          }
        }
        if (!match && $.inArray(typedChar, self.maskParts.containedLiterals) === -1) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // "i" increments the literal section checks by one.  This is necessary if you have a literal pattern group
        // starting the pattern.
        i = 0;
        if (self.maskParts.startsWithLiteral) {
          i = i + 1;
        }


        // Fail out if we try to type too many characters
        var currentSection = (input.editables.length - 1) > 0 ? input.editables.length - 1 : 0;
        if (input.editables[currentSection].length > maskEditables[currentSection].length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // Constant boolean for checking on literals (used by the two checks below)
        var typedLiteralsAreValid = (maskLiterals[currentSection+i] !== undefined) &&
          $.inArray(typedChar, self.maskParts.containedLiterals) !== -1 &&
          !(input.literals[currentSection+i]);

        // If the character typed is a literal, allow it to go through if there is still a section of unmatched literals
        // and there has been at least one editable character entered in this section.  This only works if the flag
        // 'self.settings.groupComplete' is set to 'false' (generally used for dates).
        if (typedLiteralsAreValid &&
          !self.settings.groupComplete &&
          input.editables[currentSection].length > 0) {

          self.checkSectionForLiterals(e, typedChar, maskLiterals[currentSection+i]);
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If 'self.settings.groupComplete' is true, but all characters for this particular group have already been entered,
        // Allow a typed literal character to pass
        if (typedLiteralsAreValid &&
          self.settings.groupComplete &&
          input.editables[currentSection].length === maskEditables[currentSection].length) {

          self.checkSectionForLiterals(e, typedChar, maskLiterals[currentSection+i]);
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If the "literals" are shifted forward due to the mask beginning with a literal pattern instead of an
        // editable pattern, automatically append that literal character at this point, since it hasn't been typed
        if (i > 0 && currentSection === 0 && !(input.literals[0])) {
          self.buffer += maskLiterals[0];
          if ($.inArray(typedChar, self.maskParts.containedLiterals) !== -1) {
            self.writeInput();
            self.resetStorage();
            return self.killEvent(e);
          }
        }

        // Define the section, as well as the correct pattern character to match against.
        var section = input.editables[currentSection] || '',
          currVal,
          patternChar,
          remainder;

        if (section.length < maskEditables[currentSection].length) {

          patternChar = maskEditables[currentSection].substring(input.editables[currentSection].length, (input.editables[currentSection].length + 1));

          // If we're typing inside of an existing literal pattern, this editable pattern has been pre-maturely completed
          // already, and we need to complete this literal pattern, while checking the match against the next editable group
          if (input.literals[currentSection+i] && maskLiterals[currentSection+i] !== input.literals[currentSection+i]) {
            currVal = self.element.val();
            remainder = currVal.substring(self.originalPos.begin, currVal.length);
            val = val.substring(0, (val.length - input.literals[currentSection+i].length));
            self.caret(self.originalPos.begin - input.literals[currentSection+i].length);
            self.originalPos = self.caret();
            self.element.val(val + remainder);
            self.buffer += maskLiterals[currentSection+i];
            patternChar = maskEditables[currentSection+1].substring(0, 1);
          }

          match = self.testCharAgainstRegex(typedChar, patternChar);

          // Simply add the character if its a match
          if ($.inArray(typedChar, self.maskParts.containedLiterals) === -1 && match) {
            self.buffer += typedChar;
            self.writeInput();
          }
        } else if (section.length === maskEditables[currentSection].length) {
          // Check that conditions are right for the next set of literal characters to be added
          if (maskEditables[currentSection+1] &&
              maskLiterals[currentSection+i]) {

            // check to make sure that the existing literals in the set are correctly formed,
            // and fix them if they aren't.
            if (input.literals[currentSection+i] && maskLiterals[currentSection+i] !== input.literals[currentSection+i]) {
              currVal = self.element.val();
              remainder = currVal.substring(self.originalPos.begin, currVal.length);
              val = val.substring(0, (val.length - input.literals[currentSection+i].length));
              self.caret(self.originalPos.begin - input.literals[currentSection+i].length);
              self.originalPos = self.caret();
              self.element.val(val + remainder);
              self.buffer += maskLiterals[currentSection+i];
            }

            // add the mask literals to the beginning of the buffer if they are not already there
            if (!input.literals[currentSection+i]) {
              self.buffer += maskLiterals[currentSection+i];
            }

            patternChar = maskEditables[currentSection+1].substring(0, 1);
            match = self.testCharAgainstRegex(typedChar, patternChar);

            // add the typed character if it's valid
            if ($.inArray(typedChar, self.maskParts.containedLiterals) === -1 && match) {
              self.buffer += typedChar;
            }
          } else {
            // We've technically completed the pattern, but the pattern may be shorter if each group isn't
            // 'complete'.  This section checks to see if we have leftover characters at the end of the input
            // and removes them.
            currVal = self.element.val();
            remainder = currVal.substring(self.originalPos.begin, currVal.length);

            if (remainder.length > 0) {
              self.element.val(currVal.substring(0, self.originalPos.begin));
            }
          }

          if (self.buffer.length > 0) {
            self.writeInput();
          }
        }

        self.resetStorage();
        return self.killEvent(e);
      },

      checkSectionForLiterals: function(e, typedChar, section) {
        for (var a = 0; a < section.length; a++) {
          if (typedChar === section[a]) {
            this.buffer += section;
            break;
          }
        }
      },

      // Takes an entire string of characters and runs each character against the processMask()
      // method until it's complete.
      processStringAgainstMask: function(string, originalEvent) {
        if (this.element.is(':hidden')) {
          return this;
        }

        switch(this.settings.mode) {
          case 'number':
            if (!this.originalPos) {
              this.originalPos = this.caret();
            }
            this.buffer = string;
            this.writeInput();
            this.resetStorage();
            break;
          default:
            var charArray = string.split('');
            for(var i = 0; i < charArray.length; i++) {
              var patternChar = this.getCharacter();
              this.processMask(charArray[i], patternChar, originalEvent);
            }
            break;
        }

        return this;
      },

      /**
       * Re-masks the current contents of the field.
       * @param {Boolean} remaskingOnBlur  &nbsp;-&nbsp; Internal switch.
       * @returns {Object}
       **/
      remask: function(remaskingOnBlur) {
        if (!this.originalPos) {
          if (remaskingOnBlur) {
            this.originalPos = { begin: 0, end: this.element.val().length };
          } else {
            this.originalPos = this.caret();
          }
        }
        this.writeInput(true);
        this.resetStorage();

        return this;
      },

      // Takes a character from the pattern string in Settings, gets the corresponding Regex string
      // from the definitions array in Settings, and tests the character against the Regex.
      testCharAgainstRegex: function(typedChar, patternChar) {
        var regex = this.settings.definitions[patternChar];
        return !regex ? false : regex.test(typedChar);
      },

      // Replaces all but the first occurence of a regex with nothing.
      replaceAllButFirst: function(regex, textString, replacement) {
        if (!replacement) {
          replacement = '';
        }
        var count = 0;
        textString = textString.replace(regex, function(match) {
          if (count > 0) {
            return replacement;
          }
          return match;
        });
        return textString;
      },

      // Returns the character at the current/next/previous cursor position.
      // If no direction is provided, it defaults to the current position.
      // If an optional index is provided, the cursor position will shift to that index value.
      getCharacter: function(direction, maskIndex) {
        var mask = this.settings.mode === 'number' ? this.settings.pattern.replace(/,/g, '') : this.settings.pattern,
          index = maskIndex ? maskIndex : this.caret().begin;
        direction = this.evaluateDirecton(direction);

        switch(direction) {
          case 'next':
            return mask.substring(index + 1, index + 2);
          case 'prev':
            return mask.substring(index - 1, index);
          default: // current
            return mask.substring(index, index + 1);
        }
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        if (this.settings.showCurrency) {
          this.element.parent('.field').removeClass('currency').attr('data-currency-symbol', '');
          this.element.prev('label').find('.currency').remove();
        }
        this.element.off('updated.mask keydown.mask keypress.mask keyup.mask focus.mask blur.mask ' + this.getPasteEvent());

        this.element.removeClass('is-mask').removeClass('is-number-mask');

        return this;
      },

      /**
       * Tear Down and destroy events
       **/
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);

        return this;
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Mask(this, settings));
      }
    });
  };


  $.fn.multiselect = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'multiselect',
        defaults = {
          filterMode: 'contains',
          maxSelected: undefined,
          moveSelected: 'all',
          showEmptyGroupHeaders: false,
          showSelectAll: false,
          source: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
    * The MultiSelect Component allows selecting multiple items from a list
    *
    * @class MultiSelect
    * @param {String} filterMode  &nbsp;-&nbsp; The search mode to use, can be 'contains' or 'startsWith'
    * @param {Number} maxSelected  &nbsp;-&nbsp; The max number of items which can be selected
    * @param {String} moveSelected  &nbsp;-&nbsp;  Move selected options in each group to just underneath their corresponding group headers.
    * @param {Boolean} showEmptyGroupHeaders  &nbsp;-&nbsp; If true groups with no items will still show the empty group header.
    * @param {Boolean} showSelectAll  &nbsp;-&nbsp; Show the select all text/option.
    * @param {Function} source  &nbsp;-&nbsp; The calback for ajax.
    *
    */
    function MultiSelect(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    MultiSelect.prototype = {

      init: function() {
        this.build();
      },

      build: function() {
        var ddOpts = {
            closeOnSelect: false,
            empty: true,
            moveSelected: 'all',
            multiple: true
          };

        if (this.settings.filterMode) {
          ddOpts.filterMode = this.settings.filterMode;
        }

        if (this.settings.source) {
          ddOpts.source = this.settings.source;
        }

        if (this.settings.maxSelected) {
          ddOpts.maxSelected = this.settings.maxSelected;
        }

        if (this.settings.moveSelected) {
          ddOpts.moveSelected = this.settings.moveSelected;
        }

        if (this.settings.showEmptyGroupHeaders) {
          ddOpts.showEmptyGroupHeaders = this.settings.showEmptyGroupHeaders;
        }

        if (this.settings.showSelectAll) {
          ddOpts.showSelectAll = this.settings.showSelectAll;
        }

        this.element.dropdown(ddOpts);
        this.dropdown = this.element.data('dropdown');

        return this;
      },

      /**
      * Enable the multiselect input
      */
      enable: function() {
        this.dropdown.enable();
      },

      /**
      * Disable the multiselect input
      */
      disable: function() {
        this.dropdown.disable();
      },

      /**
      * Trigger a rebuild due to settings change
      */
      updated: function() {
        this.build();
      },

      /**
      * Remove added markup and events
      */
      destroy: function() {
        this.dropdown.destroy();
        this.element.off();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new MultiSelect(this, settings));
      }
    });
  };


  $.fn.message = function(options) {

    // Settings and Options
    var pluginName = 'message',
      defaults = {
          title: 'Message Title',
          isError: false,
          message: 'Message Summary',
          width: 'auto',
          buttons: null,
          cssClass: null,
          returnFocus: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Message Component is used to show warning / error messages.
    *
    * @class Message
    * @param {String} title  &nbsp;-&nbsp; Title text or content shown in the message
    * @param {Boolean} isError  &nbsp;-&nbsp; If true, will show title styled as an error with an error icon
    * @param {String} message  &nbsp;-&nbsp; The message content or text
    * @param {Number} width  &nbsp;-&nbsp; Pass a specific with or defaults to auto
    * @param {Object} buttons  &nbsp;-&nbsp; Array of buttons to add to the message (see modal examples as well)
    * @param {String} cssClass  &nbsp;-&nbsp; Extra Class to add to the dialog for customization.
    * @param {String} returnFocus  &nbsp;-&nbsp; JQuery Element selector to focus on return
    *
    */
    function Message(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Message.prototype = {

      init: function() {
        var self = this,
          content;

        //Create the Markup
        this.message = $('<div class="modal message"></div>');
        this.messageContent = $('<div class="modal-content"></div>');
        this.title = $('<h1 class="modal-title" id="message-title">' + settings.title + '</h1>').appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
        this.content = $('<div class="modal-body"><p class="message" id="message-text">'+ settings.message +'</p></div>').appendTo(this.messageContent);

        //Append The Content if Passed in
        if (!this.element.is('body')) {
          content = this.element;
          this.content.empty().append(content.show());
        }

        this.message.append(this.messageContent).appendTo('body');
        this.message.modal({trigger: 'immediate', buttons: settings.buttons,
          resizable: settings.resizable, close: settings.close, isAlert: true});

        //Adjust Width if Set as a Setting
        if (settings.width !== 'auto') {
          this.content.closest('.modal')[0].style.maxWidth = 'none';
          this.content.closest('.modal')[0].style.width = settings.width + (/(px|%)/i.test(settings.width + '') ? '' : 'px');
        }

        if (settings.cssClass) {
          this.message.addClass(settings.cssClass);
        }

        //Setup the destroy event to fire on close.  Needs to fire after the "close" event on the modal.
        this.message.on('beforeclose.message', function () {
          var ok = self.element.triggerHandler('beforeclose');
          return ok;
        }).on('beforeopen.message', function () {
          var ok = self.element.triggerHandler('beforeopen');
          return ok;
        }).on('open.message', function () {
          self.element.trigger('open');
        }).on('afterclose.message', function() {
          self.destroy();
          if (settings.returnFocus) {
            settings.returnFocus.focus();
          }

          $(document).off('keypress.message keydown.message');
        });

        $(document).on('keypress.message keydown.message', function (e) {
          var keyCode = e.which || e.keyCode;

          if (keyCode === 27) {
            setTimeout(function () {
              var modalData = self.message.data('modal');
              if (modalData !== undefined) {
                modalData.close();
              }
            }, 0);
          }
        });

        if (settings.isError) {
          this.title.addClass('is-error').prepend($.createIconElement('error'));
        } else {
          this.title.removeClass('is-error').find('svg').remove();
        }
      },

      /**
       * Tear Down and destroy events. However the message will destroy itself on close.
       **/
      destroy: function() {
        var modalData = this.message.data('modal');
        if (modalData !== undefined) {
          modalData.destroy();
        }

        this.message
          .off('beforeclose.message beforeopen.message open.message afterclose.message')
          .remove();
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      new Message(this, settings);
    });
  };


  $.fn.modal = function(options) {

    // Settings and Options
    var pluginName = 'modal',
      defaults = {
        trigger: 'click', //Supports click, immediate
        buttons: null,  //Pass in the Buttons
        isAlert: false, //Adds alertdialog role
        content: null, //Ability to pass in dialog html content
        cssClass: null,  //Append a css class to top level
        autoFocus: true,
        id: null,  //Optionally tag a dialog with an id
        frameHeight: 180, //Extra Height
        frameWidth: 46 //Extra Width
      },
      settings = $.extend({}, defaults, options);

    /**
     * Responsive and Accessible Modal Control
     * @constructor
     * @param {Object} element
     */
    function Modal(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
      this.reStructure();
    }

    // Actual Plugin Code
    Modal.prototype = {
      init: function() {
        var self = this;

        // Used for tracking events tied to the Window object
        this.id = (parseInt($('.modal').length, 10)+1);
        this.trigger = $('button[data-modal="' + this.element.attr('id') + '"]');  //Find the button with same dialog ID
        this.overlay = $('<div class="overlay"></div>');
        this.oldActive = this.trigger;

        if (this.settings.trigger === 'click') {
          this.trigger.on('click.modal', function() {
            self.open();
          });
        }

        if (this.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.open();
          }, 1);
        }

        self.isCancelled = false;

        //ensure is appended to body for new dom tree
        if (this.settings.content) {

          this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
          this.appendContent();
          setTimeout(function () {
            self.open();
          }, 1);
          return;
        }

        self.addButtons(this.settings.buttons);
        this.element.appendTo('body');
        this.element[0].style.display = 'none';
      },

      appendContent: function () {
        var isAppended = false;

        this.element = $(
          '<div class="modal">' +
            '<div class="modal-content">'+
              '<div class="modal-header"><h1 class="modal-title">'+ this.settings.title +'</h1></div>' +
              '<div class="modal-body-wrapper">'+
                '<div class="modal-body"></div>'+
              '</div>'+
            '</div>'+
          '</div>');

        if (this.settings.id) {
          this.element.attr('id', this.settings.id);
        }

        if ($(this.settings.content).is('.modal')) {
          this.element = $(this.settings.content);
        } else if (this.settings.content && this.settings.content.length > 0) {

          if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
            isAppended = true;
            this.element = this.settings.content.closest('.modal');
          } else {
            var self = this,
              body = self.element.find('.modal-body');

            body.append(self.settings.content);
            Soho.utils.fixSVGIcons(body);
          }

          if (this.settings.content instanceof jQuery){
            this.settings.content.show();
          }
        }

        if (!isAppended) {
          this.element.appendTo('body');
        }

        if (this.settings.cssClass) {
          this.element.addClass(this.settings.cssClass);
        }

        if (this.settings.title) {
          this.element.find('.modal-title').text(this.settings.title);
        }

        if (!isAppended) {
          this.addButtons(this.settings.buttons);
        }
      },

      reStructure: function() {
        var body = $('.modal-body', this.element),
          hr = $('hr:first-child', body),
          buttonset = $('.modal-buttonset', this.element);

        if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
          body.wrap('<div class="modal-body-wrapper"></div>');
        }
        if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
          hr.insertAfter(this.element.find('.modal-header'));
        }
        if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
          buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
        }

      },

      disableSubmit: function () {
        var body = this.element,
          fields = body.find('[data-validate]:visible'),
          inlineBtns = body.find('.modal-buttonset button'),
          primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');

        if (fields.length > 0) {
          primaryButton.removeAttr('disabled');

          var allValid = true;
          fields.each(function () {

            var field = $(this);
            if (field.closest('.datagrid-filter-wrapper').length > 0) {
              return;
            }

            var isVisible = field[0].offsetParent !== null;

            if (field.is('.required')) {
              if (isVisible && !field.val()) {
                allValid = false;
              }
            } else {
              field.checkValidation();
              if (isVisible && !field.isValid()) {
                allValid = false;
              }

            }

            if (allValid) {
              primaryButton.removeAttr('disabled');
            }
          });

          if (!allValid && !primaryButton.is(':disabled')) {
             primaryButton.attr('disabled', 'true');
          }
        }

      },

      addButtons: function(buttons) {
        var self = this,
          body = this.element.find('.modal-body'),
          bodywrapper = body.parent(),
          btnWidth = 100,
          isPanel = false,
          buttonset;

        this.modalButtons = buttons;

        if (!buttons) {
          var inlineBtns = this.element.find('.modal-buttonset button');
          // Buttons in markup
          btnWidth = 100/inlineBtns.length;
          for (var i = 0, l = inlineBtns.length; i < l; i++) {
            inlineBtns[i].style.width = btnWidth + '%';
          }
          inlineBtns.button();
          inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on('click.modal', function (e) {
            if ($(e.target).is('.btn-cancel')) {
              self.isCancelled = true;
            }
            self.close();
          });
          return;
        }

        if (this.element.is('.contextual-action-panel')) {
          isPanel = true;
          // construct the toolbar markup if a toolbar isn't found
          buttonset = this.element.find('.buttonset');
          if (!buttonset.length) {
            var toolbar = this.element.find('.toolbar');
            if (!toolbar.length) {
              $('<div class="toolbar"></div>').appendTo(this.element.find('.modal-header'));
            }
            buttonset = $('<div class="buttonset"></div>').appendTo(this.element.find('.toolbar'));
          }
        } else {
          buttonset = this.element.find('.modal-buttonset');
          if (!buttonset.length) {
            buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
          }
        }

        btnWidth = 100/buttons.length;

        if (buttons) {
          buttonset.empty();
        }

        $.each(buttons, function (name, props) {
          var btn = $('<button type="button"></button>');
          btn.text(props.text);

          if (props.cssClass === 'separator') {
            btn = $('<div class="separator"></div>');
          }

          if (props.cssClass) {
            btn.attr('class', props.cssClass);
          } else {
            if (props.isDefault) {
              btn.addClass('btn-modal-primary');
            } else {
              btn.addClass('btn-modal');
            }
          }

          if (props.validate !== undefined && !props.validate) {
            btn.addClass('no-validation');
          }

          var attrs = {},
            attrTypes = ['id', 'name', 'text'];

          for (var i = 0; i < attrTypes.length; i++) {
            if (props[attrTypes[i]]) {
              attrs[attrTypes[i]] = props[attrTypes[i]];
            }
          }

          if (props.type === 'input') {
            var label = $('<label class="audible" for="filter">' + props.text + '</label>'),
              input = $('<input class="searchfield">').attr(attrs);

            buttonset.append(label, input);
            return;
          }

          if (props.icon && props.icon.charAt(0) === '#') {
            btn.html('<span>' + btn.text() + '</span>');
            $.createIconElement({
              classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
              icon: props.icon.substr('#icon-'.length)
            }).prependTo(btn);
          }

          if (props.id) {
            btn.attr('id', props.id);
          }

          btn.on('click.modal', function(e) {
            if (props.click) {
              props.click.apply(self.element[0], [e, self]);
              return;
            }
            self.close();
          });

          if (!isPanel) {
            btn[0].style.width = btnWidth + '%';
          }

          btn.button();
          buttonset.append(btn);

        });

      },

      sizeInner: function () {
        var messageArea;
        messageArea = this.element.find('.detailed-message');
        //Set a max width
        var h = $(window).height() - messageArea.offset().top - 150;
        messageArea[0].style.maxHeight = h + 'px';
        messageArea[0].style.overflow = 'auto';
        messageArea[0].style.width = messageArea.width() + 'px';
      },

      open: function () {
        var self = this, messageArea,
          elemCanOpen = true;

        if (!this.trigger || this.trigger.length ===0) {
          this.oldActive = $(':focus');  //Save and restore focus for A11Y
        }

        this.element.after(this.overlay);
        if (this.element && !this.element.parent().hasClass('modal-wrapper')) {
          this.element.wrap('<div class="modal-page-container"><div class="modal-wrapper"></div>');
        }
        this.root = this.element.closest('.modal-page-container');

        messageArea = self.element.find('.detailed-message');
        if (messageArea.length === 1) {
          $('body').on('resize.modal-' + this.id, function () {
            self.sizeInner();
          });
          self.sizeInner();
        }

        elemCanOpen = this.element.triggerHandler('beforeopen');
        self.isCancelled = false;

        if (elemCanOpen === false) {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          return false;
        }

        //Look for other nested dialogs and adjust the zindex.
        $('.modal').each(function (i) {
          var modal = $(this);
          this.style.zIndex = (1020 + (i + 1)).toString();

          if (modal.data('modal') && modal.data('modal').overlay) {
            modal.data('modal').overlay[0].style.zIndex = (1020 + i).toString();
          }

          if (!modal.data('modal')) {
            var overlay = modal.closest('.modal-page-container').next('.overlay');
            if (overlay && overlay[0]) {
              overlay[0].style.zIndex = (1020 + i).toString();
            }
          }
        });

        $('body > *').not(this.element).not('.modal, .overlay, .modal-page-container').attr('aria-hidden', 'true');

        // Ensure aria-labelled by points to the id
        if (this.settings.isAlert) {
          this.element.attr('aria-labeledby', 'message-title');
          this.element.attr('aria-describedby', 'message-text');
        } else {
          var h1 = this.element.find('h1:first'),
            id = h1.attr('id');

          if (!id) {
            id = (this.element.attr('id') ? this.element.attr('id') : 'h1')  + '-title';
            h1.attr('id', id);
          }

          var body = this.element.find('.modal-body'),
            descById = (this.element.attr('id') ? this.element.attr('id') : 'message') + '-text';

          this.element.attr('aria-labeledby', id);

          //Contextual Action Panel Case - Has a toolbar
          if (this.element.find('.toolbar .title').length) {
            this.element.find('.toolbar .title').attr('id', descById);
            this.element.attr('aria-describedby', descById);
          } else {
            body.attr('id', descById);
            this.element.attr('aria-describedby', descById);
          }

        }

        this.mainContent = $('body').children('.scrollable-container');
        if (!this.mainContent.length) {
          this.mainContent = $('body');
        }

        this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
        this.mainContent.addClass('no-scroll');

        $('body').on('resize.modal-' + this.id, function() {
          self.resize();
        });

        //Center
        this.root[0].style.display = '';
        this.element[0].style.display = '';

        setTimeout(function() {
          self.resize();
          self.element.addClass('is-visible').attr('role', (self.settings.isAlert ? 'alertdialog' : 'dialog'));
          self.root.attr('aria-hidden', 'false');
          self.overlay.attr('aria-hidden', 'true');
          self.element.attr('aria-modal', 'true'); //This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
        }, 1);

        // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a chance to be established
        // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
        // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements
        $('body').addClass('modal-engaged');

        //Handle Default button.
        $(this.element).on('keypress.modal', function (e) {
          var target = $(e.target);

          if (target.is('.searchfield') || target.is('textarea') || target.is(':button') || target.is('.dropdown') || target.closest('.tab-list').length) {
            return;
          }

          if (e.which === 13 && self.isOnTop() &&
              !target.closest('form').find(':submit').length &&
              self.element.find('.btn-modal-primary:enabled').length) {

            e.stopPropagation();
            e.preventDefault();
            self.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        });

        // Override this page's skip-link default functionality to instead focus the top
        // of this element if it's clicked.
        $('.skip-link').on('focus.modal', function(e) {
          e.preventDefault();
          self.getTabbableElements().first.focus();
        });

        function focusElement() {
          var focusElem = self.element.find(':focusable').not('.modal-header .searchfield').first();
          self.keepFocus();
          self.element.trigger('open', [self]);

          if (focusElem.length === 0) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('button') && !focusElem.is(':disabled')) {
            focusElem.addClass('hide-focus');
          }

          if (!self.settings.autoFocus) {
            return;
          }

          // If the selected element is a tab, actually make sure it's the "selected" tab.
          var selected, tabParent;
          if (focusElem.is('.tab:not(.is-selected) a')) {
            tabParent = focusElem.closest('.tab-container');
            selected = tabParent.find('.is-selected');
            if (selected.length) {
              focusElem = selected;
              tabParent.data('tabs').select(selected.children('a').attr('href'));
              return;
            }
          }

          // Otherwise, just focus
          focusElem.focus();

        }

        var pagerElem = self.element.find('.paginated');
        pagerElem.on('afterpaging', function () {
          self.resize();
        });

        setTimeout(function () {
          self.disableSubmit();
        }, 10);

        var fields = this.element.find('[data-validate]');
        fields.removeClass('disable-validation');

        setTimeout(function () {
          focusElement();
        }, 200);

        setTimeout(function () {
          self.element.trigger('afteropen');
        }, 300);

      },

      resize: function() {
        var calcHeight = ($(window).height()* 0.9)-this.settings.frameHeight, //90% -(180 :extra elements-height)
          calcWidth = ($(window).width()* 1)-this.settings.frameWidth;

        var wrapper = this.element.find('.modal-body-wrapper');

        //Remove width for backwards compat
        this.element.find('.modal-contents').css('width', '');

        if (wrapper.length) {
          wrapper[0].style.maxHeight = calcHeight + 'px';
          wrapper[0].style.maxWidth = calcWidth + 'px';
        }

        if (this.element.hasClass('lookup-modal')) {
          var table = this.element.find('.datagrid-body'),
            hasPager = this.element.find('.pager-toolbar'),
            container = table.closest('.datagrid-container');

          calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 60) - (container.next().is('.pager-toolbar') ? 35 : 0);
          table[0].style.maxHeight = calcHeight + (hasPager.length ? -15 : 0) + 'px';
          table[0].style.maxWidth = calcWidth + 'px';
        }

      },

      isOpen: function() {
        return this.element.is('.is-visible');
      },

      isOnTop: function () {
        var max = 0,
          dialog = this.element;

        $('.modal.is-visible').each(function () {
          var zIndex = this.style.zIndex;
          if (max < zIndex) {
            max = zIndex;
          }
        });

        return max === dialog[0].style.zIndex;
      },

      getTabbableElements: function() {
        var allTabbableElements = $(this.element).find('a[href], area[href], input:not([disabled]),' +
          'select:not([disabled]), textarea:not([disabled]),' +
          'button:not([disabled]), iframe, object, embed, *[tabindex],' +
          '*[contenteditable]').filter(':visible');
        return {
          first: allTabbableElements[0],
          last: allTabbableElements[allTabbableElements.length - 1]
        };
      },

      keepFocus: function() {
        var self = this, tabbableElements;

          $(self.element).on('keypress.modal keydown.modal', function (e) {
            var keyCode = e.which || e.keyCode;

            if (keyCode === 27) {
              setTimeout(function () {
                self.close();
              }, 0);
            }

            if (keyCode === 9) {
              tabbableElements = self.getTabbableElements();

              // Move focus to first element that can be tabbed if Shift isn't used
              if (e.target === tabbableElements.last && !e.shiftKey) {
                e.preventDefault();
                tabbableElements.first.focus();
              } else if (e.target === tabbableElements.first && e.shiftKey) {
                e.preventDefault();
                tabbableElements.last.focus();
              }

              self.element.find('#message-title').removeAttr('tabindex');
            }

          });
      },

      close: function (destroy) {
        if (!this.isOpen()) {
          return true;
        }

        var elemCanClose = this.element.triggerHandler('beforeclose'),
          self = this,
          fields = this.element.find('[data-validate]');

        this.root = this.element.closest('.modal-page-container');
        fields.addClass('disable-validation');

        if (elemCanClose === false) {
          return false;
        }

        if (this.mainContent && this.removeNoScroll) {
          this.mainContent.removeClass('no-scroll');
        }
        $('body').off('resize.modal-' + this.id);

        this.element.off('keypress.modal keydown.modal');
        this.element.removeClass('is-visible');

        this.overlay.attr('aria-hidden', 'true');
        if (this.root) {
          this.root.attr('aria-hidden', 'true');
        }

        if ($('.modal-page-container[aria-hidden="false"]').length < 1) {
          $('body').removeClass('modal-engaged');
          $('body > *').not(this.element.closest('.modal-page-container')).removeAttr('aria-hidden');
          $('.overlay').remove();
        }

        //Fire Events
        self.element.trigger('close', self.isCancelled);

        // Restore focus
        if (this.oldActive && $(this.oldActive).is('a:visible, button:visible, input:visible, textarea:visible')) {
          this.oldActive.focus();
          this.oldActive = null;
        } else if (this.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
          this.trigger.focus();
        }

        //close tooltips
        $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

        // remove the event that changed this page's skip-link functionality in the open event.
        $('.skip-link').off('focus.modal');

        setTimeout( function() {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          self.element.trigger('afterclose');

          if (self.settings.trigger === 'immediate' || destroy) {
            self.destroy();
          }
        }, 300); // should match the length of time needed for the overlay to fade out
      },

      // NOTE: Destroy method needs to function as a callback to be cancellable
      destroy: function() {
        var self = this,
          canDestroy = this.element.trigger('beforedestroy');

        if (!canDestroy) {
          return;
        }

        function destroyCallback() {
          if (self.modalButtons) {
            self.element.find('button').off('click.modal');
          }

          if (self.element.find('.detailed-message').length === 1) {
            $('body').off('resize.modal-' + this.id);
          }

          if (self.settings.trigger === 'click') {
            self.trigger.off('click.modal');
          }

          self.element.closest('.modal-page-container').remove();
          $.removeData(self.element[0], 'modal');
        }

        if (!this.isOpen()) {
          destroyCallback();
          return;
        }

        this.element.one('afterclose.modal', function() {
          destroyCallback();
        });

        this.close(true);
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName),
        elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(pluginName);
      }

      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);

        if (settings.trigger === 'immediate') {
          instance.open();
        }
        return;
      }

      instance = $.data(this, pluginName, new Modal(this, settings));
    });
  };


  $.fn.rating = function(options) {

     // Tab Settings and Options
    var pluginName = 'rating',
        defaults = {},
        settings = $.extend({}, defaults, options);

    function Rating(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Rating Code
    Rating.prototype = {
      init: function() {
        this.handleEvents();
        this.allInputs = this.element.find('input');
        this.readonly();
      },
      handleEvents: function () {
        var self = this;

        $('input', self.element).each(function(index) {
          $(this).on('change', function () {
            if (!self.element.hasClass('is-readonly')) {
              self.val(index + 1);
            }
          });
        });
      },
      val: function(value) {
        var i, chkIdx, self = this;
        if (!value) {
          return this.currentValue;
        }

        this.currentValue = parseFloat(value, 10);
        chkIdx = Math.round(this.currentValue);

        for (i = 0; i < this.allInputs.length; i++) {
          var input = $(this.allInputs[i]),
            svgSelector = input.parent().is('.inline') ? 'svg' : 'label';

          if (i < value) {
            input.addClass('is-filled').removeClass('is-half');
          } else {
            input.removeClass('is-filled').removeClass('is-half');
          }

          //Handle Half Star
          input.next(svgSelector).find('svg').changeIcon('star-filled');

          if (i+1 === chkIdx) {
            input.prop('checked', true);
          }

          if (chkIdx !== self.currentValue && i+1 === chkIdx) {
           input.addClass('is-half').next(svgSelector).find('svg').changeIcon('star-half');
          }
        }
        if (chkIdx <= 0) {
          $(this.allInputs[0]).prop('checked', true);
        }

        return this.currentValue;
      },
      readonly: function() {
        var elem = $(this.element);
        if (elem.hasClass('is-readonly')) {
          elem.find('input').attr('disabled','');
        }
      },
      enable: function() {
        var elem = $(this.element);
        elem.removeClass('is-readonly').find('input').removeAttr('disabled');
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Rating(this, settings));
      }
    });
  };


  $.fn.searchfield = function(options) {
    'use strict';

    if (!options) {
      options = {};
    }

    // Settings and Options
    var pluginName = 'searchfield',
        defaults = {
          allResultsCallback: undefined,
          showAllResults: true,
          categories: undefined, // If defined as an array, displays a dropdown containing categories that can be used to filter results.
          categoryMultiselect: false, // If true, creates a multiselectable Categories list
          showCategoryText: false, // If true, will show any available categories that are selected to the left of the Dropdown field.
          source: undefined,
          template: undefined, // Template that can be passed
          clearable: false //Has an X to clear
        },
        settings = $.extend({}, defaults, options);

    /**
     * Searchfield Control
     * @constructor
     * @param {Object} element
     */
    function SearchField(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    SearchField.prototype = {
      /**
       * Initialization Kickoff
       * @returns {this}
       */
      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build().setupEvents();
      },

      /**
       * Builds the markup for this component.
       * @private
       * @returns {this}
       */
      build: function() {
        this.optionsParseBoolean();
        this.label = this.element.prev('label, .label');

        // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
        // Autocomplete settings are fed the same settings as Searchfield
        if (this.settings.source || this.element.attr('data-autocomplete')) {
          this.element.autocomplete(this.settings);
        }
        this.autocomplete = this.element.data('autocomplete');

        //Prevent browser typahead
        this.element.attr('autocomplete','off');

        this.wrapper = this.element.parent('.searchfield-wrapper');
        if (!this.wrapper || !this.wrapper.length) {
          if (this.isInlineLabel) {
            this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
          }
          else {
            this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
          }

          // Label for toolbar-inlined searchfields needs to be inside the wrapper to help with positioning.
          if (this.element.closest('.toolbar').length) {
            this.label.prependTo(this.wrapper);
          }

          var customClasses = ['context', 'alternate'],
            c;
          for (var i = 0; i < customClasses.length; i++) {
            if (this.element.hasClass(customClasses[i])) {
              c = customClasses[i];
              this.wrapper.addClass(c);
              this.element.removeClass(c);
            }
          }
        }

        // Add Icon
        var icon = this.wrapper.find('.icon:not(.icon-dropdown)'),
          insertIconInFront = this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories');

        if (!icon || !icon.length) {
          icon = $.createIconElement('search');
        }

        // Swap icon position to in-front if we have "context/has-categories" CSS class.
        icon[insertIconInFront ? 'insertBefore' : 'insertAfter'](this.element).icon();

        // Change icon to a trigger button if we're dealing with categories
        if (this.hasCategories()) {
          this.wrapper.addClass('has-categories');

          this.button = this.wrapper.find('.btn, .searchfield-category-button');
          if (!this.button.length) {
            this.button = $('<button type="button" class="btn searchfield-category-button"></button>');
          }
          icon.appendTo(this.button);
          icon = this.button;

          this.button.insertBefore(this.element);

          if (this.settings.showCategoryText) {
            this.wrapper.addClass('show-category');
          }

          var ddIcon = icon.find('.icon-dropdown');
          if (!ddIcon.length) {
            ddIcon = $.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }).icon();
          }
          ddIcon.appendTo(icon);

          var popupAPI = this.button.data('popupmenu');
          if (!popupAPI) {
            this.list = this.wrapper.find('ul.popupmenu');
            if (!this.list || !this.list.length) {
              this.list = $('<ul class="popupmenu"></ul>');
            }

            // Handle Single vs Multi-Selectable Lists
            var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
            this.list.addClass(categoryListType);
            var removeListType = 'is-selectable';
            if (!this.settings.categoryMultiselect) {
              removeListType = 'is-multiselectable';
            }
            this.list.removeClass(removeListType);

            this.setCategories(this.settings.categories);

            this.list.insertAfter(this.element);
            this.button.popupmenu({
              menu: this.list,
              offset: {
                y: 10
              }
            });

          } else {
            this.setCategories(this.settings.categories);
          }

          this.setCategoryButtonText();
        }

        // Hoist the 'alternate' CSS class to the wrapper, if applicable
        var isAlternate = this.element.hasClass('alternate');
        this.wrapper[isAlternate ? 'addClass' : 'removeClass']('alternate');

        if (this.settings.clearable) {
          this.element.clearable();
        }

        return this;
      },

      /**
       * Set boolean value if strings
       * @private
       * @returns {undefined}
       */
      optionsParseBoolean: function() {
        var i, l,
          arr = [
            'showAllResults',
            'categoryMultiselect',
            'showCategoryText',
            'clearable'
          ];
        for (i=0,l=arr.length; i<l; i++) {
          this.settings[arr[i]] = this.parseBoolean(this.settings[arr[i]]);
        }
      },

      /**
       * Reveals whether or not categories are active on this searchfield
       * @returns {boolean}
       */
      hasCategories: function() {
        return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
      },

      /**
       * Sets up the event-listening structure for this component instance.
       * @private
       * @returns {this}
       */
      setupEvents: function() {
        var self = this;

        this.element.on('updated.searchfield', function() {
          self.updated();
        }).on('focus.searchfield', function(e) {
          self.handleFocus(e);
        }).on('blur.searchfield', function(e) {
          self.handleBlur(e);
        }).onTouchClick('searchfield', '.searchfield')
        .on('click.searchfield', function(e) {
          self.handleClick(e);
        }).on('keydown.searchfield', function(e) {
          self.handleKeydown(e);
        }).on('beforeopen.searchfield', function(e, menu) { // propagates from Autocomplete's Popupmenu
          self.handlePopupBeforeOpen(e, menu);
        }).on('safe-blur.searchfield listclose.searchfield', function() {
          self.wrapper.removeClass('popup-is-open');
        });

        this.wrapper.on('mouseenter.searchfield', function() {
          $(this).addClass('is-hovered');
        }).on('mouseleave.searchfield', function() {
          $(this).removeClass('is-hovered');
        });

        if (this.hasCategories()) {
          this.button.on('selected.searchfield', function(e, anchor) {
            self.handleCategorySelected(e, anchor);
          }).on('focus.searchfield', function(e) {
            self.handleCategoryFocus(e);
          }).on('blur.searchfield', function(e) {
            self.handleCategoryBlur(e);
          }).on('close.searchfield', function(e) { // Popupmenu Close
            self.handlePopupClose(e);
          });
        }

        // Insert the "view more results" link on the Autocomplete control's "populated" event
        this.element.off('populated.searchfield').on('populated.searchfield', function(e, items) {
          if (items.length > 0) {
            if (self.settings.showAllResults) {
              self.addMoreLink();
            }
          } else {
            self.addNoneLink();
          }
        });

        // Override the 'click' listener created by Autocomplete (which overrides the default Popupmenu method)
        // to act differntly when the More Results link is activated.
        this.element.on('listopen.searchfield', function(e, items) {
          var list = $('#autocomplete-list');

          // Visual indicator class
          self.wrapper.addClass('popup-is-open');

          list.off('click').on('click.autocomplete', 'a', function (e) {
            var a = $(e.currentTarget),
              ret = a.text().trim(),
              isMoreLink = a.hasClass('more-results'),
              isNoneLink = a.hasClass('no-results');

            if (!isMoreLink && !isNoneLink) {
              // Only write text into the field on a regular result pick.
              self.element.attr('aria-activedescendant', a.parent().attr('id'));
            }

            if (isMoreLink) {
              // Trigger callback if one is defined
              var callback = self.settings.allResultsCallback;
              if (callback && typeof callback === 'function') {
                callback(ret);
              }
            }

            if (a.parent().attr('data-value')) {
              for (var i = 0; i < items.length; i++) {
                if (items[i].value.toString() === a.parent().attr('data-value')) {
                  ret = items[i];
                }
              }
            }

            self.element.trigger('selected', [a, ret]);
            self.element.data('popupmenu').close();
            e.preventDefault();
            return false;
          });

          // Override the focus event created by the Autocomplete control to make the more link
          // and no-results link blank out the text inside the input.
          list.find('.more-results, .no-results').off('focus').on('focus.searchfield', function () {
            var anchor = $(this);
            list.find('li').removeClass('is-selected');
            anchor.parent('li').addClass('is-selected');
            self.element.val('');
          });

        });

        return this;
      },

      /**
       * If located inside a toolbar element, setup a timed event that will send a signal to the parent toolbar,
       * telling it to recalculate which buttons are visible. Needs to be done after a CSS animation on the searchfield finishes.
       * @private
       * @returns {undefined}
       */
      recalculateParent: function() {
        var toolbar = this.element.closest('.toolbar');
        if (toolbar.length) {
          // TODO: Bolster this to work with CSS TransitonEnd
          setTimeout(function() {
            toolbar.triggerHandler('recalculate-buttons');
          }, 300);
        }
      },

      /**
       * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing it on blur, sets up
       * an explicit, out-of-bounds click/tap that will serve to close it when the user acts.
       * @private
       * @param {boolean} force - ignore any attempt to return out first
       * @param {boolean} doFocus - focus the searchfield element.
       * @returns {undefined}
       */
      setAsActive: function(force, doFocus) {
        if (!force && this.element.hasClass('active')) {
          return;
        }

        // Activate
        this.element.addClass('active');
        var toolbar = this.element.closest('.toolbar, [class$="-toolbar"]');
        if (toolbar.length) {
          toolbar.addClass('searchfield-active');
        }

        // if Toolbar Searchfield, allow that control to handle adding this class
        if (!this.isToolbarSearchfield()) {
          this.wrapper.addClass('has-focus');
        }

        if (doFocus === true) {
          this.element.focus();
        }

        this.recalculateParent();
      },

      /**
       * Detects whether or not the Searchfield has focus.
       * @returns {boolean}
       */
      hasFocus: function() {
        var active = document.activeElement;

        if ($.contains(this.wrapper[0], active)) {
          return true;
        }

        // Don't close if a category is being selected from a category menu
        if (this.button && this.button.length) {
          var menu = this.button.data('popupmenu').menu;
          if (menu.has(active).length) {
            return true;
          }
        }

        return false;
      },

      /**
       * Focus event handler
       * @private
       * @returns {undefined}
       */
      handleFocus: function() {
        this.setAsActive();
      },

      /**
       * Blur event handler
       * @private
       * @returns {undefined}
       */
      handleBlur: function() {
        this.recalculateParent();

        if (!this.hasFocus()) {
          return;
        }

        this.wrapper.removeClass('has-focus');
      },

      /**
       * Click event handler
       * @private
       * @returns {undefined}
       */
      handleClick: function() {
        this.setAsActive();
      },

      /**
       * Keydown event handler
       * @private
       * @returns {undefined}
       */
      handleKeydown: function(e) {
        var key = e.which;

        if (key === 27) {
          this.clear();
        }
      },

      /**
       * Modifies the menu at $('#autocomplete-list') to propagate/remove style classes on the Searchfield element.
       * @private
       * @returns {boolean}
       */
      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return;
        }

        var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass',
          altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';

        menu[contextClassMethod]('context');
        menu[altClassMethod]('alternate');

        return true;
      },

      /**
       * Sets the text content on the category button.  Will either display a single category name, or a translated "[x] Selected." string.
       * @param {string} [textContent] - Optional incoming text that will be subtituted for the selected element count.
       * @returns {undefined}
       */
      setCategoryButtonText: function(textContent) {
        if (!this.settings.showCategoryText || !this.hasCategoryButton()) {
          return;
        }

        var text = '',
          button = this.wrapper.find('.btn'),
          span = button.find('span');

        if (!span || !span.length) {
          span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
        }

        span.empty();

        // incoming text takes precedent
        if (typeof textContent === 'string' && textContent.length) {
          span.text(textContent.trim());
          return;
        }

        // Otherwise, grab currently selected categories and set text
        // (or clear, if no options are selected).
        var item = this.getSelectedCategories();
        if (!item.length) {
          return;
        }

        if (item.length > 1) {
          text = item.length + ' ' + Locale.translate('Selected');
        } else {
          text = item.text().trim();
        }

        span.text(text);
      },

      /**
       * Detects whether or not this component is a Toolbar Searchfield
       * @returns {boolean}
       */
      isToolbarSearchfield: function() {
        return this.wrapper.is('.toolbar-searchfield-wrapper');
      },

      /**
       * Category Selection event handler
       * @private
       * @returns {undefined}
       */
      handleCategorySelected: function(e, anchor) {
        this.setCategoryButtonText(e, anchor.text().trim());

        // If this is a toolbar searchfield, run the size check that fixes the
        // trigger button and input field size.
        var tsAPI = this.element.data('toolbarsearchfield');
        if (tsAPI && typeof tsAPI.setOpenWidth === 'function') {
          tsAPI.calculateOpenWidth();
          tsAPI.setOpenWidth();
        }
      },

      /**
       * Category Button Focus event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryFocus: function() {
        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        this.wrapper
          .removeClass('active')
          .addClass('has-focus');
      },

      /**
       * Category Button Blur event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryBlur: function() {
        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        this.wrapper.removeClass('has-focus');
      },

      /**
       * Gets a complete list of categories in jQuery-collection form.
       * @return {jQuery} categories
       */
      getCategories: function() {
        return this.list.children('li:not(.separator)');
      },

      /**
       * Gets the currently selected list of categories in jQuery-collection form.
       * @return {jQuery} selectedCategories
       */
      getSelectedCategories: function() {
        return this.getCategories().filter('.is-checked');
      },

      /**
       * Gets the currently selected categories as data.
       * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return checked list items.
       * @returns {Object[]} data -
       * @returns {string} name - Category name
       * @returns {string|number} id - Category element's ID (if applicable)
       * @returns {string|number} value - Category element's value (if applicable)
       * @returns {boolean} [checked=true] - Category's selection status
       */
      getCategoryData: function(onlyReturnSelected) {
        var categories = this.getCategories(),
          data = [];

        categories.each(function() {
          var classList = this.classList,
            checked = classList.contains('is-checked');

          if (onlyReturnSelected === true && checked === false) {
            return;
          }

          var category = {
            name: this.innerText,
            checked: checked
          };

          if (this.id) {
            category.id = this.id;
          }

          var value = this.getAttribute('data-value');
          if (value !== undefined) {
            category.value = value;
          }

          data.push(category);
        });

        return data;
      },

      /**
       * Updates just the categories setting and rerenders the category list.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      updateCategories: function(categories) {
        this.settings.categories = categories;
        this.setCategories(this.settings.categories);
      },

      /**
       * Creates a new set of categories on the Searchfield and rerenders it.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      setCategories: function(categories) {
        this.list.empty();

        var self = this,
          previouslySelected = false;

        categories.forEach(function(val) {
          // if passed a string, typecast to an object.
          if (typeof val === 'string') {
            val = {
              name: val
            };
          }

          // Object types get a bit more customization.
          // Don't continue if there's no name present.
          if (!val.name) {
            return;
          }

          var id = '';
          if (typeof val.id === 'string' && val.id.length) {
            id = ' id="'+ val.id +'"';
          }

          var value = '',
            valueTypes = ['string', 'number'];
          if (valueTypes.indexOf(typeof val.value) > -1) {
            value = ' data-value="'+ val.value +'"';
          }

          var selected = '';
          if (val.checked === true && previouslySelected !== true) {
            selected = ' class="is-checked"';

            if (!self.settings.categoryMultiselect) {
              previouslySelected = true;
            }
          }

          self.list.append('<li'+ selected + id + value + '><a href="#">' + val.name + '</a></li>');
        });

        var api = this.button.data('popupmenu');
        if (api && typeof api.updated === 'function') {
          api.updated();
        }
      },

      /**
       * Determines whether or not a Category Trigger exists.
       * @returns {boolean}
       */
      hasCategoryButton: function() {
        return this.wrapper.find('.btn').length > 0;
      },

      /**
       * Category Button Close event handler
       * @private
       * @returns {function}
       */
      handlePopupClose: function() {
        return this.setAsActive(true, true);
      },

      /**
       * Clears the contents of the searchfield
       * @returns {undefined}
       */
      clear: function() {
        this.element.val('').trigger('change').focus();
      },

      /**
       * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a larger display of search results.
       * @private
       * @returns {undefined}
       */
      addMoreLink: function() {
        var list = $('#autocomplete-list'),
          val = this.element.val();

        if ($('.more-results', list).length > 0) {
          return;
        }

        $('<li class="separator" role="presentation"></li>').appendTo(list);
        var more = $('<li role="presentation"></li>').appendTo(list);
        this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('AllResults') + ' "' + val + '"</span>').appendTo(more);
      },

      /**
       * Adds a link at the bottom of a searchfield with no results that announces no search results.
       * @private
       * @returns {undefined}
       */
      addNoneLink: function() {
        var list = $('#autocomplete-list');
        if ($('.no-results', list).length > 0) {
          return;
        }

        var none = $('<li role="presentation"></li>').appendTo(list);

        this.noneLink = $('<a href="#" class="no-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('NoResults') + '</span>').appendTo(none);
      },

      /**
       * Tears down and rebuilds the Searchfield.
       * Can be called directly, but is also triggered by calling the "updated.searchfield" event on the searchfield element.
       * @returns {undefined}
       */
      updated: function() {
        this.teardown().init();
      },

      /**
       * Enables the Searchfield
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
       * Disables the Searchfield
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
      },

      /**
       * Performs the usual Boolean coercion with the exception of the strings "false" (case insensitive) and "0"
       * @private
       * @returns {boolean}
       */
      parseBoolean: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      /**
       * Unbinds events and removes unnecessary markup.
       * @private
       * @returns {this}
       */
      teardown: function() {
        this.element.off('updated.searchfield focus.searchfield blur.searchfield click.searchfield keydown.searchfield beforeopen.searchfield listopen.searchfield listclose.searchfield safe-blur.searchfield');

        if (this.autocomplete) {
          this.autocomplete.destroy();
        }

        if (this.wrapper.hasClass('context')) {
          this.element.addClass('context');
        }

        this.element.next('.icon').remove();
        if (this.element.parent().hasClass('searchfield-wrapper')) {
          this.element.parent().find('ul').remove();
          this.element.parent().find('.icon').remove();
        }

        return this;
      },

      /**
       * Destroys the Searchfield and removes all jQuery component instancing.
       * @returns {undefined}
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {

      // Detect if we're inside of a Toolbar and invoke Toolbar Searchfield first, if applicable.
      // Added for SOHO-6448.
      // NOTE: If we merge the searchfield/toolbarsearchfield apis, revisit this solution.
      var sf = $(this),
        toolbarParent = sf.parents('.toolbar');
      if (toolbarParent.length && !options.noToolbarSearchfieldInvoke) {
        var tbsf = sf.data('toolbarsearchfield');
        if (!tbsf) {
          return sf.toolbarsearchfield(options);
        } else {
          tbsf.updated();
        }
      }

      // Normal invoke setup
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SearchField(this, settings));
      }
    });
  };


  $.fn.signin = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'signin',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @class {SignIn}
     * @constructor
     * @param {Object} element
     */
    function SignIn(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    SignIn.prototype = {

      /**
       * @private
       */
      init: function() {
        this.settings = settings;
        this.handleKeys();
      },

      /**
       * Checks a keyboard event for a CAPS LOCK modifier.
       * @param {jQuery.Event} e
       * @returns {boolean}
       */
      isCapslock: function(e) {
        e = (e) ? e : window.event;
        var charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false),
         shifton = (e.shiftKey) ? e.shiftKey : ((e.modifiers) ? (!!(e.modifiers & 4)) : false);

        if (charCode >= 97 && charCode <= 122 && shifton) {
          return true;
        }
        if (charCode >= 65 && charCode <= 90 && !shifton) {
          return true;
        }
        return false;
      },

      /**
       * Teardown - Remove added markup and events
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        $('body').off('keypress.signin blur.signin change.signin');
      },

      /**
       * @fires SignIn#events
       * @param {Object} keypress
       * @param {Object} blur
       * @param {Object} change
       *
       */
      handleKeys: function() {
        var self = this,
          cssIcon = $.createIconElement({ classes: 'icon-capslock', icon: 'capslock' });

        // Disable default [caps lock on] popup in IE
        document.msCapsLockWarningOff = true;

        this.element
        .on('keypress.signin', '[type="password"]', function (e) {
          var field = $(this),
            fieldParent = field.parent('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          if (self.isCapslock(e) && !field.hasClass('error')) {
            if(!iconCapslock.length) {
              fieldParent.append(cssIcon);
              $('body').toast({audibleOnly: true, message: Locale.translate('CapsLockOn')});
            }
          } else {
            iconCapslock.remove();
          }

        })
        .on('blur.signin change.signin', '[type="password"]', function () {
          var field = $(this),
            fieldParent = field.closest('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          // Wait for error class to be added
          setTimeout(function() {
            if (iconCapslock && iconCapslock.length) {
              if (field.hasClass('error')) {
                iconCapslock.remove();
              } else {
                fieldParent.append(cssIcon);
              }
            }
          }, 150);

        });
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new SignIn(this, settings));
      }
    });
  };


  $.fn.slider = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'slider',
        defaults = {
          value: [50],
          min: 0,
          max: 100,
          range: false,
          step: undefined,
          ticks: [],
          tooltipContent: undefined,
          persistTooltip: false
        };

    /**
     * Touch Enabled/Responsive and Accessible Slider Control
     * @class {Slider}
     * @param {Array} value
     * @param {Number} min
     * @param {Number} max
     * @param {boolean} range
     * @param {undefined|Number} step
     * @param {Array} ticks
     * @param {undefined|Array} tooltipContent
     * @param {boolean} persistTooltip
     */
    function Slider(element) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Check if is an integer
    function isInt(n) {
      return n % 1 === 0;
    }

    // Round a non-integer to an integer closest to the nearest increment/decrement.
    // If no increment is provided or the increment is 0, only round to the nearest whole number.
    function roundToIncrement(number, increment) {
      if (!increment || isNaN(increment) || increment === 0) {
        increment = 1;
      }
      return Math.round(number/increment) * increment;
    }

    // Get the distance between two points.
    // PointA & PointB are both arrays containing X and Y coordinates of two points.
    // Distance Formula:  http://www.purplemath.com/modules/distform.htm
    function getDistance(pointA, pointB) {
      var aX = pointA[0], aY = pointA[1],
        bX = pointB[0], bY = pointB[1];

      return Math.sqrt( Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2) );
    }

    // Actual Plugin Code
    Slider.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        return this
          .buildSettings()
          .addMarkup()
          .bindEvents();
      },

      /**
       * Handles Data Attribute settings, some markup settings
       * @private
       * @returns {this}
       */
      buildSettings: function() {
        var self = this;

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        if (!this.settings) {
          this.settings = {};
        }
        this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
        this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min')) : this.settings.min;
        this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max')) : this.settings.max;
        this.settings.range = this.element.attr('data-range') !== undefined ? (this.element.attr('data-range') === 'true') : this.settings.range;
        this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

        if (this.settings.value === '') {
          this.settings.value = this.settings.min;
        }

        // build tick list
        var parsedTicks;
        if (this.element.attr('data-ticks') !== undefined) {
          try {
            parsedTicks = JSON.parse(self.element.attr('data-ticks'));
          } catch (e) {
          }

          if ($.isArray(parsedTicks)) {
            this.settings.ticks = parsedTicks;
          }
        }

        // build tooltip content
        var isTooltipPersist = (this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true);
        this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
        this.settings.tooltip = this.settings.tooltipContent;
        if (this.element.attr('data-tooltip-content') !== undefined) {
          try {
            self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
          } catch (e) {
          }
        }
        if (typeof this.settings.tooltip === 'string') {
          if (this.settings.tooltip.indexOf(',') === -1) {
            this.settings.tooltip = [this.settings.tooltip, ''];
          } else {
            var strings = this.settings.tooltip.split(',');
            this.settings.tooltip = [strings[0]];
            this.settings.tooltip.push( strings[1] ? strings[1] : '');
          }
        }
        if (this.settings.tooltip && this.settings.tooltip.length === 1) {
          this.settings.tooltip.push('');
        }

        // Build ticks.  All sliders have a tick for minimum and maximum by default.  Some will be provided as extra.
        this.ticks = [];
        var minTick = {
          'value' : this.settings.min,
          'description' : self.getModifiedTextValue(this.settings.min)
        }, maxTick = {
          'value' : this.settings.max,
          'description' : self.getModifiedTextValue(this.settings.max)
        };

        if (!this.settings.ticks) {
          this.ticks.push(minTick, maxTick);
        } else {
          // Check the type of the data-ticks.  If it's not a complete array
          // and doesn't have at least one option, ignore it.
          var ticks = self.settings.ticks || [];

          if ($.isArray(ticks) && ticks.length > 0) {
            // Filter through the incoming ticks to figure out if any have been defined
            // That match the values of min and max.
            var equalsMin = ticks.filter(function(obj) {
              return obj.value === self.settings.min;
            }),
            equalsMax = ticks.filter(function(obj) {
              return obj.value === self.settings.max;
            });

            // Overwrite description and color for min/max if they've been found.
            if (equalsMin.length > 0) {
              minTick.description = equalsMin[0].description;
              minTick.color = equalsMin[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMin[0];
              });
            }
            if (equalsMax.length > 0) {
              maxTick.description = equalsMax[0].description;
              maxTick.color = equalsMax[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMax[0];
              });
            }
          }

          // Push the values of all ticks out to the ticks array
          self.ticks.push(minTick);
          for (var i = 0; i < ticks.length; i++) {
            var tick = {};
            if (ticks[i].value !== undefined) {
              tick.value = ticks[i].value;
              tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
              tick.color = ticks[i].color;
              self.ticks.push(tick);
            }
          }
          self.ticks.push(maxTick);
        }

        // configure the slider to deal with an array of values, and normalize the values to make sure they are numbers.
        if ($.isArray(this.settings.value)) {
          this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value[0]);
        } else if (typeof this.settings.value === 'number') {
          this.settings.value = [this.settings.value];
        } else {
          // String
          if (this.settings.value.indexOf(',') === -1) {
            this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value)];
          } else {
            var vals = this.settings.value.split(',');
            vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0]);
            vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1]);
            this.settings.value = vals;
          }
        }

        // Add a second value to the array if we're dealing with a range.
        if (this.settings.range && !this.settings.value[1]) {
          this.settings.value.push(this.settings.max);
        }

        return this;
      },

      /**
       * Adds pseudo-markup that helps build the component
       * @private
       * @returns {this}
       */
      addMarkup: function() {
        var self = this,
          isVertical = false;

        if (self.element[0].tagName !== 'INPUT') {
          throw new Error('Element with ID "' + self.element.id + '" cannot invoke a slider;  it\'s not an Input element.');
        }

        // store values and attributes on the original element
        self.originalElement = {
          'type': self.element.attr('type')
        };

        // Hide the input element
        self.element.attr('type', 'hidden');

        // Build the slider controls
        self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', self.element.attr('id') + '-slider').insertAfter(self.element);
        self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
        self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper);

          // Set to a vertical slider if the class exists on the input
        if (this.element.hasClass('vertical')) {
          this.wrapper.addClass('vertical');
          isVertical = true;
        }

        // Set RTL
        this.isRtlHorizontal = (Locale.isRTL() && !isVertical);
        this.isRtlVertical = (Locale.isRTL() && isVertical);

        // Retain any width or height size properties from the original range element onto the Pseudo-markup
        var style = this.element.attr('style');
        if (style) {
          if (style.match(/min-height/)) {
            this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
            style = style.replace('min-height', '');
          }
          if (style.match(/height/)) {
            this.wrapper[0].style.height = this.element[0].style.height;
          }
          if (style.match(/min-width/)) {
            this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
            style = style.replace('min-width', '');
          }
          if (style.match(/width/)) {
            this.wrapper[0].style.width = this.element[0].style.width;
          }
        }

        // Handles
        self.handles = [];
        var labelText = self.element.prev('label').text(),
          handleLower = $('<div class="slider-handle' + (self.settings.range ? ' lower' : '') +'" tabindex="0"></div>')
          .attr('aria-label', (self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle')) + ' ' + labelText);
        self.handles.push(handleLower);
        if (self.settings.range) {
          var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>')
            .attr('aria-label', Locale.translate('SliderMaximumHandle') + ' ' + labelText);
          self.handles.push(handleHigher);
        }
        $.each(self.handles, function(i, handle) {
          // Add WAI-ARIA to the handles
          handle.attr({
            'role' : 'slider',
            'aria-orientation' : (isVertical ? 'vertical' : 'horizontal'),
            'aria-valuemin' : self.settings.min,
            'aria-valuemax' : self.settings.max
          }).hideFocus();
          handle.appendTo(self.wrapper);
        });

        function positionTick(tick) {
          var convertValueToPercentage = self.isRtlHorizontal ?
              (100 - self.convertValueToPercentage(tick.value)) :
              self.convertValueToPercentage(tick.value),
            pos = 'calc(' + convertValueToPercentage + '% - 4px)';

          tick.element = $('<div class="tick" data-value="'+ tick.value +'"></div>');
          tick.label = $('<span class="label">' + tick.description + '</span>');
          tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
          tick.element.append(tick.label);
          self.wrapper.append(tick.element);

          if (isVertical) {
            return;
          }
          tick.label[0].style.left = -(tick.label.outerWidth()/2 - tick.element.width()/2) + 'px';
        }

        // Ticks
        self.ticks.forEach(function(tick) {
          positionTick(tick);
        });

        self.value(self.settings.value);
        self.updateRange();

        // Tooltip on handle needs to update later
        $.each(self.handles, function(i, handle) {
          if (self.settings.tooltip) {
            handle.tooltip({
              content: function() {
                return '' + self.getModifiedTextValue(Math.floor(self.value()[i]));
              },
              placement: (isVertical ? 'right' : 'bottom'),
              trigger: 'focus',
              keepOpen: self.settings.persistTooltip
            });
            handle.removeAttr('aria-describedby');
          }
        });

        if (this.element.prop('disabled') === true) {
          this.disable();
        }

        return self;
      },

      /**
       * User is interacting with the Slider Range (not the handle or ticks)
       * @param {jQuery.Event} e
       */
      handleRangeClick: function(e) {
          e.preventDefault();
          if (this.isDisabled()) {
            return;
          }

          var self = this,
            isVertical = this.wrapper.hasClass('vertical'),
            pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX,
            pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY,
            mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft(),
            mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop(),
            clickCoords = [mouseX,mouseY],
            fhX = (self.handles[0].offset().left + (self.handles[0].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft(),
            fhY = (self.handles[0].offset().top + (self.handles[0].height()/2)) - self.wrapper.offset().top - $(document).scrollTop(),
            firstHandleCoords = [fhX,fhY],
            shX,
            shY,
            secondHandleCoords,
            oldVals = self.value(),
            dLower = getDistance(clickCoords,firstHandleCoords),
            dHigher,
            targetOldVal = oldVals[0],
            targetHandle = self.handles[0];

          targetHandle.addClass('hide-focus');

          function conversion() {
            if (isVertical) {
              var wh = self.wrapper.height();
              return ((wh - mouseY) / wh) * 100;
            }
            return (mouseX / self.wrapper.width()) * 100;
          }

          // Convert the coordinates of the mouse click to a value
          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // If the slider is a range, we may use the second handle instead of the first
          if (self.handles[1]) {
            shX = (self.handles[1].offset().left + (self.handles[1].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft();
            shY = (self.handles[1].offset().top + (self.handles[1].height()/2)) - self.wrapper.offset().top - $(document).scrollTop();
            secondHandleCoords = [shX, shY];
            dHigher = getDistance(clickCoords,secondHandleCoords);

            if (dLower > dHigher) {
              self.value([undefined, rangeVal]);
              targetHandle = self.handles[1];
              targetOldVal = oldVals[1];
            } else {
              self.value([rangeVal]);
            }
          } else {
            self.value([rangeVal]);
          }

          self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);

          if (rangeVal < targetOldVal) {
            self.decreaseValue(e, targetHandle, rangeVal, 0);
          } else {
            self.increaseValue(e, targetHandle, rangeVal, 0);
          }

          // Tooltip repositioner will focus the handle after positioning occurs, but if we are clicking a tick
          // on a slider with no tooltip, we need to focus it manually.
          if (!self.settings.tooltip) {
            targetHandle.focus();
          }
      },

      /**
       * Activates one of the slider handles
       * @param {jQuery[]} handle
       */
      activateHandle: function(handle) {
        handle.addClass('is-active');
      },

      /**
       * Deactivates one of the slider handles
       * @param {jQuery[]} handle
       */
      deactivateHandle: function(handle) {
        handle.removeClass('is-active');
      },

      /**
       * Enables the ability to drag one of the slider handles.
       * @param {jQuery[]} handle
       */
      enableHandleDrag: function(handle) {
        if (this.isDisabled()) {
          return;
        }

        var self = this,
          draggableOptions = {
            containment: 'parent',
            axis: (this.isVertical() ? 'y' : 'x'),
            clone: false
          };

        function updateHandleFromDraggable(e, handle, args) {
          if (self.isDisabled()) {
            return;
          }

          function conversion() {
            if (self.isVertical()) {
              var wh = self.wrapper.height(),
              // Vertical Slider accounts for limits set on the height by SoHo Xi Drag.js
              adjustedHeight = wh - handle.outerHeight();

              return ((adjustedHeight - args.top) / adjustedHeight) * 100;
            }
            return args.left / (self.wrapper.width() - handle.outerWidth()) * 100;
          }

          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // Ranged values need to check to make sure that the higher-value handle doesn't drawindowg past the
          // lower-value handle, and vice-versa.
          if (self.settings.range) {
            var originalVal = self.value();
            if (handle.hasClass('higher') && rangeVal <= originalVal[0]) {
              rangeVal = originalVal[0];
            }
            if (handle.hasClass('lower') && rangeVal >= originalVal[1]) {
              rangeVal = originalVal[1];
            }
          }

          // Round the value to the nearest step, if the step is defined
          if (self.settings.step) {
            rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
          }

          if (!e.defaultPrevented) {
            self.value(handle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
            self.updateRange();
            self.updateTooltip(handle);
            self.element.trigger('sliding', handle, rangeVal);
          }

          return;
        }

        // Add/Remove Classes for canceling animation of handles on the draggable's events.
        handle.drag(draggableOptions)
        .on('drag.slider', function (e, args) {
          updateHandleFromDraggable(e, $(e.currentTarget), args);
        })
        .on('dragstart', function() {
          $(this).addClass('is-dragging');
          self.range.addClass('is-dragging');
          self.element.trigger('slidestart', handle);
        })
        .on('dragend', function() {
          $(this).removeClass('is-dragging');
          self.range.removeClass('is-dragging');
          self.element.trigger('slidestop', handle);
        });
      },

      /**
       * Disables the dragging of a handle.
       * @param {jQuery[]} handle
       */
      disableHandleDrag: function(handle) {
        handle.off('drag.slider dragstart dragend');

        this.range.removeClass('is-dragging');
        handle.removeClass('is-dragging');

        var dragAPI = handle.data('drag');
        if (dragAPI) {
          dragAPI.destroy();
        }
      },

      /**
       * @private
       * @param {Number} value
       * @returns {Number}
       */
      convertValueToPercentage: function(value) {
        return (((value - this.settings.min) / (this.settings.max - this.settings.min)) * 100);
      },

      /**
       * @private
       * @param {Number} percentage
       * @returns {Number}
       */
      convertPercentageToValue: function(percentage) {
        var val = (percentage / 100) * (this.settings.max - this.settings.min) + this.settings.min;
        return this.isRtlHorizontal ? (this.settings.max - val + this.settings.min) : val;
      },

      /**
       * Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
       * @returns {Number}
       */
      getIncrement: function() {
        var increment = 0.1 * (this.settings.max - this.settings.min);
        if (this.settings.step !== undefined && increment <= this.settings.step) {
          increment = this.settings.step;
        }
        return increment;
      },

      /**
       * Handles Slider Component's keystrokes
       * @param {jQuery.Event} e
       * @param {this} self
       */
      handleKeys: function(e, self) {
        if (self.isDisabled()) {
          return;
        }

        var key = e.which,
          handle = $(e.currentTarget);

        handle.removeClass('hide-focus');

        // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.
        switch(key) {
          case 33: // Page Up increases the value by 10%
            self.increaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 34: // Page Down decreases the value by 10%
            self.decreaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 35: // End key sets the handle to its maximum possible value
            self.increaseValue(e, handle, this.settings.max);
            break;
          case 36: // Home key sets the handle to its lowest (either minimum value or as low as the "lower" handle)
            self.decreaseValue(e, handle, this.settings.min);
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (self.isRtlHorizontal && key === 39) {
              self.decreaseValue(e, handle);
            } else {
              self.increaseValue(e, handle);
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (self.isRtlHorizontal && key === 37) {
              self.increaseValue(e, handle);
            } else {
              self.decreaseValue(e, handle);
            }
            break;
        }
      },

      /**
       * Increases the value of one of the slider handles, accounting for step value, percentage, etc.
       * Also visually updates the handle on the visual part of the slider.
       * @param {jQuery.Event} e
       * @param {jQuery[]} handle
       * @param {Number} [value] - target value - will be automatically determined if not passed.
       * @param {Number} [increment] - an integer that will be used as the amount to increment.
       */
      increaseValue: function(e, handle, value, increment) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value().slice(0),
          incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy;
          updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          var maxValue = val[1] === undefined ? this.settings.max : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - (testVal % incrementBy);
          updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      /**
       * Decreases the value of one of the slider handles, accounting for step value, percentage, etc.
       * Also visually updates the handle on the visual part of the slider.
       * @param {jQuery.Event} e
       * @param {jQuery[]} handle
       * @param {Number} [value] - target value - will be automatically determined if not passed.
       * @param {Number} [decrement] - an integer that will be used as the amount to decrement.
       */
      decreaseValue: function(e, handle, value, decrement) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value(),
          decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          var minValue = val[0] === undefined ? this.settings.min : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - (testVal % decrementBy);
          updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy;
          updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      /**
       * Changes the position of the bar and handles based on their values.
       */
      updateRange: function() {
        var self = this,
          newVal = this.value(),
          percentages = [],
          color = this.getColorClosestToValue(),
          isVertical = self.wrapper.hasClass('vertical');

        for (var i = 0; i < this.ticks.length; i++) {
          var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] :
            newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

          if (condition) {
            this.ticks[i].element.addClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = color;
              this.ticks[i].element.addClass('inherit');
            }
          } else {
            this.ticks[i].element.removeClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = '';
              this.ticks[i].element.removeClass('inherit');
            }
          }
        }

        if (color) {
          this.range[0].style.backgroundColor = color;
          $.each(this.handles, function(i, handle) {
            handle[0].style.backgroundColor = color;
            handle[0].style.borderColor = color;
          });
        }

        // Remove any text colors that already existed.
        $.each(self.ticks, function(i) {
          self.ticks[i].label[0].style.color = '';
        });

        // Convert the stored values from ranged to percentage
        percentages[0] = this.convertValueToPercentage(newVal[0]);
        if (newVal[1] !== undefined) {
          percentages[1] = this.convertValueToPercentage(newVal[1]);
        }

        var posAttrs = (isVertical ? ['bottom', 'top'] :
          (self.isRtlHorizontal ? ['right', 'left'] : ['left', 'right'])),
          cssProps = {};

        // If no arguments are provided, update both handles with the latest stored values.
        if (!this.handles[1]) {
          cssProps[posAttrs[0]] = '0%';
          cssProps[posAttrs[1]] = (100 - percentages[0]) + '%';
        } else {
          cssProps[posAttrs[0]] = percentages[0] + '%';
          cssProps[posAttrs[1]] = (100 - percentages[1]) + '%';
        }
        this.range.css(cssProps);

        function positionHandle(handle, percentage) {
          var basePosition = isVertical ? posAttrs[1] : posAttrs[0],
            realPercentage = isVertical ? 100 - percentage : percentage;

          handle.css(basePosition, 'calc(' + realPercentage + '% - ' + handle.outerWidth()/2 + 'px)');
        }

        if (this.handles[0].hasClass('is-animated')) {
          this.handles[0].data('animationTimeout', setTimeout( function() {
            self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }
        positionHandle(this.handles[0], percentages[0]);

        if (this.handles[1]) {
          if (this.handles[1].hasClass('is-animated')) {
            this.handles[1].data('animationTimeout', setTimeout( function() {
              self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
              self.range.removeClass('is-animated');
            }, 201));
          }
          positionHandle(this.handles[1], percentages[1]);

          // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax' attribute on the Min handle
          // for better screen reading compatability
          this.handles[0].attr('aria-valuemax', newVal[1]);
          this.handles[1].attr('aria-valuemin', newVal[0]);
        }
      },

      /**
       * Allows a handle to animate to a new position if the difference in value is greater than 3% of the size of the range.
       * @param {jQuery[]} handle
       * @param {Number} originalVal
       * @param {Number} updatedVal
       */
      checkHandleDifference: function(handle, originalVal, updatedVal) {
        // IE9 doesn't support animation so return immediately.
        if ($('html').hasClass('ie9')) {
          return;
        }
        var origPercent = this.convertValueToPercentage(originalVal),
          updatedPercent = this.convertValueToPercentage(updatedVal);

        if (Math.abs(origPercent - updatedPercent) > 3) {
          handle.addClass('is-animated');
          this.range.addClass('is-animated');
        }
      },

      /**
       * If tooltips are active, updates the current placement and content of the Tooltip.
       * If no handle argument is passed, this method simply hides both handles' tooltips.
       * @param {jQuery[]} [handle]
       */
      updateTooltip: function(handle) {
        if (!this.settings.tooltip) {
          return;
        }

        if (!handle) {
          var tooltipLow = this.handles[0].data('tooltip'),
            tooltipHigh;

          if (this.handles[1]) {
            tooltipHigh = this.handles[1].data('tooltip');
          }

          tooltipLow.hide();
          if (tooltipHigh) {
            tooltipHigh.hide();
          }

          return;
        }

        var tooltip = handle.data('tooltip');

        function update() {
          tooltip.position();
          handle.focus();
        }

        // NOTE: This is a bit hacky because it depends on the setTimeout() method for animation that is triggered
        // inside the self.updateRange() method to have not fired yet.  If you put a breakpoint anywhere in there you
        // may see strange results with animation.
        if (handle.hasClass('is-animated')) {
          tooltip.hide();
          handle.one('slide-animation-end', function() {
            update();
          });
        } else {
          update();
        }
      },

      /**
       * Gets a string-based hex value for the closest tick's defined color.
       * @returns {string}
       */
      getColorClosestToValue: function() {
        var currentTheme = Soho.theme,
          preColors = {
            'light': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'dark': {
              'default'   : '#ffffff',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'high-contrast': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#e4882b',
              'good'      : '#76b051',
              'very-good' : '#56932e',
              'superior'  : '#397514'
            }
          };

        var themeColors = preColors[currentTheme],
          val = this.value()[0],
          highestTickColor, c;

        for (var i = 0; i < this.ticks.length; i++) {
          c = this.ticks[i].color;
          if (c && val >= this.ticks[i].value) {
            highestTickColor = c;
            highestTickColor = (c.indexOf('#') > -1) ? c : (themeColors[c] || themeColors.default);
          }
        }

        return highestTickColor;
      },

      /**
       * External Facing Function to set the value. Works as percent for now but need it on ticks.
       * NOTE:  Does not visually update the range.  Use _setValue()_ to do both in one swoop.
       * @param {Number} minVal
       * @param {Number} [maxVal]
       * @returns {Array}
       */
      value: function(minVal, maxVal) {
        var self = this;

        // if both options are absent, act as a getter and return the current value
        if (minVal === undefined && maxVal === undefined) {
          return self._value;
        }

        // if an array is passed as the first argument, break it apart
        if (minVal && $.isArray(minVal)) {
          if (minVal[1] !== undefined) {
            maxVal = minVal[1];
          }
          minVal = minVal[0];
        }

        // set the values back to the existing one if they aren't passed.
        if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
          minVal = self._value[0];
        }
        if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
          maxVal = self._value[1];
        }

        //set the internal value and the element's retrievable value.
        self._value = [minVal, maxVal];
        self.element.val(maxVal !== undefined ? self._value : self._value[0]);
        $.each(self.handles, function(i, handle) {
          var value = self._value[i],
            valueText = self.getModifiedTextValue(value);

          $.each(self.ticks, function(a, tick) {
            if (tick.value === value) {
              valueText = tick.description;
            }
          });

          handle.attr({
            'aria-valuenow': self._value[i],
            'aria-valuetext': valueText
          });
        });

        self.element.trigger('change');
        return self._value;
      },

      /**
       * Returns a value with prefixed/suffixed text content.
       * Used by the tooltip and default ticks to get potential identifiers like $ and %.
       * @param {string} content
       * @returns {string}
       */
      getModifiedTextValue: function(content) {
        if (!this.settings.tooltip) {
          return content;
        }
        return this.settings.tooltip[0] + content + this.settings.tooltip[1];
      },

      /**
       * Enables the slider instance.
       * @returns {this}
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.wrapper.removeClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.enableHandleDrag(handle);
        });

        return this;
      },

      /**
       * Disables the slider instance.
       * @returns {this}
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.wrapper.addClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.disableHandleDrag(handle);
        });

        return this;
      },

      /**
       * Detects whether or not this slider is disabled
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Detects whether or not this slider is vertical
       * @returns {boolean}
       */
      isVertical: function() {
        return this.wrapper.hasClass('vertical');
      },

      /**
       * Externally-facing function that updates the current values and correctly animates the range handles, if applicable.
       * @param {Number} lowVal
       * @param {Number} [highVal]
       * @returns {Array}
       */
      setValue: function(lowVal, highVal) {
        var oldVals = this.value();

        this.checkHandleDifference(this.handles[0], oldVals[0], lowVal);
        if (this.handles[1]) {
            this.checkHandleDifference(this.handles[1], oldVals[1], highVal);
        }

        var vals = this.value(lowVal, highVal);
        this.updateRange();
        this.updateTooltip();

        return vals;
      },

      // NOTE: refresh() has been deprecated in Xi Controls v4.2 - has been replaced with setValue().
      // This method will be completely removed in v4.3 and v5.x.  Please update your code.
      /**
       * @private
       * @returns {Array}
       */
      refresh: function(lowVal, highVal) {
        return this.setValue(lowVal, highVal);
      },

      /**
       * Updates the slider instance after a settings change.
       * Settings and markup are complicated in the slider so we just destroy and re-invoke it
       * with fresh settings.
       * @returns {this}
       */
      updated: function() {
        this.element.removeAttr('value');
        return this
          .teardown()
          .init();
      },

      /**
       * Removes the events and pseudo-markup created by the slider
       * @returns {this}
       */
      teardown: function() {
        var self = this;
        $.each(self.handles, function (i, handle) {
          self.disableHandleDrag(handle);
          handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
        });
        this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
        this.element.attr('type', this.originalElement.type);

        return this;
      },

      /**
       * Destroys the slider component instance and unlinks it from its base element.
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * @fires Slider#events
       * @param {Object} mousedown
       * @param {Object} click
       * @param {Object} keydown
       * @param {Object} keyup
       * @param {Object} touchend
       * @param {Object} touchcancel
       * @param {Object} updated
       * @returns {this}
       */
      bindEvents: function() {
        var self = this;

        $.each(self.handles, function (i, handle) {
          handle.on('mousedown.slider', function () {
            if (self.isDisabled()) {
              return;
            }
            $(this).focus();
          })
          .on('click.slider', function (e) {
            e.preventDefault(); //Prevent from jumping to top.
          })
          .on('keydown.slider', function(e) {
            self.activateHandle(handle);
            self.handleKeys(e, self);
          })
          .on('keyup.slider blur.slider', function() {
            self.deactivateHandle(handle);
          });

          self.enableHandleDrag(handle);
        });

        self.wrapper.on('click.slider touchend.slider touchcancel.slider', function(e) {
          self.handleRangeClick(e);
        });

        // Slider Control listens to 'updated' trigger on its base element to update values
        self.element.on('updated.slider', function() {
          self.updated();
        });

        return self;
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        } else {
          instance.settings = $.extend({}, instance.settings, options);
        }
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Slider(this, options));
      }
    });
  };


  $.fn.arrange = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'arrange',
        defaults = {
          handle: null, // The Class of the handle element
          itemsSelector: null,
          connectWith: false,
          placeholder: null,
          placeholderCssClass: 'arrange-placeholder'
        },
        settings = $.extend({}, defaults, options);


    /**
    * The Arrange Component allows touch and drag support to sort UI items.
    *
    * @class Arrange
    * @param {String} handle  &nbsp;-&nbsp; The class name of the handle element to connect
    * @param {String} itemsSelector  &nbsp;-&nbsp; The selector to match all the sortable elements.
    * @param {String} connectWith  &nbsp;-&nbsp; The optional element to connect with when using two lists
    * @param {String} placeholder  &nbsp;-&nbsp; The html for the element that appears while dragging
    * @param {String} placeholderCssClass  &nbsp;-&nbsp; The class to add to the ghost element that is being dragged.
    *
    */
    function Arrange(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Arrange Methods
    Arrange.prototype = {

      // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
      init: function() {
        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.handleEvents();
      },

      // Get Element By Touch In List
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      // Dragg touch element
      dragTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      unbind: function() {
        this.items
          .removeClass('draggable')
          .removeAttr('draggable')
          .off('selectstart.arrange '+ this.dragStart +' '+ this.dragEnd +' '+ this.dragWhileDragging);

        $(this.handle, this.items)
          .removeClass('draggable')
          .off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');

        return this;
      },

      /**
      * Resync the UI and Settings.
      */
      updated: function() {
        return this
          .unbind()
          .init();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },


      /**
       *  This component fires the following events.
       *
       * @fires Arrange#events
       * @param {Object} beforearrange  &nbsp;-&nbsp; Fires before moving an element allowing you to access the ui to customize the draggable item
       * @param {Object} afterearrange  &nbsp;-&nbsp; Fires after moving an element allowing you do any follow up updating.
       *
       */
      handleEvents: function() {
        var self = this,
          index, isHandle,
          status = {},
          items = self.element.children().not('[data-arrange-exclude="true"]'),
          placeholder = $('<' + (/^(ul|ol)$/i.test(self.element[0].tagName) ? 'li' : 'div') +'>');

        if (settings.itemsSelector) {
          items = $(settings.itemsSelector, self.element).not('[data-arrange-exclude="true"]');
          placeholder = $('<'+ items.first()[0].tagName +' />');
        }

        if (settings.placeholder) {
          placeholder = $(settings.placeholder);
        }

        self.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
        self.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
        self.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';

        self.handle = settings.handle || self.element.attr('data-arrange-handle');
        self.connectWith = self.element.attr('data-arrange-connectWith');
        self.placeholders = placeholder;

        if (!self.isTouch) {
          self.placeholders.addClass(settings.placeholderCssClass +' draggable');
        }

        // Use Handle if available
        $(self.handle, items).addClass('draggable')
          .on('mousedown.arrange touchstart.arrange', function() { isHandle = true; })
          .on('mouseup.arrange touchend.arrange', function() { isHandle = false; });

        // Add connect with
        if (self.connectWith) {
          items = items
            .add($(self.connectWith).children().not('[data-arrange-exclude="true"]'))
            .data('connectWith', self.connectWith);
        }

        self.items = items;

        // Draggable Items
        self.items
        .attr('draggable', true).addClass(self.handle ? '' : 'draggable')
        .add([this, placeholder])
        .not('a[href], img').on('selectstart.arrange', function() {
          if(this.dragDrop) {
            this.dragDrop();//ie9
          }
          return false;
        }).end()

        .each(function() {
          $(this)
          // Drag start --------------------------------------------------------------------------
          .on(self.dragStart, function(e) {
            if (self.handle && !isHandle) {
              if (self.isTouch) {
                return;
              } else {
                return false;
              }
            }
            isHandle = false;
            self.dragging = $(this);

            index = self.dragging.addClass('arrange-dragging').index();

            $.extend(status, {start: self.dragging, startIndex: index});
            self.element.triggerHandler('beforearrange', status);

            if (self.isTouch) {
              var rect = self.dragging[0].getBoundingClientRect(),
                touch = e.originalEvent.changedTouches[0];

              //Save offset
              self.offset = {
                x: touch.pageX - rect.left,
                y: touch.pageY - rect.top
              };
              self.placeholderTouch = self.dragging
                .clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch')
                .insertBefore(self.dragging);

              self.dragTouchElement(e, self.placeholderTouch);
            } else {
              var dt = e.originalEvent.dataTransfer;
              dt.effectAllowed = 'move';
              dt.setData('Text', 'dummy');
            }

          })

          // Drag end ----------------------------------------------------------
          .on(self.dragEnd, function() {
            if (!self.dragging) {
              return;
            }

            if (self.isTouch) {
              self.dragging.css('opacity', 1);
              self.placeholderTouch.remove();
            }

            self.placeholders.filter(':visible').after(self.dragging);
            self.dragging.removeClass('arrange-dragging').show();
            self.placeholders.detach();

            if (index !== self.dragging.index()) {
              $.extend(status, {end: self.dragging, endIndex: self.dragging.index()});
              self.element.triggerHandler('arrangeupdate', status);
            }
            self.dragging = null;
            self.placeholderTouch = null;
          })

          // While dragging ----------------------------------------------------
          .on(self.dragWhileDragging, function(e) {
            if (!self.dragging) {
              return;
            }
            var overItem = this,
              overIndex;
            e.preventDefault();

            if (e.type==='drop') {
              e.stopPropagation();
              self.dragging.trigger('dragend.arrange');
              return false;
            }

            if (self.isTouch) {
              var touch = e.originalEvent.touches[0];
              overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
            }
            overItem = $(overItem);

            if (!self.isTouch) {
              e.originalEvent.dataTransfer.dropEffect = 'move';
            }

            if (items.is(overItem) && placeholder.index() !== overItem.index()) {
              if (self.isTouch) {
                self.dragging.css('opacity', 0);
              } else {
                self.dragging.hide();
              }

              if (placeholder.index() < (overItem.index())) {
                placeholder.insertAfter(overItem);
                overIndex = overItem.index();
              }
              else {
                placeholder.insertBefore(overItem);
                overIndex = placeholder.index();
              }

              $.extend(status, {over: overItem, overIndex: overIndex});
              self.element.triggerHandler('draggingarrange', status);

              // Fix: IE-11 on windows-10 svg was disappering
              var svg = $('svg', overItem);
              if(self.isIe11 && svg.length) {
                overItem.html(overItem.html());
              }

              self.placeholders.not(placeholder).detach();
            }
            else if (!self.placeholders.is(this)) {
              self.placeholders.detach();
              self.element.append(placeholder);
            }

            if (self.isTouch) {
              self.dragTouchElement(e, self.placeholderTouch);
              return;
            } else {
              return false;
            }
          });//-----------------------------------------------------------------
        });//end each items
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Arrange(this, settings));
      }
    });
  };


  $.fn.scrollaction = function(options) {

    var pluginName = 'scrollaction';
    var defaults = {
      scrollActionTarget: '.js-scroll-target', // The element to add a class to based on scrolling logic
      classToAdd: 'scrolled-down' // The class added to the target element
    };

    var functions = {
      trackScrolling: function() {
        var self = this;
        self.lastScrollTop = 0;

        this.element.scroll(function() {
          var st = $(this).scrollTop();

          if (st > self.lastScrollTop){
            $(self.settings.scrollActionTarget).addClass(self.settings.classToAdd);
          } else {
            $(self.settings.scrollActionTarget).removeClass(self.settings.classToAdd);
          }

          self.lastScrollTop = st;
        });
      }
    };

    /**
     * A component that applies a class based on scroll direction
     * @constructor
     * @param {Object} [element=this] - The element to attach to (only when manually calling the constructor)
     * @param {Object} [options]
     * @param {string} [options.scrollActionTarget='.js-scroll-target'] - The selector of the element to add the class to
     * @param {string} [options.classToAdd='scrolled-down'] - The class name
     */
    function ScrollAction(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      functions.trackScrolling.call(this);
    }

    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new ScrollAction(this, options));
      }
    });
  };



  $.fn.spinbox = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'spinbox',
        defaults = {
          min: null,
          max: null,
          step: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Spinbox component provides easy access to modification of a numeric input field.
    *
    * @class Spinbox
    * @param {null|Number} min &nbsp;-&nbsp; if defined, provides a minimum numeric limit
    * @param {null|Number} max  &nbsp;-&nbsp; if defined, provides a maximum numeric limit
    * @param {null|Number} step  &nbsp;-&nbsp; if defined, increases or decreases the spinbox value by a specific interval whenever the control buttons are used.
    */
    function Spinbox(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Spinbox.prototype = {

      /**
       * @private
       */
      init: function() {
        this.settings = $.extend({}, settings);
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.isWrapped = this.element.parent().is('.spinbox-wrapper');

        this
          .setInitialValue()
          .addMarkup()
          .bindEvents()
          .setWidth();
      },

      /**
       * Sets the width of the spinbox input field.
       * @returns {this}
       */
      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.element.parent()[0].style.width = (parseInt(style.width) + (this.element.parent().find('.down').outerWidth() * 2)) + 'px';
        }

        return this;
      },

      /**
       * Sanitize the initial value of the input field.
       * @returns {this}
       */
      setInitialValue: function() {
        var self = this,
          val = self.checkForNumeric(self.element.val());

        this.element.val(val);
        // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
        // of the input, since it may have changed after re-invoking the input field.
        if (this.element.attr('data-trackdirty')) {
          this.element.data('original', val);
        }

        //allow numeric input on iOS
        var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
        if (iOS) {
          this.element.attr('pattern','\\d*');
        }

        if (this.settings.max) {
          this.element.attr('max', this.settings.max);
        }
        if (this.settings.step) {
          this.element.attr('step', this.settings.step);
        }
        if (this.settings.min) {
          this.element.attr('min', this.settings.min);
        }


        return this;
      },

      /**
       * Appends extra control markup to a Spinbox field.
       * @returns {this}
       */
      addMarkup: function() {
        var self = this;
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('spinbox-wrapper');
        }
        else if (!this.isWrapped) {
          this.element.wrap('<span class="spinbox-wrapper"></span>');
        }

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (this.isWrapped) {
          this.buttons = {
            'down' : this.element.parent().find('.down').button(),
            'up' : this.element.parent().find('.up').button()
          };

          if (this.isTouch) {
            this.buttons.down.attr('aria-hidden', 'true');
            this.buttons.up.attr('aria-hidden', 'true');
          }
        }

        if (!this.buttons) {
          this.buttons = {
            'down' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control down">-</span>').insertBefore(this.element).button(),
            'up' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control up">+</span>').insertAfter(this.element).button()
          };
        }

        // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
        // plugin either the min/max or the mask, and the plugin will automatically figure out how to
        // use them.
        var min = this.element.attr('min'),
          max = this.element.attr('max'),
          mask = this.element.attr('data-mask'),
          maskSize, maskValue = '',
          attributes = {
            role: 'spinbutton'
          },
          i = 0;

        // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
        // work correctly.  Cannot define a Min value here because the plugin must be able to invoke itself
        // with a NULL value.
        if (!min && !max && !mask) {
          max = '9999999';
        }

        // If a mask doesn't exist, but min and max values do exist, create a mask that reflects those min/max values
        if ((min || max) && !mask) {
          var newMask = '',
            tempMin = min ? min : '',
            tempMax = max ? max : '',
            longerVal = tempMin.length > tempMax.length ? tempMin : tempMax;
          i = 0;

          while (i <= longerVal.length) {
            newMask += '#';
            i++;
          }

          // Add a negative symbol to the mask if it exists within the longer value.
          if (tempMin.indexOf('-') !== -1 || tempMax.indexOf('-') !== -1) {
            newMask = '-' + newMask.substring(0, (newMask.length - 1));
          }

          attributes['data-mask'] = newMask;
          mask = newMask;
        }

        // If a "data-mask" attribute is already defined, use it to determine missing values for min/max, if they
        // don't already exist.
        maskSize = mask.length;
        i = 0;
        while (i <= maskSize) {
          maskValue += '9';
          i++;
        }

        // If no negative symbol exists in the mask, the minimum value must be zero.
        if (mask.indexOf('-') === -1) {
          attributes.min = min ? min : 0;
          attributes.max = max ? max : maskValue;
        } else {
          attributes.min = min ? min : maskValue;
          attributes.max = max ? max : maskValue.substring(0, (maskValue.length - 1));
        }

        if (!this.element.attr('data-mask-mode') || this.element.attr('data-mask-mode') !== 'number') {
          attributes['data-mask-mode'] = 'number';
        }

        // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later on during
        // initialization.  Check to make sure its the actual Mask plugin object, and not the "data-mask"
        // pattern string.
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }

        // Add Aria Properties for valuemin/valuemax
        if (min) {
          attributes['aria-valuemin'] = min;
        }
        if (max) {
          attributes['aria-valuemax'] = max;
        }
        this.element.attr(attributes);

        // Set an initial "aria-valuenow" value.
        this.updateAria(self.element.val());

        // Invoke the mask plugin
        this.element.mask();

        // Disable in full if the settings have determined we need to disable on init.
        if (this.isDisabled()) {
          this.disable();
        }

        return this;
      },

      /**
       * Enables Long Pressing one of the Spinbox control buttons.
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      enableLongPress: function(e, self) {
        self.addButtonStyle(e);
        self.longPressInterval = setInterval(function() {
          if ($(e.currentTarget).is(':hover')) {
            self.handleClick(e);
          }
        }, 140);
      },

      /**
       * Disables Long Pressing one of the Spinbox control buttons.
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      disableLongPress: function(e, self) {
        self.removeButtonStyle(e);
        clearInterval(self.longPressInterval);
        self.longPressInterval = null;
      },

      /**
       * Event handler for 'click' events
       * @param {jQuery.Event} e
       */
      handleClick: function(e) {
        if (this.isDisabled() || e.which !== 1) {
          return;
        }
        var target = $(e.currentTarget);
        if (target.hasClass('up')) {
          this.increaseValue();
        } else {
          this.decreaseValue();
        }

        if (!this.isTouch) {
          this.element.focus();
        } else {
          target.focus();
        }
      },

      /**
       * Event handler for 'keydown' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyDown: function(e, self) {
        var key = e.which,
          validKeycodes = [35, 36, 37, 38, 39, 40];

        if ($.inArray(key, validKeycodes) === -1) {
          return;
        }

        // If the keycode got this far, it's an arrow key, HOME, or END.
        switch(key) {
          case 35: // End key sets the spinbox to its minimum value
            if (self.element.attr('min')) { self.element.val(self.element.attr('min')); }
            break;
          case 36: // Home key sets the spinbox to its maximum value
            if (self.element.attr('max')) { self.element.val(self.element.attr('max')); }
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (Locale.isRTL() && key === 39) {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            } else {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (Locale.isRTL() && key === 37) {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            } else {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            }
            break;
        }
      },

      /**
       * Event handler for 'keypress' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyPress: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // NOTE:
        if (key < 48 || (key > 57 && key < 96) || key > 105) {
          return;
        }

        // If the key is a number, pre-calculate the value of the number to see if it would be
        // greater than the maximum, or less than the minimum.  If it's fine, let it through.
        // Doing this check here prevents visual jitter.
        var num = Number(this.checkForNumeric(this.element.val())), // if using Numlock, subtract 48 to get the correct value from String.fromCharCode()
          min = self.element.attr('min'),
          max = self.element.attr('max');

        if (num < min) {
          e.preventDefault();
          return self.updateVal(min);
        }
        if (num > max) {
          e.preventDefault();
          return self.updateVal(max);
        }
      },

      /**
       * Event handler for 'keyup' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyup: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // Spinbox Control Button styles are added/removed on keyup.
        switch (key) {
          case 38: case 39:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.down);
            } else {
              self.removeButtonStyle(self.buttons.up);
            }
            break;
          case 37: case 40:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.up);
            } else {
              self.removeButtonStyle(self.buttons.down);
            }
            break;
        }

        self.updateAria(self.element.val());
      },

      /**
       * Change a newly pasted value to this element's min or max values, if the pasted value goes
       * beyond either of those limits.  Listens to an event emitted by the Mask plugin after pasted content
       * is handled.
       * @param {Spinbox} self
       */
      handleAfterPaste: function(self) {
        var min = Number(self.element.attr('min')),
          max = Number(self.element.attr('max')),
          val = Number(self.element.val());

        val = (val < min ? min : (val > max ? max : val));
        self.updateVal(val);
      },

      /**
       * Increases the value of the Spinbox field, constrained by the step interval and maximum limit.
       */
      increaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);
        if (this.element.attr('max') && val > this.element.attr('max')) {
          return;
        }
        this.updateVal(val);
      },

      /**
       * Decreases the value of the Spinbox field, constrained by the step interval and minimum limit.
       */
      decreaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);
        if (this.element.attr('min') && val < this.element.attr('min')) {
          return;
        }
        this.updateVal(val);
      },

      /**
       * Sets a new spinbox value and focuses the spinbox.
       * @param {Number|String} newVal
       */
      updateVal: function(newVal) {
        this.element.val(newVal);
        this.updateAria(newVal);
        this.element.focus();
      },

      /**
       * Sanitizes the value of the input field to an integer if it isn't already established.
       * @param {Number|String} val - will be converted to a number if it's a string.
       * @returns {Number}
       */
      checkForNumeric: function(val) {
        // Allow for NULL
        if (val === '') {
          return val;
        }
        if ($.isNumeric(val)) {
          return Number(val);
        }
        val = parseInt(val);
        if ($.isNumeric(val)) {
          return Number(val);
        }
        // Zero out the value if a number can't be made out of it.
        return 0;
      },

      /**
       * Updates the "aria-valuenow" property on the spinbox element if the value is currently set
       */
      updateAria: function(val) {
        var min = this.element.attr('min'),
          max = this.element.attr('max');

        val = this.checkForNumeric(val);
        this.element.attr('aria-valuenow', (val !== '' ? val : ''));

        // Tougle min/max buttons
        this.setIsDisabled(this.buttons.up, (val !== '' && max && val >= max) ? 'disable' : 'enable');
        this.setIsDisabled(this.buttons.down, (val !== '' && min && val <= min) ? 'disable' : 'enable');
      },

      /**
       * adds a "pressed-in" styling for one of the spinner buttons
       */
      addButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.addClass('is-active');
      },

      /**
       * Removes "pressed-in" styling for one of the spinner buttons
       */
      removeButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.removeClass('is-active');
      },

      /**
       * Enables the Spinbox
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.element.parent('.spinbox-wrapper').removeClass('is-disabled');
      },

      /**
       * Disables the Spinbox
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent('.spinbox-wrapper').addClass('is-disabled');
      },

      /**
       * Determines whether or not the spinbox is disabled.
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Toggle whther or not the component is disabled.
       * @param {jQuery[]} button
       * @param {booelan} isDisabled
       */
      setIsDisabled: function(button, isDisabled) {
        isDisabled = isDisabled === undefined ? true :
          (!isDisabled || isDisabled === 'enable') ? false : true;

        button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
      },

      /**
       * Teardown
       */
      destroy: function() {
        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        for (var button in this.buttons) {
          var buttonAPI = $(button).data('button');

          if (buttonAPI) {
            buttonAPI.destroy();
          }
        }

        this.buttons.up.off('click.spinbox mousedown.spinbox');
        this.buttons.up.remove();
        this.buttons.down.off('click.spinbox mousedown.spinbox');
        this.buttons.down.remove();
        this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
        this.element.unwrap();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @listens Spinbox#events
       * @param {Object} focus  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       * @param {Object} keydown  &nbsp;-&nbsp;
       * @param {Object} keypress  &nbsp;-&nbsp;
       * @param {Object} keyup  &nbsp;-&nbsp;
       * @param {Object} afterpaste  &nbsp;-&nbsp;
       */
      bindEvents: function() {
        var self = this,
          preventClick = false;

        // Main Spinbox Input
        this.element.on('focus.spinbox', function() {
          self.element.parent('.spinbox-wrapper').addClass('is-focused');
        }).on('blur.spinbox', function() {
          self.element.parent('.spinbox-wrapper').removeClass('is-focused');
          // Explicitly trigger the change event if the "original" value is different from its current value.
          // Prevents an issue where changing the value with arrow keys doesn't trigger the "change" event on blur.
          self.element.trigger('change');
        }).on('keydown.spinbox', function(e) {
          self.handleKeyDown(e, self);
        }).on('keypress.spinbox', function(e) {
          self.handleKeyPress(e, self);
        }).on('keyup.spinbox', function(e) {
          self.handleKeyup(e, self);
        }).on('afterpaste.mask', function() {
          self.handleAfterPaste(self);
        });

        // Up and Down Buttons
        var buttons = this.buttons.up.add(this.buttons.down[0]);
        buttons.on('touchstart.spinbox mousedown.spinbox', function(e) {
          if (e.which === 1) {

            if (!preventClick) {
              self.handleClick(e);
            }

            if (self.isTouch) {
              return;
            }

            preventClick = true;
            self.enableLongPress(e, self);

            $(document).one('mouseup', function() {
              self.disableLongPress(e, self);
              preventClick = false;
              self.element.focus();
            });

            //Stop MouseDown From Running
            if (this.isTouch) {
              e.preventDefault();
              e.stopPropagation();
            }
          }
        });

        return this;
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Spinbox(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.splitter = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'splitter',
        defaults = {
          axis: 'x',
          side: 'left', // or right
          resize: 'immediate',
          containment: null, //document or parent
          save: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Splitter(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Splitter.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Build the Control and Events
      build: function() {
        var self = this,
          s = this.settings,
          splitter = this.element,
          parent = splitter.parent(),
          w = parent.width(),
          direction = s.axis === 'x' ? 'left' : 'top',
          thisSide = parent.is('.content') ? parent.parent() : parent,
          parentHeight,
          defaultOffset = 299;

        setTimeout(function() {
          parentHeight = parent.height();
        }, 0);

        this.docBody = $('body');
        this.isSplitterRightSide = splitter.is('.splitter-right') || (s.axis === 'x' && s.side === 'right');
        this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
        s.uniqueId = this.uniqueId();

        if (this.isSplitterRightSide) {
          this.leftSide = thisSide;

          thisSide.addClass('is-right-side')
            .next().addClass('flex-grow-shrink is-right-side')
            .parent().addClass('splitter-container');

          splitter.addClass('splitter-right');

          if (s.collapseButton) {
            var savedOffset = 0;
            var $splitterButton = $('<button type="button" class="splitter-btn" id="splitter-collapse-btn" title="Collapse"><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-double-chevron"></use></svg></button>');
            $splitterButton.appendTo(splitter);
            if (splitter[0].offsetLeft > 10) {
              $('#splitter-collapse-btn').addClass('rotate');
            }
            $('#splitter-collapse-btn').click(function() {
              if (savedOffset <= 0) {
                if (splitter[0].offsetLeft <= 10){
                  self.splitTo(defaultOffset, parentHeight);
                  $(this).addClass('rotate');
                } else {
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                }
              } else {
                if (splitter[0].offsetLeft > 10){
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                } else {
                  self.splitTo(savedOffset, parentHeight);
                  $(this).addClass('rotate');
                  savedOffset = 0;
                }
              }
            });
          }
        }
        else if (this.isSplitterHorizontal) {
          this.topPanel = splitter.prev();
          w = this.topPanel.height();

          parent.addClass('splitter-container is-horizontal');
          splitter.next().addClass('flex-grow-shrink');
          splitter.addClass('splitter-horizontal');
        } else {
          this.rightSide = thisSide;
          this.leftSide = thisSide.prev().parent();

          thisSide.prev()
            .addClass('flex-grow-shrink')
            .parent().addClass('splitter-container');
        }

        //Restore from local storage
        if (localStorage && s.save &&
          !isNaN(parseInt(localStorage[s.uniqueId]))) {
          w = localStorage[s.uniqueId];
        }

        w = parseInt(w);

        if (this.isSplitterHorizontal) {
          splitter[0].style.top = w + 'px';
        } else {
          splitter[0].style.top = 0;
        }

        this.splitTo(w, parentHeight);

        //Add the Splitter Events
        this.documentWidth = 0;

        this.element.drag({
          axis: s.axis,
          containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
          containmentOffset: {left: 20, top: 0}
        })
        .on('dragstart.splitter', function () {
          var iframes = $('iframe');
          self.documentWidth = $(document).width();

          if (iframes.length > 0) {
            for (var i = 0, l = iframes.length; i < l; i++) {
              var frame = $(iframes[i]),
                width = parseInt(getComputedStyle(frame.parent()[0]).width, 10) - 40 +'px';
              frame.before('<div class="overlay" style="opacity: 0; visibility: visible; height: 100%; width: '+ width +'"></div>');
            }
          }
        })
        .on('dragend.splitter', function (e, args) {
          $('.overlay').remove();

          if (s.collapseButton) {
            if (args[direction] <= 10) {
              $('#splitter-collapse-btn').removeClass('rotate');
            } else {
              $('#splitter-collapse-btn').addClass('rotate');
            }
          }

          if (s.resize === 'end') {
            self.splitTo(args[direction], parentHeight);
          }

        })
        .on('drag.splitter', function (e, args) {
          if (args.left <= 0) {
            return false;
          }
          if (s.resize === 'immediate') {
            self.splitTo(args[direction], parentHeight);
          }
        });

        //Horizontal Splitter
        if (s.axis === 'y') {
          this.element.addClass('splitter-horizontal');
        }

        //Aria
        this.element.attr({'aria-dropeffect': 'move', 'tabindex': '0', 'aria-grabbed': 'false'});

        return this;
      },

      toggleSelection: function () {
        this.element.toggleClass('is-dragging');
      },

      //Resize the panel vertically
      resizeTop: function (splitter, top, parentHeight) {
        if (top > parentHeight || top < 0) {
          top = parseInt(parentHeight) / 2;
        }

        this.topPanel[0].style.height = top + 'px';
      },

      //Resize the panel to the Left
      resizeLeft: function (splitter, leftArg) {
        var left = this.leftSide.outerWidth() - leftArg;

        //Adjust Left and Right Side
        this.rightSide[0].style.width = left + 'px';

        //Reset the Width
        splitter[0].style.left = '';
      },

      //Resize the panel to the Right
      resizeRight: function (splitter, w) {
        //Adjust Left and Right Side
        this.leftSide[0].style.width = w + 'px';
        splitter[0].style.left = (w-1) +'px';
      },

      //Preferably use the id, but if none that make one based on the url and count
      uniqueId: function () {
        return this.element.attr('id') ||
          (window.location.pathname.split('/').pop()) + '-splitter-' + $('.splitter').length;
      },

      splitTo: function (split, parentHeight) {
        var self = this,
          splitter = this.element;

        if (this.isSplitterRightSide) {
          this.resizeRight(splitter, split);
        } else if (this.isSplitterHorizontal) {
          this.resizeTop(splitter, split, parentHeight);
        } else {
          this.resizeLeft(splitter, split);
        }

        this.element.trigger('split', [split]);
        this.docBody.triggerHandler('resize', [self]);

        //Save to local storage
        if (localStorage) {
          localStorage[this.settings.uniqueId] = split;
        }

        this.split = split;
        this.parentHeight = parentHeight;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @fires Splitter#events
       * @param {Object} updated  &nbsp;-&nbsp; Fires when the component updates.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a key is pressed while the component is focused.
       */
      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.' + pluginName, function() {
            self.updated();
          })
          .on('keydown.' + pluginName, function(e) {
            //Space will toggle selection
            if (e.which === 32) {
              self.toggleSelection();
              e.preventDefault();
            }

            if (e.which === 37) {
              self.splitTo(self.split - 15, self.parentHeight);
            }

            if (e.which === 39) {
              self.splitTo(self.split + 15, self.parentHeight);
            }
          });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Splitter(this, settings));
      }
    });
  };


  $.fn.stepprocess = function(options) {
    var pluginName = 'stepprocess',
      defaults = {
        linearProgression: false,
        folderIconOpen: 'caret-up',
        folderIconClosed: 'caret-down',
        stepList: '#step-list',
        stepLi: '.js-step',
        stepLink: '.js-step-link',
        stepFolder: '.js-step-folder',
        btnPrev: '.js-step-link-prev',
        btnNext: '.js-step-link-next',
        beforeSelectStep: null,
      },
      settings = $.extend({}, defaults, options);

    /**
     * A Stepprocess/wizard control
     *
     * @param {object} element
     * @param {object[]} [options]
     * @param {boolean} [options.linearProgression=false]                     - Whether to prevent clicking and allow only prev/next navigation of steps
     * @param {string} [options.folderIconOpen="caret-up"]                    - A specific folder open icon
     * @param {string} [options.folderIconClosed="caret-down"]                - A specific folder close icon
     * @param {object} [options.stepList="#step-list"]                        - The ID of the stepList
     * @param {object} [options.stepLi=".js-step"]                            - jQuery selector for the step elements
     * @param {object} [options.stepLink=".js-step-link"]                     - jQuery selector for the step link elements
     * @param {object} [options.stepFolder=".js-step-folder"]                 - jQuery selector for the step folder elements
     * @param {object} [options.btnPrev=".js-step-link-prev"]                 - jQuery selector for the previous step button
     * @param {object} [options.btnNext=".js-step-link-next"]                 - jQuery selector for the next step button
     * @param {function(event, args)|Promise} [options.beforeSelectStep=null] - A callback (function or promise) that gives
     *        args.stepLink (the step link element) and args.isStepping (whether we are prev/next'ing or not)
     */
    function Stepprocess(element) {
      this.element = $(element);
      this.init();
    }

    // Stepprocess Methods
    Stepprocess.prototype = {
      init: function() {
        this.settings = $.extend({}, settings);
        this.$stepList = $(this.settings.stepList);
        this.initStepprocess();
        this.handleKeys();
        this.setupEvents();
        this.focusFirst();
      },

      /** @private  */
      initStepprocess: function() {
        var self = this,
          steps = self.$stepList.find(this.settings.stepLi);

        steps.each(function() {
          self.decorateNode(this);
        });

        var startingStep = $(this.settings.stepLi + '.is-selected');
        var startingStepLink = startingStep.find(this.settings.stepLink);
        this.selectStep(startingStepLink);
      },

       /**
       * @private
       * Set initial attributes on each step its counterparts
       * @param  {object} step - The step element to decorate
       */

      decorateNode: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder),
            isDisabled = $stepLink.hasClass('is-disabled'),
            isOpen = $stepFolder.hasClass('is-open');

        if (isDisabled) {
          $stepLink.attr('aria-disabled','true');
        }

        if ($stepFolder.length) {

          $step.addClass('folder');
          $stepFolder.attr('role', 'group');

          if (isDisabled) {
            $stepFolder.addClass('disabled');

            if (isOpen) {
              $stepFolder.children().each(function() {
                $(this).find(self.settings.stepLink)
                  .addClass('is-disabled')
                  .attr('aria-disabled', 'true');
              });
            }
          }

          $stepLink.attr('aria-expanded', isOpen);
        }

        // parentCount 'aria-level' to the node's level depth
        var parentCount = $stepLink.parentsUntil(this.$stepList, 'ul').length - 1;

        // Set the current stepprocess item node position relative to its aria-setsize
        var posinset = $step.index();

        // Set the current stepprocess item aria-setsize
        var listCount = $step.siblings().addBack().length;

        $stepLink
          .attr({
            'role': 'stepitem',
            'tabindex': '-1',
            'aria-selected': 'false',
            'aria-level': parentCount + 1,
            'aria-posinset': posinset + 1,
            'aria-setsize': listCount,
            'aria-disabled': isDisabled
          })
          .addClass('hide-focus')
          .hideFocus();
      },

       /** @private  */

        /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */

      /** @private  */
      focusFirst: function () {
        this.$stepList.find(this.settings.stepLi + ':first').attr('tabindex', '0');
      },

          /**
       * @private
       * @param  {[type]} step - The step element
       */

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderClose: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder);

        var treeIcon = $stepLink
                        .closest('.folder')
                          .removeClass('is-open')
                          .end()
                        .find('svg.icon-tree');

        this.setIcon(treeIcon, this.settings.folderIconClosed);

        this.isAnimating = true;

        $stepFolder
          .one('animateclosedcomplete', function() {
            $stepFolder.removeClass('is-open');
            self.isAnimating = false;
          })
          .animateClosed();

        $stepLink.attr('aria-expanded', 'false');
      },

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderOpen: function(step) {
        var self = this,
            $step = $(step);

        if (!this.isOpen($step)) {

          var $stepLink = $step.children(this.settings.stepLink),
              $stepFolder = $step.children(this.settings.stepFolder);

          $step.addClass('is-open');
          $stepLink.attr('aria-expanded', 'true');

          var svgElem = $stepLink.find('svg.icon-tree');
          self.setIcon(svgElem, self.settings.folderIconOpen);

          self.isAnimating = true;

          $stepFolder
            .one('animateopencomplete', function() {
              self.isAnimating = false;
            })
            .addClass('is-open')
            .css('height', 0)
            .animateOpen();
        }
      },

      /**
       * @private
       * @param  {[type]} stepLink- Description
       * @return {[type]}     - Description
       */
      folderToggle: function(stepLink) {
        var $step = stepLink.closest(this.settings.stepLi);

        if (this.isFolder($step)) {
          var $stepFolder = $step.children(this.settings.stepFolder);
          if (this.isOpen($stepFolder)) {
            this.folderClose($step);
          } else {
            this.folderOpen($step);
          }
        }
      },


       /**
       * @private
       * @return {object} - the "step" element
       */

      /**
       * @private
       * @return {object}
       */
      getSelectedStep: function () {
        return $(this.settings.stepLi + '.is-selected', this.$stepList);
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getNextNode: function(stepLink) {
        var next = stepLink.parent().next().find(this.settings.stepLink + ':first');
        var $nextStep = next.closest(this.settings.stepLi);

        // Possibly Move Into Children
        if (stepLink.next().is(this.settings.stepFolder) && stepLink.next().hasClass('is-open')) {
          next = stepLink.next().find(this.settings.stepLink + ':first');
        }

        //skip disabled
        if(next.hasClass('is-disabled')) {
          next = $nextStep.next().find(this.settings.stepLink + ':first');
        }

        //bottom of a group..{l=2: max folders to be deep }
        if (next.length === 0) {
          for (var i=0, l=2, closest=stepLink; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find(this.settings.stepLink + ':first');
            if (next.length) {
              break;
            }
          }
        }
        return next;
      },
       /**
       * @private
       * Get the next step in the tree
       * (not to be confused with getNextNode, which includes folders)
       * @return {object}
       */

      /**
       * @private
       * @return {object}
       */
      getNextStep: function() {
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink),
            $curStepFolder = $curStep.next(this.settings.stepFolder),
            $nextStepLink = this.getNextNode($curStepLink),
            $nextStepFolder = $nextStepLink.next(this.settings.stepFolder),
            stepLinkToSelect = null,
            theFolder = null;

        if ($curStepFolder.length) {
          // Select the first node of the current folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $curStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else if ($nextStepFolder.length) {
          // Select the first node of the next node's folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $nextStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else {
          // Neither folders options work so select the next node
          stepLinkToSelect = $nextStepLink;
        }

        return stepLinkToSelect;
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getPreviousNode: function(stepLink) {
        var prev = stepLink.parent().prev().find(this.settings.stepLink + ':first');
        var $prevStep = prev.closest(this.settings.stepLi);

        //move into children at bottom
        if ($prevStep.is('.folder.is-open') &&
            $prevStep.find('ul.is-open a').length &&
            !$prevStep.find('ul.is-disabled').length) {
          prev = $prevStep.find('ul.is-open ' + this.settings.stepLink + ':last');
        }

        //skip disabled
        if(prev.hasClass('is-disabled')) {
          prev = $prevStep.prev().find(this.settings.stepLink + ':first');
        }

        //top of a group
        if (prev.length === 0) {
          prev = stepLink.closest(this.settings.stepFolder).prev(this.settings.stepLink);
        }
        return prev;
      },

      /**
       * @private
       * Get the previous step in the tree
       * (not to be confused with getPreviousNode, which includes folders)
       * @return {object}
       */
      getPreviousStep: function() {
        // Get the currently select node
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink);

        // Get the previous step to switch to
        var $prevStepLink = this.getPreviousNode($curStepLink),
            $prevStep = $prevStepLink.closest(this.settings.stepLi),
            stepLinkToSelect = $prevStepLink;

        // If we are moving upwards and hit a folder title step
        if (this.isFolder($prevStep)) {

          if (this.isOpen($prevStep)) {
            // If the folder is open, and we got here, that means we
            // were currently at the first step in the folder and need to
            // go to the prev step above the folder step (aka the prev to the prev)
            stepLinkToSelect = this.getPreviousNode($prevStepLink);

          } else {
            var theFolder = $prevStep.children(this.settings.stepFolder);

            if (theFolder.children().length) {
              stepLinkToSelect = theFolder.find(this.settings.stepLink).last();
            }
          }
        }

        return stepLinkToSelect;
      },

      /**
       * Go to the next step element
       */
      goToNextStep: function() {
        var stepLink = this.getNextStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'next');
        }
      },

      /**
       * Go to the previous step element
       */
      goToPreviousStep: function() {
        var stepLink = this.getPreviousStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'prev');
        }
      },

      /**
       * @private
       * Key Behavior as per:
       * http://access.aol.com/dhtml-style-guide-working-group/#treeview
       */
      handleKeys: function () {
        var self = this;

        this.$stepList.on('focus.stepprocess', this.settings.stepLink, function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.stepprocess');
              e.keyCode= 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        // Handle Up/Down Arrow Keys and Space
        this.$stepList.on('keydown.stepprocess', this.settings.stepLink, function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.stepprocess');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              } else {
                self.folderToggle(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                prev = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                next = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(next);
              } else {
                self.folderToggle(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          // Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.$stepList.find(self.settings.stepLink + ':first:visible');
            self.setFocus(next);
          }

          // End (fn-right on mac)
          if (charCode === 35) {
            next = self.$stepList.find(self.settings.stepLink + ':last:visible');
            self.setFocus(next);
          }

        });

        // Handle Left/Right Arrow Keys
        this.$stepList.on('keypress.stepprocess', this.settings.stepLink, function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest(self.settings.stepLi).nextAll().find('.js-step-link:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }
        });
      },

      /**
       * @private
       * @param  {[type]}  step - The step Li element
       * @return {Boolean}
       */
      isFolder: function(step) {
        return $(step).hasClass('folder');
      },

      /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */
      isInFolder: function(step) {
        return $(step).closest(this.settings.stepFolder, this.$stepList).length;
      },

      /**
       * @private
       * @param  {object}  stepFolder - The step folder element
       * @return {boolean}
       */
      isOpen: function(stepFolder) {
        return $(stepFolder).hasClass('is-open');
      },

      /**
       * @private
       * @param {object} stepLink
       */
      setFocus: function (stepLink) {
        stepLink.focus();
      },

      /**
       * @private
       * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
       * @param {string} svg
       * @param {string} icon
       */
      setIcon: function(svg, icon) {
        var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

        /**
       * Select a step
       * @param  {object} stepLink - The jquery object for the step link element
       * @param  {string} [linearDirection=none|previous|next] - Which direction we are traveling
       */
      selectStep: function (stepLink, linearDirection) {
        var self = this;
        if (linearDirection === undefined) {
          linearDirection = 'none';
        }

        // Possibly Call the beforeSelectStep
        var result;
        if (typeof self.settings.beforeSelectStep === 'function') {

          var args = {
            stepLink: stepLink,
            isStepping: linearDirection
          };
          result = self.settings.beforeSelectStep(args);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode, stepLinkToSelect) {
              if (continueSelectNode) {
                if (stepLinkToSelect) {
                  stepLink = stepLinkToSelect;
                }
                self.selectStepFinish(stepLink, linearDirection);
              }
            });
          } else if (result) { // boolean is returned instead of a promise
            self.selectStepFinish(stepLink, linearDirection);
          }

        } else { // No Callback specified
          self.selectStepFinish(stepLink, linearDirection);
        }
      },

      /**
       * @private
       * Finishes selecting a step
       * @param  {object} stepLink - Description
       * @param  {string} [linearDirection=previous|next] - Description
       *
       */
      selectStepFinish: function(stepLink, linearDirection) {
        var self = this,
            $allStepLinks = $(this.settings.stepLink, this.$stepList),
            $step = stepLink.closest(this.settings.stepLi);

        $allStepLinks
          .attr({
            'tabindex': '-1',
            'aria-selected': 'false'
          })
          .parent().removeClass('is-selected');

        stepLink.attr({
          'tabindex': '0',
          'aria-selected': 'true'
        });

        $step.addClass('is-selected');

        if (this.isFolder($step)) {
          // It is a folder
          if (linearDirection === 'none') {
            this.folderToggle($step); // clicking toggles
          } else {
            this.folderOpen($step); // going prev/next always opens
          }
        } else {
          // Its not a folder
          var parentIsFolder = $step.closest(this.settings.stepFolder, this.$stepList);

          if (parentIsFolder.length) {
            // If the step is in a folder, make sure that folder opens
            this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
          }

          // Show the step's panel
          this.showStepPanel(stepLink.attr('href'));
        }
        stepLink.focus();

        setTimeout(function() {
          self.element.triggerHandler('selected', stepLink);
        }, 0);
      },

      /**
       * @private
       * @param  {object} step - The step element to decorate
       */
      unSelectedNode: function (step) {
        var aTags = $(this.settings.stepLink, this.$stepList),
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink);

        aTags.attr('tabindex', '-1');
        $stepLink.attr('tabindex', '0');

        $step.removeClass('is-selected');
        $stepLink.attr('aria-selected', 'false');
      },

      /**
       * @private
       * @return {[type]}- Description
       */
      setupEvents: function () {
        var self = this;

        // Updated and Click events
        self.$stepList
          .on('updated.stepprocess', function () {
            self.initStepprocess();
          })
          .on('click.stepprocess', self.settings.stepLink + ':not(.is-clone)', function (e) {
            e.preventDefault();

            if (!self.settings.linearProgression) {
              var $target = $(this);

              if (!$target.is('.is-disabled, .is-loading')) {
                self.selectStep($target);
                e.stopPropagation();
              }
            }
          });

        // Next Button Click
        $(this.settings.btnPrev).on('click', function(e) {
          e.preventDefault();
          self.goToPreviousStep.call(self);
        });

        // Previous Button Click
        $(this.settings.btnNext).on('click', function(e) {
          e.preventDefault();
          self.goToNextStep.call(self);
        });

        // Setup main scrolling
        $(this.settings.contentScroll).scrollaction({
          scrollActionTarget: '.main'
        });

        // Setup sidebar scrolling
        $(this.settings.stepListScroll).scrollaction({
          scrollActionTarget: '.sidebar'
        });

        // Toggle sidebar
        // Button to toggle the tree in responsive view
        $('.js-toggle-sidebar').click(function(e) {
          e.preventDefault();
          self.element
            .toggleClass('tablet-hide-steps')
            .toggleClass('phone-hide-steps');
        });
      },

      /**
       * @private
       * Show the content panel for the step
       * @param  {string} contentId - The contentId to show
       */
      showStepPanel: function(contentId) {
        $('.step-panel-active').removeClass('step-panel-active');
        $(contentId).addClass('step-panel-active');
        this.element.addClass('phone-hide-steps');
      },

      /** @private */
      destroy: function() {
        this.$stepList.removeData(pluginName);
        this.$stepList.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Stepprocess(this, settings));
      }
    });

  };


  $.fn.swaplist = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'swaplist',
        defaults = {
          // Datasets
          'available': null,
          'selected': null,
          'additional': null,

          // Main containers
          'availableClass': '.available',
          'selectedClass': '.selected',
          'additionalClass': '.full-access',

          // Action buttons
          'availableBtn': '.btn-moveto-selected',
          'selectedBtnLeft': '.btn-moveto-left',
          'selectedBtnRight': '.btn-moveto-right',
          'additionalBtn': '.btn-moveto-selected',

          // Template HTML
          'template': ''+
            '<ul data-swap-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="swaplist-item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>'
        },
        settings = $.extend({}, defaults, options);

    /**
    * The SwapList Component creates a list of options that can be picked and organized.
    *
    * @class SwapList
    * @param {Array} available &nbsp;-&nbsp; An array containing items for the available bucket.
    * @param {Array} selected  &nbsp;-&nbsp;  An array containing items for the selected bucket.
    * @param {Array} additional  &nbsp;-&nbsp;  An array containing items for the additional bucket.
    * @param {String} availableClass  &nbsp;-&nbsp; A class name linking the available root element.
    * @param {String} selectedClass  &nbsp;-&nbsp; A class name linking the selected root element.
    * @param {String} additionalClass &nbsp;-&nbsp; A class name linking the additional root element.
    * @param {String} availableBtn &nbsp;-&nbsp; A class name linking the available button element.
    * @param {String} selectedBtnLeft &nbsp;-&nbsp;  A class name linking the move left button element.
    * @param {String} selectedBtnRight &nbsp;-&nbsp;  A class name linking the move right button element.
    * @param {String} additionalBtn &nbsp;-&nbsp;  A class name linking the additional button element.
    * @param {String} template &nbsp;-&nbsp; An Html String with the mustache template for the view.
    */
    function SwapList(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // SwapList Methods
    SwapList.prototype = {

      init: function() {
        var self = this,
          s = self.settings;
        self.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        self.isAdditional = $(s.additionalClass +' .listview', self.element).length > 0;

        if (self.isTouch) {
          self.element.addClass('is-touch');
        }
        self.loadListview();
        self.initDataset();
        self.setElements();
        self.isMultiSelectClass();

        setTimeout(function() { // Wait for Listview availability
          self.makeDraggable();
          self.handleEvents();
          self.initSelected(s.availableClass);
          self.initSelected(s.additionalClass);
        }, 0);
      },

      /**
       * Load listview
       * @private
       */
      loadListview: function() {
        var i, l, lv, c,
          self = this,
          s = self.settings,
          containers = [
            { dataset: s.available, class: s.availableClass },
            { dataset: s.selected, class: s.selectedClass },
            { dataset: s.additional, class: s.additionalClass }
          ];

        for (i=0,l=containers.length; i<l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          if (!c.dataset && lv.length && $('li', lv).length) {
            lv.listview({ selectable: 'multiple' });
          }
          else if (lv.length) {
            lv.listview({ dataset: (c.dataset || []), template: s.template, selectable: 'multiple' });
          }
        }
      },


      /**
       * Set elements
       * @private
       */
      setElements: function() {
        this.offset = null;

        this.containers = $(
          this.settings.availableClass +','+
          this.settings.selectedClass +','+
          this.settings.additionalClass, this.element);

        this.actionButtons = $(
          this.settings.availableBtn +','+
          this.settings.additionalBtn +','+
          this.settings.selectedBtnLeft +','+
          this.settings.selectedBtnRight, this.element);

        this.selectedButtons = $(
          this.settings.selectedBtnLeft +','+
          this.settings.selectedBtnRight, this.element);

        this.tabButtonsStr = ''+
          this.settings.availableBtn +' '+
          this.settings.additionalBtn +' '+
          (this.selectedButtons.length > 1 ?
            this.settings.selectedBtnRight : this.settings.selectedBtnLeft);

        this.dragElements = 'ul, li:not(.is-disabled)';
        this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
        this.dragEnterWhileDragging = 'dragenter.swaplist';
        this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
        this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';

        this.selections = {
          'items': [],
          'owner': null,
          'related': null,
          'droptarget': null,
          'isInSelection': null,
          'isHandle': null,
          'placeholder': null,
          'placeholderTouch': null,
          'dragged': null,
          'draggedIndex': null
        };

        // Dragging time placeholder
        this.settings.numOfSelectionsClass = 'num-of-selections';
        this.settings.itemContentClass = 'swaplist-item-content';
        this.settings.itemContentTempl = $(
          '<div><p><span class="'+ this.settings.numOfSelectionsClass +'">###</span> '+
            Locale.translate('ItemsSelected') +'</p><div/>'
        );
      },

      /**
       * When list is Empty force to add css class "is-muliselect"
       * @private
       */
      isMultiSelectClass: function() {
        var i, l, lv,
          s = this.settings,
          containers = [s.availableClass, s.selectedClass, s.additionalClass];

        for (i=0,l=containers.length; i<l; i++) {
          lv = $(containers[i] +' .listview', this.element);
          if (!$('li', lv).length) {
            lv.addClass('is-muliselect');
          }
        }
      },

      /**
       * Initialize pre selected items
       * @private
       * @param {jQuery|HTMLElement} container
       */
      initSelected: function(container) {
        var list;
        container = this.isjQuery(container) ? container : $(container, this.element);
        if (container.length) {
          list = $('.listview', container).data('listview');
          $('li[selected]', container).each(function() {
            $(this).removeAttr('selected');
            list.select($(this));// Select this item
          });
          this.moveElements(container, this.settings.selectedClass);
          $(this.settings.selectedClass +' li:last-child', this.element).blur();
        }
      },

      /**
       * Move Elements
       * @private
       * @param {jQuery[]|HTMLElement} from
       * @param {jQuery[]|HTMLElement} to
       */
      moveElements: function(from, to) {
        var ul, size, currentSize,
          self = this, list;

        from = (typeof from !== 'string') ? from : $(from, self.element);
        to = (typeof to !== 'string') ? to : $(to, self.element);
        list = $('.listview', from).data('listview');

        self.clearSelections();
        self.selections.owner = from;
        self.selections.droptarget = to;

        if (self.isTouch) {
          $.each(list.selectedItems, function(index, val) {
            self.selections.items[index] = val.closest('li');
          });
        } else {
          self.selections.items = list.selectedItems;
        }

        self.setSelectionsItems(self.selections.owner);
        self.unselectElements(list);

        if (self.selections.items.length) {
          self.element.triggerHandler('beforeswap', [self.selections.itemsData]);

          ul = $('ul', to);
          currentSize = $('li', ul).length;
          size = self.selections.items.length + currentSize;

          $.each(self.selections.items, function(index, val) {
            val = $(val);
            val.attr({ 'aria-posinset': currentSize + index + 1, 'aria-setsize': size });
            ul.append(val);
            val.focus();
          });

          self.afterUpdate($('.listview', to).data('listview'));
        }
      },

      /**
       * Un-select Elements
       * @private
       * @param {jQuery|HTMLElement} list
       */
      unselectElements: function(list) {
        $.each(list.selectedItems, function(index, val) {
          list.select(val);
        });
      },

      /**
       * Detect browser support for drag-n-drop
       * @private
       * @returns {boolean}
       */
      isDragAndDropSupports: function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
      },

      /**
       * Detect browser support for match-media
       * @private
       * @returns {boolean}
       */
      isMatchMediaSupports: function() {
        return (typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined');
      },

      /**
       * Detect browser viewport
       * @private
       * @returns {Object}
       */
      viewport: function() {
        var e = window, a = 'inner';
        if (!('innerWidth' in window)) {
          a = 'client';
          e = document.documentElement || document.body;
        }
        return { width : e[a+'Width'] , height : e[a+'Height'] };
      },

      /**
       * Check given [max-width] is true/false
       * @private
       * @returns {boolean}
       */
      isMaxWidth: function(w) {
        return ((this.isMatchMediaSupports() && window.matchMedia('(max-width: '+ w +'px)').matches) || this.viewport().width <= w);
      },

      /**
       * Make Draggable
       * @private
       */
      makeDraggable: function() {
        var self = this,
          ul = $('ul', self.element);

        if (self.isDragAndDropSupports) {
          // Use Handle if available
          self.handle = ul.first().attr('data-swap-handle');
          self.handle = $(self.handle, ul).length > 0 ? self.handle : null;
          // self.handle = (!self.isTouch && $(self.handle, ul).length > 0) ? self.handle : null;
          $(self.handle, ul).addClass('draggable')
            .off('mousedown.swaplist touchstart.swaplist')
            .on('mousedown.swaplist touchstart.swaplist', function() { self.selections.isHandle = true; })
            .off('mouseup.swaplist touchend.swaplist')
            .on('mouseup.swaplist touchend.swaplist', function() { self.selections.isHandle = false; });

          self.targets = ul.attr({'aria-dropeffect': 'none'});

          self.items = $('li:not(.is-disabled)', self.element)
            .not('a[href], img')
              .off('selectstart.swaplist')
              .on('selectstart.swaplist', function() {
              if (this.dragDrop) { this.dragDrop(); } //ie9
              return false;
            }).end()
            .attr({'draggable': true})
            .addClass(self.handle ? '' : 'draggable');
        }
      },

      /**
       * Get Element By Touch In List
       * @private
       * @param {jQuery|HTMLElement} list
       * @param {Number} x
       * @param {Number} y
       */
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      /**
       * Drag touch element
       * @private
       * @param {jQuery.Event} e
       * @param {jQuery[]} elm
       */
      draggTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      /**
       * Shorctut for testing whether a modifier is pressed
       * @private
       * @returns {boolean}
       */
      hasModifier: function(e) {
        return (e.ctrlKey || e.metaKey || e.shiftKey);
      },

      /**
       * Applying dropeffect to the target containers
       * @private
       */
      addDropeffects: function() {
        this.targets.each(function() {
          $(this).attr({'aria-dropeffect': 'move', 'tabindex': 0});
        });
        $.each(this.selections.items, function(index, val) {
          $(val).attr({'aria-grabbed': true, 'tabindex': 0});
        });
      },

      /**
       * Removing dropeffect from the target containers
       * @private
       */
      clearDropeffects: function() {
        this.targets.attr({'aria-dropeffect': 'none'}).removeAttr('tabindex');
        $.each(this.selections.items, function(index, val) {
          val = $(val);
          val.removeAttr('aria-grabbed' + (!val.is(':focus') ? ' tabindex' : ''));
        });
      },

      /**
       * Clear selections
       * @private
       */
      clearSelections: function() {
        this.selections.items = [];
        this.selections.itemsData = [];
        this.selections.owner = null;
        this.selections.related = null;
        this.selections.droptarget = null;
        this.selections.isInSelection = null;
        this.selections.dragged = null;
        this.selections.placeholder = null;
        this.selections.placeholderTouch = null;
        $('ul, li', this.element).removeClass('over');
        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      },

      /**
       * Set selections items
       * @private
       * @param {jQuery[]|HTMLElement} container
       */
      setSelectionsItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        var nodes = $('.listview li', container),
          dataList = this.getDataList(container);
        for (var i=0,l=nodes.length; i<l; i++) {
          var li = $(nodes[i]);
          if (li.is('.is-selected')) {
            this.selections.itemsData.push(dataList[i]);
          }
        }
      },

      /**
       * Init dataset
       * @private
       */
      initDataset: function() {
        var s = this.settings,
          containers = [
            {type: 'available', dataset: s.available, class: s.availableClass},
            {type: 'selected', dataset: s.selected, class: s.selectedClass},
            {type: 'additional', dataset: s.additional, class: s.additionalClass}
          ];

        this.dataset = {'available': [], 'selected': []};
        if (this.isAdditional) {
          this.dataset.additional = [];
        }

        for (var i=0,l=containers.length; i<l; i++) {
          var c = containers[i],
            nodes = $(c.class +' .listview li', this.element);
          for (var nodeIndex=0,l2=nodes.length; nodeIndex<l2; nodeIndex++) {
            var data, value,
              li = $(nodes[nodeIndex]);
            if (c.dataset) {
              // Make sure it's not reference pointer to data object, make copy of data
              data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
              delete data.selected;
            }
            else {
              data = {text: $.trim($('.swaplist-item-content', li).text())};
              value = li.attr('data-value');
              if (value) {
                data.value = value;
              }
            }
            if (this.dataset[c.type]) {
              data.node = li;
              this.dataset[c.type].push(data);
            }
          }
        }
      },

      /**
       * Get data list
       * @private
       * @param {jQuery[]|HTMLElement} container
       * @returns {Object}
       */
      getDataList: function(container) {
        var s = this.settings,
          d = this.dataset;
        container = this.isjQuery(container) ? container : $(container, this.element);
        return container.is(s.additionalClass) ? d.additional :
          (container.is(s.selectedClass) ? d.selected :
            (container.is(s.availableClass) ? d.available : []));
      },

      /**
       * Move an array element position
       * @private
       * @param {Array} arr
       * @param {Number} from
       * @param {Number} to
       */
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      /**
       * Sync dataset
       * @private
       * @param {} owner
       * @param {jQuery[]} droptarget
       */
      syncDataset: function(owner, droptarget) {
        var droptargetNodes = $('.listview li', droptarget),
          ownerDataList = this.getDataList(owner),
          dtDataList = this.getDataList(droptarget);

        for (var i=0,l=this.selections.items.length; i<l; i++) {
          var item = this.selections.items[i];
          for (var dtIndex=0,l2=droptargetNodes.length; dtIndex<l2; dtIndex++) {
            if ($(droptargetNodes[dtIndex]).is(item)) {
              for (var ownerIndex=0,l3=ownerDataList.length; ownerIndex<l3; ownerIndex++) {
                var ownerItem = ownerDataList[ownerIndex];
                if (ownerItem.node && ownerItem.node.is(item)) {
                  dtDataList.push(ownerItem);
                  ownerDataList.splice(ownerIndex, 1);
                  this.arrayIndexMove(dtDataList, dtDataList.length-1, dtIndex);
                  break;
                }
              }
            }
          }
        }
      },

      /**
       * Check if a object is jQuery object
       * @private
       * @param {Object} obj - the object being checked
       */
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      /**
       * Update attributes
       * @private
       * @param {jQuery[]} list
       */
      updateAttributes: function(list) {
        var items = $('li', list),
          size = items.length;

        items.each(function(i) {
          $(this).attr({ 'aria-posinset': i+1, 'aria-setsize': size });
        });
      },

      /**
       * After update
       * @private
       * @param {jQuery[]} list
       */
      afterUpdate: function(list) {
        var self = this;

        setTimeout(function() {
          if (list) {
            if (self.selections.placeholder) {
              list.select(self.selections.placeholder);
              self.selections.placeholder.focus();
            }
            self.unselectElements(list);
            self.syncDataset(self.selections.owner, self.selections.droptarget);
            self.updateAttributes($('.listview', self.selections.owner));
            self.updateAttributes($('.listview', self.selections.droptarget));
            if (self.selections.items.length) {
              self.element.triggerHandler('swapupdate', [self.selections.itemsData]);
            }
          }
          self.clearDropeffects();
          self.clearSelections();
          self.items.removeClass('is-dragging is-dragging-touch');
        }, 100);
      },

      /**
       * Get items from provided container
       * @private
       * @param {jQuery[]|HTMLElement} container
       * @returns {Object}
       */
      getItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        return this.getDataList(container);
      },

      /**
        * Get the current representative dataset with only the available elements in it.
       */
      getAvailable: function() {
        return this.getDataList(this.settings.availableClass);
      },

      /**
       * Get the current representative dataset with only the selected elements in it.
       */
      getSelected: function() {
        return this.getDataList(this.settings.selectedClass);
      },

      /**
       * Get the current representative dataset with only the additional elements in it.
       */
      getAdditional: function() {
        return this.getDataList(this.settings.additionalClass);
      },

      /**
       * Make selected if dragged element was not selected
       * @private
       * @param {Object} list
       * @param {jQuery[]} target
       */
      draggedMakeSelected: function(list, target) {
        var self = this, isInSelection = false;
        if (!self.selections.isInSelection) {
          // Check if dragged element was selected or not
          $.each(list.selectedItems, function(index, val) {
            if (target[0] === val[0]) {
              isInSelection = true;
              return false;
            }
          });
          if (!isInSelection) {
            list.select(target); // Make selected
            self.selections.isInSelection = true;
          }
        }
      },

      /**
       * Updates the internal datasets and refresh the ui.
       * @param {Object} ds &nbsp;-&nbsp; The updated dataset(s) of the form `{available: [], selected: [], additional: []}`
       */
      updateDataset: function(ds) {
        var i, l, lv, c, api,
          self = this,
          s = self.settings,
          containers = [
            { type: 'available', dataset: ds.available, class: s.availableClass },
            { type: 'selected', dataset: ds.selected, class: s.selectedClass },
            { type: 'additional', dataset: ds.additional, class: s.additionalClass }
          ];

        for (i = 0, l = containers.length; i < l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          api = lv.data('listview');

          if (api) {
            api.unselectRowsBetweenIndexes([0, $('li', lv).length - 1]);
            s[c.type] = c.dataset || [];
            api.loadData(s[c.type]);
          }
        }

        self.initDataset();
        self.makeDraggable();
        self.initSelected(s.availableClass);
        self.initSelected(s.additionalClass);
      },

      /**
       * Removes event bindings from the swaplist instance.
       * @private
       * @returns {this}
       */
      unbind: function() {
        this.actionButtons.off('click.swaplist');
        this.containers.off('keydown.swaplist');
        this.selectedButtons.off('keydown.swaplist');
        this.element.off(this.dragStart+' '+this.dragEnterWhileDragging +' '+this.dragOverWhileDragging +' '+this.dragEnd, this.dragElements);

        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
        return this;
      },

      /**
       * Updates this instance of the swaplist component with new settings.
       * @private
       * @returns {this}
       */
      updated: function() {
        return this
          .unbind()
          .init();
      },

      /**
       * Destroys this instance of the swaplist component and removes its link to its base element.
       */
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @fires Swaplist#events
      * @param {Object} swapupdate &nbsp;-&nbsp; Fires when any bucket has its content changed.
       */
      handleEvents: function() {
        var self = this,
          settings = self.settings,
          selections = self.selections;

        // TOP BUTTONS =============================================================================
        self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
          var actionButton = $(this),
            container = actionButton.closest('.card'); // Current list clicked from

          if (container.is(settings.availableClass)) { // Move from Available to Selected
            self.moveElements(settings.availableClass, settings.selectedClass);
          }

          else if (container.is(settings.additionalClass)) { // Move from Additional to Selected
            self.moveElements(settings.additionalClass, settings.selectedClass);
          }

          // Move from Selected
          else if (container.is(settings.selectedClass)) {
            if (actionButton.is(settings.selectedBtnLeft)) { // to Available
              self.moveElements(settings.selectedClass, settings.availableClass);
            }
            else if (actionButton.is(settings.selectedBtnRight)) { // to Additional
              self.moveElements(settings.selectedClass, settings.additionalClass);
            }
          }
        });


        // KEYSTROKE ===============================================================================
        // Keydown event to implement selections
        self.containers.on('keydown.swaplist', function(e) {
          var container = $(this);
          e = e || window.event;
          if (e.keyCode === 77 && self.hasModifier(e)) { // Modifier + M
            if (!container.is(settings.selectedClass) ||
              (container.is(settings.selectedClass) && self.selectedButtons.length === 1)) {
              container.find(self.actionButtons).trigger('click.swaplist');
            } else {
              self.selectedButtons.first().focus();
            }
            e.preventDefault();
          }
        });

        // Keydown event to handle selected container
        self.selectedButtons.on('keydown.swaplist', function(e) {
          var btn = $(this), index, move;
          e = e || window.event;
          if (e.keyCode === 13 || e.keyCode === 32) { // Enter or Space
            btn.trigger('click.swaplist');
            e.preventDefault();
          }
          // Left or Right arrow
          if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
            index = self.selectedButtons.index(this);
            move = e.keyCode === 37 ?
              (index > 0 ? index-1 : self.selectedButtons.length-1) :
              (index < self.selectedButtons.length-1 ? index+1 : 0);
            self.selectedButtons[move].focus();
          }
        });

        self.element.on('keydown.swaplist', self.tabButtonsStr, function(e) {
          var btn = $(this),
            keyCode = e.keyCode || e.which;

          if (keyCode === 9 && !e.shiftKey) { // Tab key
            $('li:first-child', btn.closest('.card')).focus();
            e.preventDefault();
          }
        });


        // DRAGGABLE ===============================================================================
        self.element
        .on('mousedown.swaplist', self.dragElements, function(e) {
          if (self.handle) {
            var target = $(e.target).closest('li');
            target.attr({ 'draggable': $(e.target).is('.draggable') });
          }
          e.stopPropagation();
        })
        .onTouchClick('swaplist', self.dragElements)

        // Dragstart - initiate dragging
        .on(self.dragStart, self.dragElements, function(e) {
          e.stopImmediatePropagation();
          if (self.handle && !selections.isHandle) {
            e.stopPropagation();
            return;
          }
          var rect, touch, placeholderContainer,
            target = $(e.target).closest('li'),
            list = $('.listview', target.closest('.card')).data('listview');

          // Not in draging area
          if (!list) {
            return;
          }

          if (!self.isTouch) {
            self.draggedMakeSelected(list, target);
          }

          self.clearSelections(); // Clear selection before fill

          selections.owner = target.closest('.card');
          selections.dragged = target;
          selections.draggedIndex = target.index();
          selections.placeholder = target.clone(true);
          selections.placeholder.attr('id', 'sl-placeholder');

          self.setSelectionsItems(selections.owner);

          selections.items = list.selectedItems;
          self.element.triggerHandler('beforeswap', [selections.itemsData]);

          $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
          self.addDropeffects();

          if (!self.isTouch) {
            selections.dragged.addClass('is-dragging');
            e.originalEvent.dataTransfer.setData('text', '');

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, selections.dragged).html(settings.itemContentTempl.html());
            }
          }
          else {
            rect = target[0].getBoundingClientRect();
            touch = e.originalEvent.changedTouches[0];

            //Save offset
            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };

            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '1';
            }
            selections.placeholderTouch = selections.dragged.clone(true);

            if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
              selections.dragged.clone()
                .addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2')
                .insertBefore(selections.dragged)
                .hide();
            }
            selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide();

            // Mobile view with three container(available, selected, additional) prepend to parent
            placeholderContainer = (self.element.is('.one-third') && self.isMaxWidth(766)) ? self.element.parent() : self.element;
            placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');

            $('#sl-placeholder-container').append(selections.placeholderTouch);
            $('#sl-placeholder-container')[0].style.width = selections.owner.width() +'px';
            $('#sl-placeholder-touch')[0].style.width = selections.owner.width() +'px';

            self.draggTouchElement(e, selections.placeholderTouch);
          }
          e.stopPropagation();
        })

        // Dragenter - set that related/droptarget
        .on(self.dragEnterWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          self.element.triggerHandler('draggingswap', [selections.itemsData]);
          selections.related = e.target;
          $('ul, li', self.element).removeClass('over');
          $(e.target).closest('ul, li').addClass('over');
          selections.droptarget = $(selections.related).closest('.card');
          $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
          e.stopPropagation();
        })

        // Dragover - allow the drag by preventing default, for touch set related/droptarget
        .on(self.dragOverWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var touch,
            overItem = $(this),
            list = $('.listview', selections.dragged.closest('.card')).data('listview');

          if (self.isTouch) {
            if (!!self.handle && !selections.isHandle) {
              return;
            }

            if (!selections.isInSelection) {
              self.draggedMakeSelected(list, selections.dragged);
              selections.items = list.selectedItems;
              $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
            }

            touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;

            selections.dragged.addClass('is-dragging');
            selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
            selections.placeholderTouch.show();

            $('[aria-grabbed="true"]', self.element)
              .not(selections.dragged)
              .not(selections.placeholderTouch)
              .not('#sl-placeholder-touch2')
              .slideUp();

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, (selections.placeholderTouch.add('#sl-placeholder-touch2')))
                .html(settings.itemContentTempl.html());

              $('#sl-placeholder-touch2').show();
              selections.dragged.hide();
            }
            self.draggTouchElement(e, selections.placeholderTouch);

            self.element.triggerHandler('draggingswap', [selections.itemsData]);
            selections.related = overItem;
            $('ul, li', this.element).removeClass('over');
            overItem.closest('ul, li').addClass('over');
            selections.droptarget = selections.related.closest('.card');
          }
          e.preventDefault();
          e.stopPropagation();
        })

        // Dragend - implement items being validly dropped into targets
        .on(self.dragEnd, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var related = $(selections.related).closest('li'),
          ul = $('ul', selections.droptarget),
          currentSize = $('li', ul).length,
          size = selections.items.length + currentSize;

          self.unselectElements($('.listview', selections.owner).data('listview'));

          $.each(selections.items, function(index, val) {
            val = $(val);
            if (currentSize && !$(selections.related).is('ul')) {
              var isLess = (related.index() < selections.draggedIndex),
                el = isLess ? val : $(selections.items[(selections.items.length-1) - index]),
                posinset = related.index()+(isLess ? index+1 : index+2);

              val.attr({ 'aria-posinset': posinset, 'aria-setsize': size });
              related[isLess ? 'before' : 'after'](el);

            } else {
              val.attr({ 'aria-posinset': currentSize+index+1, 'aria-setsize': size });
              ul.append(val);
            }
            val.focus();
          });

          if (selections.items.length > 1) {
            $('.'+ settings.itemContentClass, selections.dragged).html(
              $('.'+ settings.itemContentClass, selections.placeholder).html()
            );
            if (self.isTouch) {
              selections.dragged.show();
            }
          }

          if (self.isTouch) {
            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '';
            }
          }

          selections.isHandle = null;
          $('[aria-grabbed="true"]', self.element).show();
          self.afterUpdate($('.listview', selections.droptarget).data('listview'));
          e.preventDefault();
          e.stopPropagation();
        });
      } // END: Handle Events ---------------------------------------------------------------------

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SwapList(this, settings));
      }
    });
  };


  $.fn.toast = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toast',
        defaults = {
          title: '(Title)',
          message: '(Content)',
          position: 'top right',  //top left, bottom left, bottom right (center??)
          audibleOnly: false,
          progressBar: true,
          timeout: 6000
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Toast(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Toast Methods
    Toast.prototype = {

      init: function() {
        this.settings = settings;
        this.show();
      },

      // Show a Single Toast Message
      show: function() {
        var self = this,
          settings = self.settings,
          maxHideTime = parseFloat(settings.timeout),
          isPausePlay = false,
          percentage = 100,
          timer,
          container = $('#toast-container'),
          toast = $('<div class="toast"><span class="toast-title">'+ settings.title+
            '</span><span class="toast-message">'+ settings.message + '</span></div>'),
          closeBtn = $('<button type="button" class="btn-icon btn-close" title="'+ Locale.translate('Close')+
            '" aria-hidden="true">' + $.createIcon('close') + '<span class="audible"> '+ Locale.translate('Close')+'</span></button>'),
          progress = $('<div class="toast-progress"></div>');

        if (!container.length) {
          container = $('<div id="toast-container" class="toast-container" aria-relevant="additions" aria-live="polite"></div>').appendTo('body');
        }

        container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left')
          .addClass('toast-' + settings.position.replace(' ', '-'));

        settings.timeout = settings.audibleOnly ? 100 : settings.timeout;

        // Start timer
        timer = new $.fn.timer(function() {
          self.remove(toast);
        }, settings.timeout);

        if (settings.progressBar) {
          toast.append(progress);
        }

        $(timer.event).on('update', function(e, data) {
          percentage = ((maxHideTime - data.counter) / maxHideTime) * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (settings.progressBar) {
            progress[0].style.width = percentage + '%';
          }
        });

        container.append(toast);
        toast.addClass((settings.audibleOnly ? 'audible' : 'effect-scale'));
        toast.append(closeBtn);

        $(document).on('keydown keyup', function(e) {
          e = e || window.event;
          if(e.ctrlKey && e.altKey && e.keyCode === 80) { //[Control + Alt + P] - Pause/Play toggle
            isPausePlay = e.type === 'keydown' ? true : false;
            timer[isPausePlay ? 'pause' : 'resume']();
          }
        });

        toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
          isPausePlay = /mousedown|touchstart/i.test(e.type) ? true : false;
          timer[isPausePlay ? 'pause' : 'resume']();
        });

        closeBtn.on('click', function () {
          timer.cancel();
          self.remove(toast);
        });
      },

      // Remove the Message and Animate
      remove: function (toast) {
        if (this.settings.audibleOnly) {
          toast.remove();
          return;
        }

        toast.addClass('effect-scale-hide');
        setTimeout(function () {
          toast.remove();
        }, 500);
      },

      // Teardown
      destroy: function() {
        $('#toast-container').remove();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
        instance.show();
      } else {
        instance = $.data(this, pluginName, new Toast(this, settings));
      }
    });
  };


  $.fn.tabs = function(options) {

    // Tab Settings and Options
    var pluginName = 'tabs',
        defaults = {
          addTabButton: false, // If set to true, creates a button at the end of the tab list that can be used to add an empty tab and panel
          addTabButtonCallback: null, // if defined as a function, will be used in-place of the default Tab Adding method
          ajaxOptions: null, // if defined, will be used by any internal Tabs AJAX calls as the desired request settings.
          containerElement: null, // Defines a separate element to be used for containing the tab panels.  Defaults to a `.tab-panel-container` element that is created if it doesn't already exist.
          changeTabOnHashChange: false, // If true, will change the selected tab on invocation based on the URL that exists after the hash
          hashChangeCallback: null, // If defined as a function, provides an external method for adjusting the current page hash used by these tabs
          lazyLoad: true, // if true, when using full URLs in tab HREFs, or when using Ajax calls, tabs will be loaded as needed instead of the markup all being established at once.
          moduleTabsTooltips: false, // if true, will display a tooltip on Module Tabs with cut-off text content.
          source: null, // If defined, will serve as a way of pulling in external content to fill tabs.
          sourceArguments: {}, // If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
          tabCounts: false, // If true, Displays a modifiable count above each tab.
          verticalResponsive: false // If Vertical Tabs & true, will automatically switch to Horizontal Tabs on smaller breakpoints.
        },
        tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'],
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tabs(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Tabs.prototype = {

      init: function(){
        return this
          .setup()
          .build()
          .setupEvents();
      },

      setup: function() {
        // Used by the $(body).resize event to correctly identify the tabs container element
        this.tabsIndex = $('.tab-container').index(this.element);
        return this;
      },

      build: function() {
        var self = this,
          tabPanelContainer,
          moveTabPanelContainer = false;

        // Check for a tab panel container immediately after the `.tab-container` element (default as of Soho Xi 4.3.0)
        tabPanelContainer = this.element.next('.tab-panel-container');

        // Auto-detect and move existing tab-panel containers in key areas, if applicable.
        // Check inside the container first
        if (!tabPanelContainer.length) {
          tabPanelContainer = this.element.children('.tab-panel-container');

          if (!this.isVerticalTabs()) {
            moveTabPanelContainer = true;
          }
        }

        // Special case for Header Tabs, find the page container and use that as the container
        var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');
        if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
          tabPanelContainer = bodyPageContainer;
        }

        // Special case for Module Tabs, where it's possible for layout reasons for there to be
        // an application menu element adjacent between the Tab list and the Tab Panel container
        if (this.element.next('.application-menu').length) {
          tabPanelContainer = this.element.next().next('.page-container');
          moveTabPanelContainer = false;
        }

        // Defining `this.settings.containerElement` ultimately overrides any internal changes to the tab panel container.
        if (this.settings.containerElement && $(this.settings.containerElement).length) {
          tabPanelContainer = $(this.settings.containerElement);
          moveTabPanelContainer = false;
        }

        // If a `.tab-panel-container` still doesn't exist, create one.
        if (!tabPanelContainer || !tabPanelContainer.length) {
          tabPanelContainer = $('<div class="tab-panel-container"></div>');
          moveTabPanelContainer = true;
        }

        if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
          tabPanelContainer[0].classList.add('tab-panel-container');
        }
        if (moveTabPanelContainer) {
          tabPanelContainer.insertAfter(this.element);
        }

        this.container = tabPanelContainer;

        // Detect the existence of a "tab-list-container" element, if applicable.
        // Tab List containers are optional for all tab container types, but mandatory for
        // Composite Form tabs.
        var tablistContainer = this.element.children('.tab-list-container');
        if (!tablistContainer.length && this.isScrollableTabs()) {
          tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
        }
        if (tablistContainer.length) {
          this.tablistContainer = tablistContainer;
        }

        // Add a default tabs class of "horizontal" if it doesn't already exist
        var noClass = true,
          closestHeader = this.element.closest('.header');
        tabContainerTypes.forEach(function tabTypeIterator(val, i) {
          if (self.element.hasClass(tabContainerTypes[i])) {
            noClass = false;
          }
        });
        if (noClass) {
          if (closestHeader.length) {
            self.element.addClass('header-tabs');
          } else {
            self.element.addClass('horizontal');
          }
        }

        // Build Tab Counts
        if (self.settings.tabCounts) {
          self.element.addClass('has-counts');
        }

        //Attach Tablist role and class to the tab headers container
        this.tablist = this.element.children('.tab-list');
        if (!this.tablist.length) {

          // If we have a `.tab-list-container` element, check that before creating markup
          if (this.tablistContainer) {
            this.tablist = this.tablistContainer.children('.tab-list');
          }

          // Create and append the `.tab-list` if it still doesn't exist.
          if (!this.tablist.length) {
            this.tablist = $('<ul class="tab-list"></ul>');
            if (this.tablistContainer) {
              this.tablist.appendTo(this.tablistContainer);
            } else {
              this.tablist.appendTo(this.element);
            }
          }
        }

        // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
        // Move it if necessary.
        if (this.tablistContainer) {
          if (!this.tablist.parent().is(this.tablistContainer)) {
            this.tablistContainer.append(this.tablist);
          }

          this.tablistContainer.on('mousewheel.tabs', function(e) {
            if (e.deltaY) {
              this.scrollLeft += e.deltaY;
            }
          });
        }

        self.tablist
          .attr({
            'class': 'tab-list',
            'role': 'tablist',
            'aria-multiselectable': 'false'
          });

        // Conditionally Change layout classes if veritcal tabs is in responsive mode, and breakpoints match
        this.checkResponsive();

        // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and App Menu Button.
        this.renderHelperMarkup();

        //for each item in the tabsList...
        self.anchors = self.tablist.children('li:not(.separator)').children('a');
        self.anchors.each(function prepareAnchor() {
          var a = $(this);
          a.attr({'role': 'tab', 'aria-expanded': 'false', 'aria-selected': 'false', 'tabindex': '-1'})
           .parent().attr('role', 'presentation').addClass('tab');

          if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
            $.createIconElement({ icon: 'close', classes: 'icon close' }).insertAfter(a);
          }

          // Find and configure dropdown tabs
          var dd = a.nextAll('ul').first();
          if (dd.length > 0) {
            dd.addClass('dropdown-tab');
            var li = a.parent();

            li.addClass('has-popupmenu').popupmenu({
              menu: dd,
              trigger: 'click',
              attachToBody: true
            });

            a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

            if (!a.parent().children('.icon.icon-more').length) {
              $.createIconElement({ classes: 'icon-more', icon: 'dropdown' }).insertAfter(a);
            }
          }

          if (self.settings.tabCounts && $(this).find('.count').length === 0) {
            $(this).prepend('<span class="count">0 </span>');
          }

          // Make it possible for Module Tabs to display a tooltip containing their contents
          // if the contents are cut off by ellipsis.
          if (self.settings.moduleTabsTooltips) {
            a.on('beforeshow.toolbar', function() {
              return a.data('cutoffTitle') === 'yes';
            }).tooltip({
              content: '' + a.text().trim()
            });
          }
        });

        // Build/manage tab panels
        function associateAnchorWithPanel() {
          var a = $(this),
            li = a.parent(),
            popup = li.data('popupmenu'),
            panel;

          // Associated the current one
          var href = a.attr('href');

          if (href.substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }

          if (href !== undefined && href !== '#') {
            panel = $(href);

            if (li.is(':not(.has-popupmenu)') && !panel.length) {
              return;
            }

            a.data('panel-link', panel);
            panel.data('tab-link', a);
            self.panels = self.panels.add(panel);
          }

          // If dropdown tab, add the contents of the dropdown
          // NOTE: dropdown tabs shouldn't have children, so they aren't accounted for here
          if (popup) {
            popup.menu.children('li').each(function() {
              var li = $(this),
                a = li.children('a'),
                href = a.attr('href'),
                panel = $(href);

              a.data('panel-link', panel);
              panel.data('tab-link', a);

              self.panels = self.panels.add(panel);
              self.anchors = self.anchors.add(a);

              if (!li.hasClass('dismissible')) {
                return;
              }

              var icon = li.children('.icon');
              if (!icon.length) {
                icon = $.createIconElement({icon: 'close', classes: 'icon close'});
              }
              icon.detach().appendTo(a);

            }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
              var icon = $(this),
                li = icon.closest('li');

              if (li.is('.dismissible') && icon.is('.icon')) {
                e.preventDefault();
                e.stopPropagation();
                self.closeDismissibleTab(li.children('a').attr('href'));
              }
            });
          }
        }

        self.panels = $();
        self.anchors.each(associateAnchorWithPanel);
        self.panels
          .addClass('tab-panel')
          .attr({'role': 'tabpanel'})
          .find('h3:first').attr('tabindex', '0');

        self.panels.appendTo(self.container);

        var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)',
          tabs = this.tablist.children('li' + excludes),
          selected = this.tablist.children('li.is-selected' + excludes),
          selectedAnchor = selected.children('a');

        // Setup a hash for nested tab controls
        self.nestedTabControls = self.panels.find('.tab-container');

        if (tabs.length) {
          // If the hashChange setting is on, change the selected tab to the one referenced by the hash
          if (this.settings.changeTabOnHashChange) {
            var hash = window.location.hash;
            if (hash && hash.length) {
              var matchingTabs = tabs.find('a[href="'+ hash +'"]');
              if (matchingTabs.length) {
                selected = matchingTabs.first().parent();
                selectedAnchor = selected.children('a');
              }
            }
          }

          // If there is no selected tab, try to find the first available tab (if there are any present)
          if (!selected.length) {
            selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
            selectedAnchor = selected.children('a');
          }

          // If there are tabs present, activate the first one
          if (selected.length) {
            this.activate(selectedAnchor.attr('href'));
          }
        }

        if (this.isModuleTabs() && this.element.children('.toolbar').length) {
          this.element.addClass('has-toolbar');
        }

        this.setOverflow();

        if (this.hasSquareFocusState()) {
          this.positionFocusState(selectedAnchor);
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.addClass('no-transition');
          this.focusBar(undefined, function transitionRemover() {
            setTimeout(function() {
              self.animatedBar.removeClass('no-transition');
            }, 0);
          });
        }

        // Setup Edge Fades
        if (this.tablistContainer) {
          this.tablistContainer.on('scroll.tabs', function() {
            self.renderEdgeFading();
          });
          this.renderEdgeFading();
        }

        return this;
      },

      /**
       * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
       * Designed to be run at any point in the Tabs lifecycle.
       * @returns {this}
       */
      renderHelperMarkup: function() {
        var auxilaryButtonLocation = this.tablistContainer || this.tablist;
        if (this.isModuleTabs()) {
          auxilaryButtonLocation = this.tablist;
        }

        // Square Focus State
        if (this.hasSquareFocusState()) {
          this.focusState = this.element.find('.tab-focus-indicator');
          if (!this.focusState.length) {
            this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
          }
        } else {
          if (this.focusState && this.focusState.length) {
            this.focusState.off().remove();
            this.focusState = undefined;
          }
        }

        // Animated Bar
        if (this.hasAnimatedBar()) {
          this.animatedBar = this.element.find('.animated-bar');
          if (!this.animatedBar.length) {
            this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
          }
          this.animatedBar.insertBefore(this.tablist);
        } else {
          if (this.animatedBar && this.animatedBar.length) {
            this.animatedBar.off().remove();
            this.animatedBar = undefined;
          }
        }

        // Add the markup for the "More" button if it doesn't exist.
        if (!this.moreButton) {
          this.moreButton = $();
        }

        if (!this.isVerticalTabs()) {
          if (!this.moreButton.length) {
            this.moreButton = auxilaryButtonLocation.next('.tab-more');
          }
          // If we still don't have a More Button, create one
          if (!this.moreButton.length) {
            this.moreButton = $('<div>').attr({'class': 'tab-more'});
            this.moreButton.append( $('<span class="more-text">').text(Locale.translate('More')));
            this.moreButton.append($.createIconElement({ classes: 'icon-more', icon: 'dropdown' }));
          }

          // Append in the right place based on configuration
          auxilaryButtonLocation.after(this.moreButton);
        } else {
          if (this.moreButton.length) {
            this.moreButton.off().remove();
            this.moreButton = $();
          }
        }

        // Add the application menu Module Tab, if applicable
        var appMenuTrigger = this.tablist.find('.application-menu-trigger');
        if (this.isModuleTabs()) {
          if (!appMenuTrigger.length) {
            appMenuTrigger = $('<li class="tab application-menu-trigger"><a href="#">' +
              '<span class="icon app-header"><span class="one"></span><span class="two"></span><span class="three"></span></span>' +
              '<span>Menu</span>' +
              '</a></tab>');
            this.tablist.prepend(appMenuTrigger);
          }
        } else {
          if (this.isVerticalTabs() && appMenuTrigger.length) {
            appMenuTrigger.off().remove();
          }
        }

        // Add Tab Button
        if (this.settings.addTabButton) {
          if (!this.addTabButton || !this.addTabButton.length) {
            this.addTabButton = $('<div class="add-tab-button" tabindex="0" role="button">' +
              '<span aria-hidden="true" role="presentation">+</span>' +
              '<span class="audible">'+ Locale.translate('AddNewTab') +'</span>' +
              '</div>');
            this.addTabButton.insertAfter(this.moreButton);
            this.element.addClass('has-add-button');
          }
        } else {
          if (this.addTabButton && this.addTabButton.length) {
            this.addTabButton.remove();
            this.addTabButton = undefined;
            this.element.removeClass('has-add-button');
          }
        }

        return this;
      },

      setupEvents: function() {
        var self = this;

        // Set animation bar if tabs under modal
        var modal = self.element.closest('.modal');
        if (modal.length) {
          modal.on('afteropen', function () {
            if (self.hasAnimatedBar()) {
              self.focusBar();
            }
          });
        }

        // Clicking the 'a' triggers the click on the 'li'
        function routeAnchorClick(e) {
          var a = $(e.currentTarget);

          if (this.wasTapped === true) {
            this.wasTapped = false;
            return;
          }

          if (e.type === 'touchend') {
            this.wasTapped = true;
          }

          if (a.attr('href').substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }
          e.preventDefault();
        }

        // Some tabs have icons that can be clicked and manipulated
        function handleIconClick(e) {
          var elem = $(this);
          if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
            return;
          }

          var li = $(elem).parent();

          if (li.hasClass('dismissible')) {
            e.preventDefault();
            e.stopPropagation();
            self.closeDismissibleTab(li.children('a').attr('href'));
          }
        }

        function handleTabBlur() {
          $(this).parent().removeClass('is-focused');
        }

        // Any events bound to individual tabs (li) and their anchors (a) are bound to the tablist
        // element so that tabs can be added/removed/hidden/shown without needing to change event bindings.
        this.tablist
          .on('mousedown.tabs', '> li', function(e) {
            self.handleAddFocusData(e, $(this));

            // let right click pass through
            if (e.which !== 3) {
              return self.handleTabClick(e, $(this));
            }
          })
          .on('click.tabs', 'a', routeAnchorClick)
          .on('click.tabs', '.icon', handleIconClick)
          .on('focus.tabs', 'a', function(e) {
            return self.handleTabFocus(e, $(this));
          })
          .on('blur.tabs', 'a', handleTabBlur)
          .on('keydown.tabs', 'a', function(e) {
            return self.handleTabKeyDown(e);
          });

        // Setup events on Dropdown Tabs
        function dropdownTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a'),
            menu = li.data('popupmenu').menu;

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !li.is('.dismissible')) {
              return;
            }

            self.closeDismissibleTab(a.attr('href'));
            return;
          }

          menu.on('keydown.popupmenu', 'a', function(e) {
            switch(e.which) {
              case 27: // escape
                li.addClass('is-selected');
                a.focus();
                break;
              case 8: // backspace (delete on Mac)
                closeDropdownMenuItem(e);
                break;
              case 46: // The actual delete key
                closeDropdownMenuItem(e);
                break;
            }
          });

          li.on('selected.tabs', function(e, anchor) {
            var li = $(this),
              href = $(anchor).attr('href');
            self.activate(href);

            if (self.hasSquareFocusState()) {
              self.positionFocusState(a);
            }

            if (self.hasAnimatedBar()) {
              self.focusBar(li);
            }

            a.focus();
            self.scrollTabList(li);

            li.addClass('is-selected');
            return false;
          });
        }

        var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
        ddTabs.each(dropdownTabEvents);

        function dismissibleTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a');

          a.on('keydown.tabs', function(e) {
            self.handleDismissibleTabKeydown(e);
          });
        }

        var dismissible = self.tablist.find('li').filter('.dismissible');
        dismissible.each(dismissibleTabEvents);

        // Events specific to markup that can be re-rendered mid-lifecycle
        // The responsive vertical tabs system will set this up automatically, so skip
        if (!this.isResponsiveVerticalTabs()) {
          this.setupHelperMarkupEvents();
        }

        this.panels.on('keydown.tabs', function(e) {
          self.handlePanelKeydown(e);
        });

        // Check whether or not all of the tabs + more button are de-focused.
        // If true, the focus-state and animated bar need to revert positions
        // back to the currently selected tab.
        this.element.on('focusout.tabs', function allTabsFocusOut() {
          var noFocusedTabs = !$.contains(self.element[0], document.activeElement),
            noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

          if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
            self.hideFocusState();
          }
        }).on('updated.tabs', function() {
          self.updated();
        }).on('activated.tabs', function(e) {
          // Stop propagation of the activate event from going higher up into the DOM tree
          e.stopPropagation();
        }).on('add.tabs', function(e, newTabId, newTabOptions, newTabIndex) {
          self.add(newTabId, newTabOptions, newTabIndex);
        }).on('remove.tabs', function(e, tabId) {
          self.remove(tabId);
        });

        // Check to see if we need to add/remove the more button on resize
        $('body').on('resize.tabs' + this.tabsIndex, function() {
          self.handleResize();
        });
        self.handleResize(true);

        return this;
      },

      /**
       * Adds events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      setupHelperMarkupEvents: function () {
        var self = this;

        // Setup the "more" function
        this.moreButton
          .onTouchClick('tabs')
          .on('click.tabs', function(e) {
            self.handleMoreButtonClick(e);
          })
          .on('keydown.tabs', function(e) {
            self.handleMoreButtonKeydown(e);
          })
          .on('focus.tabs', function(e) {
            self.handleMoreButtonFocus(e);
          })
          .on('mousedown.tabs', function(e) {
            self.handleAddFocusData(e, $(this));
          });

        if (this.settings.addTabButton) {
          this.addTabButton
            .onTouchClick('tabs')
            .on('click.tabs', function() {
              self.handleAddButton();
            })
            .on('keydown.tabs', function(e) {
              self.handleAddButtonKeydown(e);
            })
            .on('focus.tabs', function(e) {
              self.handleAddButtonFocus(e);
            });
        }
      },

      /**
       * Removes events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      removeHelperMarkupEvents: function() {
        if (this.moreButton && this.moreButton.length) {
          this.moreButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
        }

        if (this.addTabButton && this.addTabButton.length) {
          this.addTabButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs');
        }

        return this;
      },

      /**
       * Setup a mousedown event on tabs to determine in the focus handler whether or a not a keystroked cause
       * a change in focus, or a click.  Keystroke focus changes cause different visual situations
       * @param {$.Event} e
       * @param {jQuery[]} elem
       * @returns {undefined}
       */
      handleAddFocusData: function(e, elem) {
        var tab = elem;
        if (tab.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (!tab.is(this.moreButton)) {
          tab = tab.children('a');
        }

        this.hideFocusState();
        tab.data('focused-by-click', true);
      },

      handleTabClick: function(e, li) {
        if (this.element.is('.is-disabled') || (li && (li.is('.is-disabled') || li.is('.separator')))) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        var appMenuResult = this.handleAppMenuTabKeydown(e);
        if (!appMenuResult) {
          return;
        }

        var a = li.children('a');
        a.data('focused-by-click', true);

        if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
          this.popupmenu.close();
        }

        // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.
        if (li.is('.has-popupmenu')) {
          this.positionFocusState(a);
          return;
        }

        var href = a.attr('href');

        if (li.is('.add-tab-button')) {
          a = this.handleAddButton();
          li = a.parent();
          href = a.attr('href');
          this.element.trigger('tab-added', [a]);
        }

        // close tab on middle click
        if (e.which === 2) {
          if (li.is('.dismissible') && $(e.target).is('.close')) {
            this.closeDismissibleTab(href);
          }
          e.preventDefault();
          return;
        }

        this.activate(href);
        this.changeHash(href);

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }

        a.focus();

        if (this.isScrollableTabs()) {
          this.scrollTabList(li);
        }

        // Hide these states
        this.focusBar(li);
        this.positionFocusState(a);

        if (this.settings.lazyLoad === true && this.isURL(href)) {
          return false;
        }
      },

      handleMoreButtonClick: function(e) {
        if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        this.moreButton.data('focused-by-click', true);

        if (!(this.container.hasClass('has-more-button'))) {
          e.stopPropagation();
        }
        if (this.moreButton.hasClass('popup-is-open')) {
          this.popupmenu.close();
          this.moreButton.removeClass('popup-is-open');
        } else {
          this.buildPopupMenu();
        }

        this.hideFocusState();
      },

      handleTabFocus: function(e, a) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var li = a.parent(),
          dataFocusedClick = a.data('focused-by-click'),
          focusedByKeyboard = dataFocusedClick === undefined || (dataFocusedClick && dataFocusedClick === false);

        $.removeData(a[0], 'focused-by-click');

        if (this.isTabOverflowed(li)) {
          this.buildPopupMenu(a.attr('href'));
          this.moreButton.addClass('is-focused');
          this.positionFocusState(this.moreButton);
        } else {
          li.addClass('is-focused');
          this.positionFocusState(a, focusedByKeyboard);
        }
      },

      handleMoreButtonFocus: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return;
        }

        var dataFocusedClick = this.moreButton.data('focused-by-click'),
          focusedByKeyboard = (dataFocusedClick && dataFocusedClick === false);

        $.removeData(this.moreButton[0], 'focused-by-click');

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
          this.positionFocusState(this.moreButton, focusedByKeyboard);
        }
      },

      handleTabKeyDown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (e.shiftKey || e.ctrlKey || e.metaKey || (e.altKey && e.which !== 8)) {
          return;
        }

        var self = this,
          passableKeys = [8, 13, 32];

        function isPassableKey() {
          return $.inArray(e.which, passableKeys) > -1;
        }

        if ((e.which < 32 && !isPassableKey()) || e.which > 46) {
          return;
        }

        if (isPassableKey()) {
          var appMenuResult = this.handleAppMenuTabKeydown(e);
          if (!appMenuResult) {
            return;
          }
        }

        function openMenu(oldHref) {
          e.preventDefault();
          // setTimeout is used to bypass triggering of the keyboard when self.buildPopupMenu() is invoked.
          setTimeout(function() {
            self.buildPopupMenu(oldHref);
          }, 0);
        }

        var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)',
          currentLi = $(e.currentTarget).parent(),
          currentA = currentLi.children('a'),
          targetLi,
          tabs = self.tablist.children('li' + allExcludes),
          isRTL = Locale.isRTL();

        function previousTab() {
          var i = tabs.index(currentLi) - 1;
          while (i > -1 && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i = i - 1;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }

          var last = self.tablist.children('li' + allExcludes).last();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(last.find('a').attr('href'));
          }

          return last;
        }

        function nextTab() {
          var i = tabs.index(currentLi) + 1;
          while(i < tabs.length && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i++;
          }

          var first = self.tablist.children('li' + allExcludes).first();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(first.find('a').attr('href'));
            return first;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }
          return first;
        }

        function checkAngularClick() {
          if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) { // Needed to fire the "Click" event in Angular situations
            currentA.click();
          }
        }

        function activate() {
          if (currentLi.hasClass('has-popupmenu')) {
            currentLi.data('popupmenu').open();
            return;
          }

          var href = currentA.attr('href');

          if (currentLi.is('.add-tab-button')) {
            currentA = self.handleAddButton();
            currentLi = currentA.parent();
            href = currentA.attr('href');
            self.element.trigger('tab-added', [currentA]);
          }

          self.activate(href);
          self.changeHash(href);
          self.focusBar(currentLi);
          checkAngularClick();
          currentA[0].focus();
          self.hideFocusState();

          // In the event that the activated tab is a full link that should be followed,
          // the keystroke events need to manually activate the link change.  Clicks are handled
          // automatically by the browser.
          self.handleOutboundLink(href);
        }

        switch(e.which) {
          case 8:
            if (e.altKey && currentLi.is('.dismissible')) {
              e.preventDefault();
              self.closeDismissibleTab(currentA.attr('href'));
            }
            return;
          case 13: // Enter
            activate();
            return false;
          case 32: // Spacebar
            activate();
            return false;
          case 38:
            targetLi = previousTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 37:
            targetLi = isRTL ? nextTab() : previousTab();
            e.preventDefault();
            break;
          case 40:
            targetLi = nextTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 39:
            targetLi = isRTL ? previousTab() : nextTab();
            e.preventDefault();
            break;
        }

        if (targetLi) {
          var isAddTabButton = targetLi.is('.add-tab-button'),
            focusStateTarget = isAddTabButton ? targetLi : targetLi.children('a');

          // Use the matching option in the popup menu if the target is hidden by overflow.
          if (this.isTabOverflowed(targetLi)) {
            return openMenu(targetLi.children('a').attr('href'));
          }

          if (!isAddTabButton) {
            focusStateTarget.focus();
          } else {
            self.addTabButton.focus();
          }

          if (this.isScrollableTabs()) {
            this.scrollTabList(focusStateTarget);
          }

          if (self.hasSquareFocusState()) {
            self.positionFocusState(focusStateTarget, true);
          }
        }
      },

      handleDismissibleTabKeydown: function(e) {
        var key = e.which,
          tab = $(e.target);

        if (tab.is('a')) {
          tab = tab.parent();
        }

        if (e.altKey && key === 46) { // Alt + Del
          if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
            return;
          }

          e.preventDefault();
          this.closeDismissibleTab(tab.children('a').attr('href'));
        }
      },

      handleAppMenuTabKeydown: function(e) {
        var target = $(e.target),
          li = target.parent();

        if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
          return true;
        }

        // If the tab is an application-menu trigger, open the app menu
        // Used by Module Tabs
        var menu = $('#application-menu');
        if (!menu.length) {
          return false;
        }

        e.preventDefault();

        this.hideFocusState();

        if (menu.hasClass('is-open')) {
          menu.trigger('close-applicationmenu');
          return false;
        }

        menu.trigger('open-applicationmenu');
        return false;
      },

      handleMoreButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL();

        function openMenu() {
          e.preventDefault();
          self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }

        function lastTab() {
          e.preventDefault();
          self.findLastVisibleTab();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              openMenu();
              break;
            }
            lastTab();
            break;
          case 38: // up
            lastTab();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
          case 39: // right
            if (isRTL) {
              lastTab();
              break;
            }
            openMenu();
            break;
          case 40: // down
            openMenu();
            break;
        }
      },

      handlePanelKeydown: function(e) {
        var key = e.which,
          panel = $(e.target),
          a = this.anchors.filter('#' + panel.attr('id')),
          tab = this.anchors.filter('#' + panel.attr('id')).parent();

        if (tab.is('.dismissible')) {
          // Close a Dismissible Tab
          if (e.altKey && key === 46) { // Alt + Delete
            e.preventDefault();
            return this.closeDismissibleTab(a.attr('href'));
          }
        }

        // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab
        if ((e.ctrlKey && key === 38) && $.contains(document.activeElement, panel[0])) { // Ctrl + Up Arrow
          e.preventDefault();
          return this.activate(a.attr('href'));
        }
      },

      handleAddButton: function() {
        var cb = this.settings.addTabButtonCallback;
        if (cb && typeof cb === 'function') {
          var newTabId = cb();
          return this.anchors.filter('[href="#'+ newTabId +'"]');
        }

        function makeId() {
          var stringName = 'new-tab',
            existing = $('[id^="'+ stringName +'"]');

          if (!existing.length) {
            return stringName + '-0';
          }
          return stringName + '-' + existing.length;
        }

        function makeName(id) {
          var nameParts = id.toString().split('-');
          nameParts.forEach(function(val, i) {
            nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
          });

          return nameParts.join(' ');
        }

        var newIndex = this.tablist.children().index(this.addTabButton),
          newId = makeId(),
          newName = makeName(newId),
          settings = {
            name: newName,
            content: '&nbsp;',
            isDismissible: true
          };

        if (newIndex < 0) {
          newIndex = this.tablist.find('li:not(.separator)').length;
        }

        // Allow the opportunity to pass in external settings for the new tab control
        var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);
        if (!externalSettings) {
          this.add(newId, settings, newIndex);
          return this.anchors.filter('[href="#'+ newId +'"]');
        }

        if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
          newId = externalSettings.newId;
        }
        if (externalSettings.settings && typeof externalSettings.settings === 'object') {
          settings = externalSettings.settings;
        }
        if (!isNaN(externalSettings.newIndex)) {
          newIndex = externalSettings.newIndex;
        }

        this.add(newId, settings, newIndex);
        return this.anchors.filter('[href="#'+ newId +'"]');
      },

      handleAddButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL(),
          targetLi,
          filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

        function openMenu() {
          e.preventDefault();
          targetLi = self.tablist.find(filter).last();

          if (self.isTabOverflowed(targetLi)) {
            // Open the spillover
            self.buildPopupMenu(targetLi.children('a').attr('href'));
            self.positionFocusState(self.moreButton, true);
            return;
          }
        }

        function firstTab() {
          targetLi = self.tablist.find(filter).first();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              firstTab();
              break;
            }
            openMenu();
            break;
          case 38: // up
            openMenu();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
            return this.handleAddButton();
          case 39: // right
            if (isRTL) {
              openMenu();
              break;
            }
            firstTab();
            break;
          case 40: // down
            firstTab();
            break;
          default:
            return;
        }

        targetLi.children('a').focus();
      },

      handleAddButtonFocus: function() {
        var tabs = this.tablist.find('li:not(.separator)');
        tabs.add(this.moreButton).removeClass('is-focused');

        this.addTabButton.addClass('is-focused');
        this.positionFocusState(this.addTabButton, true);
      },

      handleResize: function(ignoreResponsiveCheck) {
        if (!ignoreResponsiveCheck) {
          this.checkResponsive();
        }

        this.setOverflow();

        var selected = this.tablist.find('.is-selected');
        if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
          selected = this.moreButton;
        }

        if (!selected.length) {
          this.defocusBar();
          this.hideFocusState();
        } else {
          this.focusBar(selected);
          this.positionFocusState(selected);
        }

        this.handleVerticalTabResize();
        this.renderVisiblePanel();
        this.renderEdgeFading();
      },

      checkResponsive: function() {
        var self = this,
          classList = self.element[0].classList;

        function rebuild() {
          self.removeHelperMarkupEvents();
          self.renderHelperMarkup();
          self.setupHelperMarkupEvents();
        }

        function makeResponsive() {
          if (!classList.contains('is-in-responsive-mode')) {
            classList.add('is-in-responsive-mode');
            classList.add('header-tabs');
            classList.add('alternate');
            classList.remove('vertical');
            rebuild();
          }
        }

        function makeVertical() {
          if (classList.contains('is-in-responsive-mode')) {
            classList.add('vertical');
            classList.remove('is-in-responsive-mode');
            classList.remove('header-tabs');
            classList.remove('alternate');
            rebuild();
          }
        }

        // Check for responsive mode for Vertical tabs
        if (this.isResponsiveVerticalTabs()) {
          if (Soho.breakpoints.isBelow('phone-to-tablet')) {
            makeResponsive();
          } else {
            makeVertical();
          }
        } else {
          makeVertical();
        }
      },

      handleVerticalTabResize: function() {
        if (!this.isVerticalTabs()) {
          return;
        }

        // When tabs are full-size (part of a layout) CSS rules should handle this better
        // due to less strange sizing constraints.  JS resizing is necessary for nesting.
        if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
          return;
        }

        var elemStyle = window.getComputedStyle(this.element[0]),
          elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');

        this.tablist[0].style.height = elemOuterHeight;
      },

      // Changes the location in the browser address bar to force outbound links.
      handleOutboundLink: function(href, useRelativePath) {
        if (href.charAt(0) === '#') {
          return false;
        }

        if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
          href = window.location.origin + href;
        }

        window.location = href;
      },

      hasAnimatedBar: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      hasSquareFocusState: function() {
        return true;
      },

      hasMoreButton: function() {
        return this.element[0].classList.contains('has-more-button');
      },

      isInResponsiveMode: function() {
        return this.element[0].classList.contains('is-in-responsive-mode');
      },

      isModuleTabs: function() {
        return this.element.hasClass('module-tabs');
      },

      isVerticalTabs: function() {
        return this.element.hasClass('vertical');
      },

      isResponsiveVerticalTabs: function() {
        return this.settings.verticalResponsive === true;
      },

      isHeaderTabs: function() {
        return this.element.hasClass('header-tabs');
      },

      isScrollableTabs: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      isHidden: function() {
        return this.element.is(':hidden');
      },

      isNested: function() {
        return this.element.closest('.tab-panel').length;
      },

      isActive: function(href) {
        if (!href || !href.length || (href.length === 1 && href.indexOf('#') < 1)) {
          return false;
        }

        var panel = this.getPanel(href);
        return panel[0].classList.contains('can-show');
      },

      isNestedInLayoutTabs: function() {
        var nestedInModuleTabs = this.element.closest('.module-tabs').length,
          nestedInHeaderTabs = this.element.closest('.header-tabs').length,
          hasTabContainerClass = this.element.closest('.tab-panel-container').length;

        return (nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0);
      },

      isTab: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('li.tab');
      },

      isAnchor: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('a');
      },

      getAnchor: function(href) {
        if (this.isAnchor(href)) {
          return href;
        }

        if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
          href = '#' + href;
        }
        return this.anchors.filter('[href="' + href + '"]');
      },

      getPanel: function(href) {
        if (this.isTab(href)) {
          href = href.children('a');
        }

        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (!href || href === '' || href === '#') {
          return $();
        }

        return this.panels.filter('[id="' + href.replace(/#/g, '') + '"]');
      },

      getMenuItem: function(href) {
        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (href.indexOf('#') === -1) {
          href = '#' + href;
        }
        return this.moreMenu.children().children().filter('[data-href="'+ href +'"]').parent();
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      getPreviousTab: function(tabId) {
        var tab = this.getTab(null, tabId),
          filter = 'li:not(.separator):not(:hidden):not(.is-disabled)',
          tabs = this.tablist.find(filter),
          target = tabs.eq(tabs.index(tab) - 1);

        while(target.length && !target.is(filter)) {
          target = tabs.eq(tabs.index(target) - 1);
        }

        // Top-level Dropdown Tabs don't have an actual panel associated with them.
        // Get a Dropdown Tab's first child as the target.
        if (target.is('.has-popupmenu')) {
          var menuAPI = target.data('popupmenu');
          if (menuAPI) {
            target = menuAPI.menu.children('li').first();
          }
        }

        return target;
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      // If an optional target Tab (li) is provided, use this to perform activation events
      activatePreviousTab: function(tabId, target) {
        var tab = this.getTab(null, tabId);

        if (!target || !(target instanceof jQuery)) {
          target = this.getPreviousTab(tabId);
        }

        if (!target.length) {
          this.hideFocusState();
          this.defocusBar();
          return target;
        }

        var a = target.children('a');
        if (tab.is('.is-selected')) {
          this.activate(a.attr('href'));
          a.focus();
        }
        this.positionFocusState(a);
        this.focusBar(target);

        return target;
      },

      isURL: function(href) {
        if (!href || href.indexOf('#') === 0) {
          return false;
        }

        return true;
      },

      activate: function(href) {
        var self = this,
          a, targetTab, targetPanel, targetPanelElem, oldTab, oldPanel,
          selectedStateTarget,
          activeStateTarget;

        if (self.isURL(href)) {
          return this.callSource(href, true);
        }

        a = self.getAnchor(href);
        targetTab = a.parent();
        targetPanel = self.getPanel(href);
        targetPanelElem = targetPanel[0];
        oldTab = self.anchors.parents().filter('.is-selected');

        // Avoid filter(:visible)
        for (var i = 0; i < self.panels.length; i++) {
          if (self.panels[i].classList.contains('is-visible')) {
            oldPanel = $(self.panels[i]);
          }
        }

        if (!oldPanel) {
          oldPanel = self.panels;
        }

        var isCancelled = self.element.trigger('beforeactivate', [a]);
        if (!isCancelled) {
          return;
        }

        if (targetPanel.length < 1) {
          if (this.settings.source) {
            return this.callSource(href);
          }
        } else {
          oldPanel[0].classList.remove('can-show');
          oldPanel[0].classList.remove('is-visible');
          oldPanel.closeChildren();
          self.element.trigger('activated', [a]);

          targetPanelElem.classList.add('can-show');
          self.renderVisiblePanel();
          // trigger reflow as display property is none for animation
          targetPanelElem.offsetHeight; // jshint ignore:line

          targetPanel.one($.fn.transitionEndName() + '.tabs', function() {
            self.element.trigger('afteractivated', [a]);
          });

          // Triggers the CSS Animation
          targetPanelElem.classList.add('is-visible');
        }

        // Update the currently-selected tab
        self.updateAria(a);
        oldTab.add(this.moreButton).removeClass('is-selected');

        if (targetTab[0].classList.contains('tab')) {
          selectedStateTarget = targetTab;
          activeStateTarget = targetTab;
        }

        var ddMenu = targetTab.parents('.popupmenu'),
          ddTab;

        if (ddMenu.length) {
          ddTab = ddMenu.data('trigger');
          if (ddTab.length) {
            selectedStateTarget = ddTab;
            activeStateTarget = ddTab;
          }
        }

        if (this.isTabOverflowed(activeStateTarget)) {
          activeStateTarget = this.moreButton;
          selectedStateTarget = this.moreButton;
        }
        this.focusBar(activeStateTarget);

        selectedStateTarget.addClass('is-selected');

        // Fires a resize on any invoked child toolbars inside the tab panel.
        // Needed to fix issues with Toolbar alignment, since we can't properly detect
        // size on hidden elements.
        var childToolbars = targetPanel.find('.toolbar');
        if (childToolbars.length) {
          childToolbars.each(function() {
            var api = $(this).data('toolbar');
            if (api && typeof api.handleResize === 'function') {
              api.handleResize();
            }
          });
        }
      },

      /**
       * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
       * @returns {undefined}
       */
      renderEdgeFading: function() {
        if (!this.isScrollableTabs() || !this.tablistContainer) {
          return;
        }

        var isRTL = Locale.isRTL(),
          tablistContainerElem = this.tablistContainer[0],
          scrollLeft = tablistContainerElem.scrollLeft,
          scrollWidth = tablistContainerElem.scrollWidth,
          containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'));

        if (isRTL) {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-left');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-right');
        } else {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-right');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-left');
        }
      },

      /**
       * Calls an options-provided source method to fetch content that will be displayed inside a tab.
       * @param {string} href - string representing the target tab to load content under.
       * @param {function} callback - method that fires after a successful source call.
       * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore, or a promise object that will fire callbacks in either "success" or "failure" scenarios.
       */
      callSource: function(href, isURL) {
        if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
          return false;
        }
        if (this.settings.lazyLoad !== true) {
          return false;
        }

        var self = this,
          sourceType = typeof this.settings.source,
          response = function(htmlContent) {
            if (htmlContent === undefined || htmlContent === null) {
              return;
            }

            htmlContent = $.sanitizeHTML(htmlContent);

            // Get a new random tab ID for this tab if one can't be derived from the URL string
            if (isURL) {
              var anchor = self.tablist.find('[href="'+ href +'"]'),
                containerId = self.element[0].id || '',
                id = anchor.uniqueId('tab', containerId);

              href = '#' + id;
              // Replace the original URL on this anchor now that we've loaded content.
              anchor.attr('href', href);
            }

            self.createTabPanel(href, htmlContent, true);
            self.activate(href);

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [href, htmlContent]);
          };

        this.container.triggerHandler('start'); // For Busy Indicator
        this.container.trigger('requeststart');

        function handleStringSource(url, options) {
          var opts = $.extend({ dataType: 'html' }, options, {
            url: url
          });

          var request = $.ajax(opts);
          request.done(response);
          return request;
        }

        if (isURL) {
          return handleStringSource(href, this.ajaxOptions);
        }

        // return _true_ from this source function on if we're just loading straight content
        // return a promise if you'd like to setup async handling.
        if (sourceType === 'function') {
          return this.settings.source(response, href, this.settings.sourceArguments);
        }

        if (sourceType === 'string') {
          // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
          var safeHref = href.replace(/#/g, ''),
            sourceURL = this.settings.source.toString(),
            hasHref = sourceURL.indexOf(safeHref) > -1;

          if (!hasHref) {
            var param = 'tab=' + safeHref,
              paramIndex = sourceURL.indexOf('?'),
              hashIndex = sourceURL.indexOf('#'),
              insertIndex = sourceURL.length;

            if (paramIndex < 0) {
              param = '?' + param;
              if (hashIndex > -1) {
                insertIndex = hashIndex + 1;
              }
            } else {
              param = param + '&';
              insertIndex = paramIndex + 1;
            }

            sourceURL = Soho.string.splice(sourceURL, insertIndex, 0, param);
          }

          return handleStringSource(sourceURL, this.ajaxOptions);
        }

        return false;
      },

      renderVisiblePanel: function() {
        // Recalculate all components inside of the visible tab to adjust widths/heights/display if necessary
        this.resizeNestedTabs();
        //TJM: Prioritizing performance fix.
        //this.panels.filter(':visible').handleResize();
      },

      changeHash: function(href) {
        if (!this.settings.changeTabOnHashChange) {
          return;
        }

        if (!href) {
          href = '';
        }

        href.replace(/#/g, '');

        var cb = this.settings.hashChangeCallback;
        if (cb && typeof cb === 'function') {
          cb(href);
        } else {
          window.location.hash = href;
        }

        this.element.triggerHandler('hash-change', [href]);
      },

      updateAria: function(a) {
        if (!a) {
          return;
        }
        //hide old tabs
        this.anchors.attr({
          'aria-selected': 'false',
          'aria-expanded': 'false',
          'tabindex': '-1'
        });
        this.moreButton.attr({
          'tabindex': '-1'
        });

        //show current tab
        if (a.length && this.element.is(':not(.is-disabled)')) {
          a.parent().removeClass('is-selected');
          if (!this.isTabOverflowed(a.parent())) {
            a.attr({
              'aria-selected': 'true',
              'aria-expanded': 'true',
              'tabindex': '0'
            }).parent().addClass('is-selected');
          } else {
            this.moreButton.attr({
              'tabindex': '0'
            });
          }
        }
      },

      resizeNestedTabs: function() {
        this.nestedTabControls.each(function(i, container) {
          var c = $(container),
            api = c.data('tabs');

          if (api && api.handleResize && typeof api.handleResize === 'function') {
            api.handleResize(true);
          }
        });
      },

      // Adds a new tab into the list and properly binds events
      add: function(tabId, options, atIndex) {
        if (!tabId) {
          return this;
        }

        if (!options) {
          options = {};
        }

        var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0;

        // Sanitize
        tabId = '' + tabId.replace(/#/g, '');
        options.name = options.name ? options.name.toString() : '&nbsp;';
        options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
        options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

        function getObjectFromSelector(sourceString) {
          var contentType = typeof sourceString;
          switch(contentType) {
            case 'string':
              var hasId = sourceString.match(/#/g);
              // Text Content or a Selector.
              if (hasId !== null) {
                var obj = $(sourceString);
                sourceString = obj.length ? $(sourceString).clone() : sourceString;
              }
              // do nothing if it's just a string of text.
              break;
            case 'object':
              // jQuery object or HTML Element
              sourceString = $(sourceString).clone();
              break;
          }
          return sourceString;
        }

        if (options.content) {
          options.content = getObjectFromSelector(options.content);
        }
        if (options.dropdown) {
          options.dropdown = getObjectFromSelector(options.dropdown);
        }

        // Build
        var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>'),
          anchorMarkup = $('<a href="#'+ tabId +'" role="tab" aria-expanded="false" aria-selected="false" tabindex="-1">'+ options.name +'</a>'),
          tabContentMarkup = this.createTabPanel(tabId, options.content);

        tabHeaderMarkup.html(anchorMarkup);

        if (options.isDismissible) {
          tabHeaderMarkup.addClass('dismissible');
          tabHeaderMarkup.append($.createIconElement({ icon: 'close', classes: 'close icon' }));
        }

        if (this.settings.tabCounts) {
          anchorMarkup.prepend('<span class="count">0 </span>');
        }

        if (options.dropdown) {
          // TODO: Need to implement the passing of Dropdown Tab menus into this method.
        }

        function insertIntoTabset(self, targetIndex) {
          var method,
            tabs = self.tablist.children('li'),
            nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button'),
            finalIndex = tabs.length - 1;

          if (!tabs.length) {
            tabHeaderMarkup.appendTo(self.tablist);
            tabContentMarkup.appendTo(self.container);
            return;
          }

          var addTabButton = tabs.filter('.add-tab-button'),
            appMenuTrigger = tabs.filter('.application-menu-trigger');

          // NOTE: Cannot simply do !targetIndex here because zero is a valid index
          if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
            targetIndex = tabs.length;
          }

          function pastEndOfTabset(index) {
            return index > tabs.length - 1;
          }

          function atBeginningOfTabset(index) {
            return index <= 0;
          }

          if (tabs.length > nonSpecialTabs.length) {
            if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
              targetIndex = targetIndex - 1;
            }

            if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
              targetIndex = targetIndex + 1;
            }
          }

          var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;

          finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;

          method = 'insertAfter';
          if (conditionInsertTabBefore) {
            method = 'insertBefore';
          }

          tabHeaderMarkup[method](tabs.eq(finalIndex));
          tabContentMarkup.appendTo(self.container);
          return;
        }

        insertIntoTabset(this, atIndex);

        // Add each new part to their respective collections.
        this.panels = this.panels.add(tabContentMarkup);
        this.anchors = this.anchors.add(anchorMarkup);

        // Link the two items via data()
        anchorMarkup.data('panel-link', tabContentMarkup);
        tabContentMarkup.data('tab-link', anchorMarkup);
        // TODO: When Dropdown Tabs can be added/removed, add that here

        // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.
        if (this.settings.moduleTabsTooltips) {
          anchorMarkup.on('beforeshow.toolbar', function() {
            return anchorMarkup.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: '' + anchorMarkup.text().trim()
          });
        }

        // Adjust tablist height
        this.setOverflow();

        // If started from zero, position the focus state/bar and activate the tab
        if (startFromZero) {
          this.positionFocusState(anchorMarkup);
          this.focusBar(tabHeaderMarkup);
          this.activate(anchorMarkup.attr('href'));
          anchorMarkup.focus();
        }

        return this;
      },

      // Removes a tab from the list and cleans up properly
      // NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs of selecting certain
      // Tabs/Anchors at certain times.
      remove: function(tabId, disableBeforeClose) {
        var self = this,
          targetLi = this.doGetTab(null, tabId);

        if (!targetLi || !targetLi.length) {
          return;
        }

        var targetAnchor = targetLi.children('a'),
          targetPanel = this.getPanel(tabId),
          hasTargetPanel = (targetPanel && targetPanel.length),
          targetLiIndex = this.tablist.children('li').index(targetLi),
          notATab = '.application-menu-trigger, .separator, .is-disabled, :hidden',
          prevLi = targetLi.prev();

        if (!disableBeforeClose) {
          var canClose = this.element.triggerHandler('beforeclose', [targetLi]);
          if (canClose === false) {
            return false;
          }
        }

        var wasSelected = false;
        if (targetLi.hasClass('is-selected')) {
          wasSelected = true;
        } else {
          prevLi = this.tablist.children('li').not(notATab).filter('.is-selected');
        }

        // Remove these from the collections
        if (hasTargetPanel) {
          this.panels = this.panels.not(targetPanel);
        }
        this.anchors = this.anchors.not(targetAnchor);

        // Destroy Anchor tooltips, if applicable
        if (this.settings.moduleTabsTooltips) {
          targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
        }

        // Close Dropdown Tabs in a clean fashion
        var popupAPI = targetLi.data('popupmenu');
        if (targetLi.hasClass('has-popupmenu')) {
          if (popupAPI) {
            popupAPI.menu.children('li').each(function() {
              self.remove($(this).children('a').attr('href'));
            });
            popupAPI.destroy();
          }
        }

        // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
        // remaining, and if so, close the entire Dropdown Tab.
        // The actual check on these elements needs to be done AFTER the targetLi is removed
        // from a Dropdown Tab, to accurately check the number of list items remaining.
        // See: _isLastDropdownTabItem()_
        var parentMenu = targetLi.closest('.dropdown-tab'),
          trigger = parentMenu.data('trigger');

        // Kill associated events
        targetLi.off('click.tabs');
        targetAnchor.off('click.tabs focus.tabs keydown.tabs');

        // Remove Markup
        targetLi.remove();
        if (hasTargetPanel) {
          targetPanel.remove();
        }

        var menuItem = targetAnchor.data('moremenu-link');
        if (menuItem) {
          menuItem.parent().off().remove();
          $.removeData(targetAnchor[0], 'moremenu-link');
        }

        function isLastDropdownTabItem(menu) {
          return menu.length && menu.children('li:not(.separator)').length === 0;
        }
        if (isLastDropdownTabItem(parentMenu)) {
          prevLi = this.getPreviousTab(trigger);

          setTimeout(function() {
            self.remove(trigger);
          }, 1);
        }

        // Close dropdown tab's menu
        if (trigger && trigger.length) {
          trigger.data('popupmenu').close();
        }

        // Adjust tablist height
        this.setOverflow();

        this.element.trigger('close', [targetLi]);

        // If any tabs are left in the list, set the previous tab as the currently selected one.
        var count = targetLiIndex - 1;
        while (count > -1) {
          count = -1;
          if (prevLi.is(notATab)) {
            prevLi = prevLi.prev();
            count = count - 1;
          }
        }

        // If we find nothing, search for ANY available tab
        if (!prevLi.length) {
          prevLi = this.tablist.children('li').not(notATab).first();
        }

        // If there's really nothing, kick on out and defocus everything.
        if (!prevLi.length) {
          this.hideFocusState();
          this.defocusBar();

          this.element.trigger('afterclose', [targetLi]);
          return this;
        }

        var a = prevLi.children('a'),
          activateTargetA = a;

        this.positionFocusState(a);

        if (wasSelected) {
          if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
            activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
          }
          this.activate(activateTargetA.attr('href'));
        }

        this.focusBar(prevLi);
        a.focus();

        this.element.trigger('afterclose', [targetLi]);

        return this;
      },


      createTabPanel: function(tabId, content, doInsert) {
        tabId = tabId.replace(/#/g, '');

        // If a jQuery-wrapped element is provided, actually append the element.
        // If content is text/string, simply inline it.
        var markup = $('<div id="'+ tabId +'" class="tab-panel" role="tabpanel"></div>');
        if (content instanceof $) {
          markup.append(content);
        } else {
          markup[0].innerHTML = content || '';
        }

        if (doInsert === true) {
          this.container.append(markup);
        }

        this.panels = this.panels.add(markup);

        return markup;
      },

      checkPopupMenuItems: function(tab) {
        function getRemainingMenuItems(popupAPI) {
          if (!popupAPI || !popupAPI.menu) {
            return $();
          }
          var menu = popupAPI.menu,
            items = menu.children('li');

          if (!items.length) {
            popupAPI.destroy();
            return $();
          }
          return items;
        }

        if (tab.is('.has-popupmenu')) {
          return getRemainingMenuItems(tab.data('popupmenu'));
        }

        var ddTab = tab.closest('.dropdown-tab');
        if (!ddTab.length) {
          return $();
        }
        return getRemainingMenuItems(ddTab.data('popupmenu'));
      },

      getTab: function(e, tabId) {
        var self = this,
          tab = $();

        function getTabFromEvent(ev) {
          var t = $(ev.currentTarget);
          if (t.is('.tab')) {
            return t;
          }
          if (t.closest('.tab').length) {
            return t.closest('.tab').first();
          }
          return null;
        }

        function getTabFromId(id) {
          if (!id || id === '' || id === '#') {
            return null;
          }

          if (id.indexOf('#') === -1) {
            id = '#' + id;
          }

          var anchor = self.anchors.filter('[href="' + id + '"]');
          if (!anchor.length) {
            return null;
          }

          return anchor.parent();
        }

        // TabId can also be a jQuery object containing a tab.
        if (tabId instanceof $ && tabId.length > 0) {
          if (tabId.is('a')) {
            return tabId.parent();
          }
          return tabId;
        }

        return e ? getTabFromEvent(e) : tabId ? getTabFromId(tabId) : tab;
      },

      doGetTab: function(e, tabId) {
        if (!e && !tabId) { return $(); }
        if (e && !(e instanceof $.Event) && typeof e !== 'string') {
          return $();
        }

        if (e) {
          if (typeof e !== 'string') { // jQuery Event
            return this.getTab(e);
          }
          return this.getTab(null, e); // String containing a selector
        }

        // Straight to the TabID
        return this.getTab(null, tabId);
      },

      // Hides a tab
      hide: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Shows a tab
      show: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Disables an individual tab
      disableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Enables an individual tab
      enableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Renames a tab and resets the focusable bar/animation.
      rename: function(e, tabId, name) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          name = tabId;
          tabId = e;
        }

        if (!name) {
          return;
        }

        var tab = this.doGetTab(e, tabId),
          hasCounts = this.settings.tabCounts,
          hasTooltip = this.settings.moduleTabsTooltips,
          anchor = tab.children('a'),
          count;

        if (hasCounts) {
          count = anchor.find('.count').clone();
        }

        anchor.text(name.toString());

        if (hasCounts) {
          anchor.prepend(count);
        }

        if (hasTooltip) {
          anchor.data('tooltip').setContent(name.trim());
        }

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // For tabs with counts, updates the count and resets the focusable bar/animation
      updateCount: function(e, tabId, count) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          count = tabId;
          tabId = e;
        }

        if (!this.settings.tabCounts || !count) {
          return;
        }

        var tab = this.doGetTab(e, tabId);

        tab.children('a').find('.count').text(count.toString() + ' ');

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // returns the currently active tab
      getActiveTab: function() {
        var visible = this.panels.filter(':visible');
        return this.anchors.filter('[href="#'+ visible.first().attr('id') +'"]');
      },

      getVisibleTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (!self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      getOverflowTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      setOverflow: function () {
        var elem = this.element[0],
          tablist = this.tablist[0],
          HAS_MORE = 'has-more-button',
          hasMoreIndex = this.hasMoreButton(),
          isScrollableTabs = this.isScrollableTabs();

        // Recalc tab width before detection of overflow
        if (this.isModuleTabs()) {
          this.adjustModuleTabs();
        }

        var tablistStyle, tablistHeight,
          tablistContainerScrollWidth, tablistContainerWidth,
          overflowCondition;

        if (isScrollableTabs) {
          tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
          tablistContainerWidth = this.tablistContainer[0].offsetWidth;
          overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
        } else {
          tablistStyle = window.getComputedStyle(tablist, null);
          tablistHeight = parseInt(tablistStyle.getPropertyValue('height')) + 1; // +1 to fix an IE bug
          overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
        }

        // Add "has-more-button" class if we need it, remove it if we don't
        // Always display the more button on Scrollable Tabs
        if (overflowCondition) {
          if (!hasMoreIndex) {
            elem.classList.add(HAS_MORE);
          }
        } else if (hasMoreIndex) {
          elem.classList.remove(HAS_MORE);
        }

        this.adjustSpilloverNumber();
      },

      adjustModuleTabs: function() {
        var self = this,
          sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)'),
          appTrigger = this.tablist.find('.application-menu-trigger'),
          hasAppTrigger = appTrigger.length > 0,
          tabContainerW = this.tablist.outerWidth(),
          defaultTabSize = 120,
          visibleTabSize = 120,
          appTriggerSize = (hasAppTrigger ? appTrigger.outerWidth() : 0),
          anchorStyle,
          anchorPadding;

        // Remove overflowed tabs
        sizeableTabs.children('a').removeAttr('style');
        sizeableTabs.removeAttr('style').each(function() {
          var t = $(this);
          if (self.isTabOverflowed(t)) {
            sizeableTabs = sizeableTabs.not(t);
          }
        });

        // Resize the more button to fit the entire space if no tabs can show
        // Math: +101 is the padding of the <ul class="tab-list"> element
        if (!sizeableTabs.length) {
          visibleTabSize = (tabContainerW - appTriggerSize + 101);
          this.moreButton[0].style.width = visibleTabSize + 'px';
          return;
        } else {
          anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
          anchorPadding = parseInt(anchorStyle.paddingLeft) + parseInt(anchorStyle.paddingRight);

          if (this.moreButton[0].hasAttribute('style')) {
            this.moreButton[0].removeAttribute('style');
          }
        }

        // Math explanation:
        // Width of tab container - possible applcation menu trigger
        // Divided by number of visible tabs (doesn't include app menu trigger which shouldn't change size)
        // Minus one (for the left-side border of each tab)
        visibleTabSize = ((tabContainerW - appTriggerSize) / sizeableTabs.length - 1);

        if (visibleTabSize < defaultTabSize) {
          visibleTabSize = defaultTabSize;
        }

        var a,
          prevWidth,
          cutoff = 'no';

        for (var i = 0; i < sizeableTabs.length; i++) {
          a = sizeableTabs.eq(i).children('a');
          a[0].style.width = '';

          if (this.settings.moduleTabsTooltips === true) {
            cutoff = 'no';

            prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width);

            if (prevWidth > (visibleTabSize - anchorPadding)) {
              cutoff = 'yes';
            }
            a.data('cutoffTitle', cutoff);
          }

          sizeableTabs[i].style.width = visibleTabSize + 'px';
          a[0].style.width = visibleTabSize + 'px';
        }

        this.adjustSpilloverNumber();
      },

      adjustSpilloverNumber: function() {
         var moreDiv = this.moreButton.find('.more-text'),
          tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)'),
          overflowedTabs = this.getOverflowTabs();

        if (tabs.length <= overflowedTabs.length) {
          moreDiv.text('' + Locale.translate('Tabs'));
        } else {
          moreDiv.text('' + Locale.translate('More'));
        }

        var countDiv = this.moreButton.find('.count');
        if (!countDiv.length) {
          countDiv = $('<span class="count"></span>');
          this.moreButton.children('span').first().prepend(countDiv);
        }

        countDiv.text('' + overflowedTabs.length + ' ');

        return;
      },

      //Selects a Tab
      select: function (href) {
        var modHref = href.replace(/#/g, ''),
          anchor = this.getAnchor(modHref);

        this.positionFocusState(undefined, false);
        this.focusBar(anchor.parent());
        this.activate(anchor.attr('href'));
        this.changeHash(modHref);

        anchor.focus();
      },

      buildPopupMenu: function(startingHref) {
        var self = this;
        if (self.popupmenu) {
          self.popupmenu.destroy();
          $('#tab-container-popupmenu').off('focus.popupmenu').remove();
          $(document).off('keydown.popupmenu');
        }

        // Build the new markup for the popupmenu if it doesn't exist.
        // Reset it if it does exist.
        var menuHtml = $('#tab-container-popupmenu'),
          shouldBeSelectable = '';
        if (this.isScrollableTabs()) {
          shouldBeSelectable = ' is-selectable';
        }

        if (menuHtml.length === 0) {
          menuHtml = $('<ul id="tab-container-popupmenu" class="tab-list-spillover'+ shouldBeSelectable +'">').appendTo('body');
        } else {
          menuHtml.html('');
        }

        // Build menu options from overflowed tabs
        var tabs = self.tablist.children('li'),
          isRTL = Locale.isRTL();

        function buildMenuItem(item) {
          var $item = $(item),
            $itemA = $item.children('a');

          if ($item.is(':hidden')) {
            return;
          }

          if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
            return;
          }

          if ($item.is('.separator')) {
            $item.clone().appendTo(menuHtml);
            return;
          }

          var popupLi = $item.clone(),
            popupA = popupLi.children('a');

          popupLi[0].classList.remove('tab');
          if (popupLi[0].classList.contains('is-selected')) {
            popupLi[0].classList.remove('is-selected');
            if (self.isScrollableTabs()) {
              popupLi[0].classList.add('is-checked');
            }
          }

          popupLi[0].removeAttribute('style');

          popupLi.children('.icon').off().appendTo(popupA);
          popupLi.appendTo(menuHtml);

          // Link tab to its corresponding "More Tabs" menu option
          $item.data('moremenu-link', popupA);
          popupA.find('.icon-more').remove();

          // Link "More Tabs" menu option to its corresponding Tab.
          // Remove onclick methods from the popup <li> because they are called
          // on the "select" event in context of the original button
          popupA.data('original-tab', $itemA);
          popupA.onclick = undefined;

          if (!$item.is('.has-popupmenu')) {
            return;
          }

          // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
          // As a submenu of the "popupLi".
          var submenu = $('#' + item.getAttribute('aria-controls')),
            clone = submenu.clone(),
            cloneLis = clone.children('li');

          clone[0].classList.remove('has-popupmenu');

          cloneLis.each(function(i) {
            var li = $(this),
              a = li.children('a'),
              originalLi = submenu.children('li').eq(i),
              originalA = originalLi.children('a');

            a.data('original-tab', originalA);
            originalA.data('moremenu-link', a);
          });

          clone.insertAfter(popupA);
        }

        // Build spillover menu options
        for (var i = 0; i < tabs.length; i++) {
          buildMenuItem(tabs[i]);
        }

        self.tablist.children('li:not(.separator)').removeClass('is-focused');
        var xOffset = 1;
        if (!this.isScrollableTabs()) {
          xOffset = 3;
        }

        // Invoke the popup menu on the button.
        self.moreButton.popupmenu({
          autoFocus: false,
          attachToBody: true,
          menu: 'tab-container-popupmenu',
          trigger: 'immediate',
          offset: { x: xOffset }
        });
        self.moreButton.addClass('popup-is-open');
        self.popupmenu = self.moreButton.data('popupmenu');

        if (self.hasSquareFocusState()) {
          self.positionFocusState(self.moreButton);
        }

        function closeMenu() {
          $(this).off('close.tabs selected.tabs');
          self.moreButton.removeClass('popup-is-open');
          self.positionFocusState(undefined);
          self.focusBar();
        }

        function selectMenuOption(e, anchor) {
          var href = anchor.attr('href'),
            id = href.substr(1, href.length),
            tab = self.doGetTab(id) || $(),
            a = tab ? tab.children('a') : $(),
            originalTab = anchor.data('original-tab').parent();

          if (originalTab.is('.add-tab-button')) {
            a = self.handleAddButton();
            originalTab = a.parent();
            href = a.attr('href');
            self.element.trigger('tab-added', [a]);
          }

          self.activate(href);

          // Fire an onclick event associated with the original tab from the spillover menu
          if (tab.length && a.length && typeof a[0].onclick === 'function') {
            a[0].onclick.apply(a[0]);
          }

          // Focus the More Button
          // NOTE: If we switch the focusing-operations back to how they used to be (blue bar moving around with the focus state)
          // remove the line below.
          self.moreButton.focus();

          self.scrollTabList(tab);
        }

        self.moreButton
          .on('close.tabs', closeMenu)
          .on('selected.tabs', selectMenuOption);

        var menu = self.popupmenu.menu;

        function handleDestroy() {
          menu.off();
          self.hideFocusState();
          $('#tab-container-popupmenu').remove();
        }

        function handleDismissibleIconClick(e) {
          var icon = $(this),
            li = icon.closest('li');

          if (!li.is('.dismissible') || !icon.is('.close')) {
            return;
          }

          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
          self.popupmenu.close();
        }

        menu
          .on('destroy.popupmenu', handleDestroy)
          .on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick)
          .on('click.popupmenu', '.icon', handleDismissibleIconClick);

        // If the optional startingIndex is provided, focus the popupmenu on the matching item.
        // Otherwise, focus the first item in the list.
        if (startingHref) {
          self.popupmenu.highlight(menu.find('a[href="' + startingHref + '"]'));
        } else if (self.tablist.children('.is-selected').length > 0) {
          self.popupmenu.highlight(menu.find('a[href="' + self.tablist.children('.is-selected').children('a').attr('href') + '"]'));
        } else {
          self.popupmenu.highlight(menu.find('li:first-child > a'));
        }

        // Overrides a similar method in the popupmenu code that controls escaping of this menu when
        // pressing certain keys.  We override this here so that the controls act in a manner as if all tabs
        // are still visible (for accessiblity reasons), meaning you can use left and right to navigate the
        // popup menu options as if they were tabs.
        $(document).bindFirst('keydown.popupmenu', function handlePopupMenuKeydown(e) {
          var key = e.which,
            currentMenuItem = $(e.target);

          function isFocusedElement() {
            return this === document.activeElement;
          }

          function prevMenuItem() {
            // If the first item in the popup menu is already focused, close the menu and focus
            // on the last visible item in the tabs list.
            var first = menu.find('li:first-child > a');
            if (first.filter(isFocusedElement).length > 0) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();
              self.findLastVisibleTab();
            }
          }

          function nextMenuItem() {
            // If the last item in the popup menu is already focused, close the menu and focus
            // on the first visible item in the tabs list.
            var last = menu.find('li:last-child > a');
            if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();

              if (self.settings.addTabButton) {
                self.addTabButton.focus();
                return;
              }
              self.findFirstVisibleTab();
            }
          }

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
              return;
            }
            //self.popupmenu.close();
            self.closeDismissibleTab(currentMenuItem.attr('href'));
            return;
          }

          var pseudoKeycode;

          switch(key) {
            case 8:
            case 46:
              closeDropdownMenuItem(e);
              break;
            case 37: // left
              pseudoKeycode = isRTL ? 40 : 38;
              if (currentMenuItem.is('a')) {
                if (currentMenuItem.parent().is(':not(:first-child)')) {
                  e.preventDefault(); // Prevent popupmenu from closing on left key
                }
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 38: // up
              prevMenuItem();
              break;
            case 39: // right
              pseudoKeycode = isRTL ? 38 : 40;
              if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 40: // down
              nextMenuItem();
              break;
          }
        });
      },

      // Used for checking if a particular tab (in the form of a jquery-wrapped list item) is spilled into
      // the overflow area of the tablist container <UL>.
      isTabOverflowed: function(li) {
        if (this.isVerticalTabs() || this.isScrollableTabs()) {
          return false;
        }

        if (this.tablist.scrollTop() > 0) {
          this.tablist.scrollTop(0);
        }

        var liTop = Math.round(li[0].getBoundingClientRect().top),
          tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1);

        // +1 to compensate for top border on Module Tabs
        if (this.isModuleTabs()) {
          tablistTop = tablistTop + 1;
        }

        return liTop > tablistTop;
      },

      findLastVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)'),
          targetFocus = tabs.first();

        // if Scrollable Tabs, simply get the last tab and focus.
        if (this.isScrollableTabs()) {
          return tabs.last().find('a').focus();
        }

        while(!(this.isTabOverflowed(targetFocus))) {
          targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
        }
        tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
      },

      findFirstVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
        tabs.eq(0).find('a').focus();
      },

      focusBar: function(li, callback) {
        if (!this.hasAnimatedBar()) {
          return;
        }

        if (!(li instanceof $) || !li.length) {
          return;
        }

        var self = this,
          target = li,
          scrollingTablist = this.tablistContainer,
          isRTL = Locale.isRTL(),
          paddingLeft, paddingRight, width,
          tabMoreWidth,
          tablistScrollWidth,
          tablistScrollLeft,
          anchorStyle, targetStyle;

        this.animatedBar.removeClass('no-transition');

        if (!target || target === undefined || !target.length || !self.anchors.length) {
          this.animatedBar.removeClass('visible');
          return;
        }

        targetStyle = window.getComputedStyle(target[0], null);
        paddingLeft = parseInt(targetStyle.getPropertyValue('padding-left'), 10) || 0;
        paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
        width = parseInt(targetStyle.getPropertyValue('width')) || 0;

        if (target.is('.tab')) {
          anchorStyle = window.getComputedStyle(target.children('a')[0]);
          paddingLeft += parseInt(anchorStyle.getPropertyValue('padding-left'), 10) || 0;
          paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
        }

        var left = isRTL ?
          (paddingRight + target.position().left + target.outerWidth(true)) : (target.position().left);

        clearTimeout(self.animationTimeout);
        this.animatedBar.addClass('visible');

        function animationTimeout(cb) {
          var style = self.animatedBar[0].style;
          tablistScrollLeft = scrollingTablist[0].scrollLeft;
          tablistScrollWidth = scrollingTablist[0].scrollWidth;
          tabMoreWidth = this.moreButton.outerWidth(true);

          if (isRTL) {
            style.right = tablistScrollWidth + paddingRight - (left + tablistScrollLeft) + 'px';
          } else {
            style.left = left + tablistScrollLeft + 'px';
          }
          style.width = width + 'px';

          if (cb && typeof cb === 'function') {
            cb();
          }
        }
        this.animationTimeout = setTimeout(animationTimeout.apply(this, [callback]), 0);
      },

      defocusBar: function() {
        if (!this.hasAnimatedBar()) {
          return;
        }

        var self = this,
          left = Locale.isRTL() ? 0 : (self.animatedBar.position().left+(self.animatedBar.outerWidth()/2));

        clearTimeout(self.animationTimeout);

        this.animatedBar[0].style.left = left + 'px';
        this.animatedBar[0].style.width = 0;

        this.animationTimeout = setTimeout(function() {
          if (self.animatedBar && self.animatedBar.length) {
            self.animatedBar.removeClass('visible').removeAttr('style');
          }
        }, 350);
      },

      /**
       * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
       * @param {jQuery[]} target - the target <li> or <a> tag
       * @param {Number} duration - the time it will take to scroll
       * @returns {undefined}
       */
      scrollTabList: function(target) {
        if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
          return;
        }

        var tabCoords = Soho.DOM.getDimensions(target[0]),
          tabContainerDims = Soho.DOM.getDimensions(this.tablistContainer[0]),
          d;

        var FADED_AREA = 40, // the faded edges on the sides of the tabset
          adjustedLeft = tabCoords.left,
          adjustedRight = tabCoords.right;

        if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
          d = (Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1) - FADED_AREA;
        }
        if (adjustedRight > tabContainerDims.right - FADED_AREA) {
          d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
        }

        if (d === 0) {
          d = undefined;
        }

        // Scroll the tablist container
        this.tablistContainer.smoothScroll(d, 250);
      },

      hideFocusState: function() {
        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }
      },

      positionFocusState: function(target, unhide) {
        if (!this.hasSquareFocusState()) {
          return;
        }

        var self = this;
        target = target !== undefined ? $(target) :
            self.moreButton.hasClass('is-selected') ? self.moreButton :
            self.tablist.children('.is-selected').length > 0 ? self.tablist.children('.is-selected').children('a') : undefined;

        if (!target || target === undefined || !target.length || (target.is(this.moreButton) && this.isScrollableTabs())) {
          this.focusState.removeClass('is-visible');
          return;
        }

        // Use the parent <li> for anchors to get their dimensions.
        if (target.is('a')) {
          target = target.parent();
        }

        // Move the focus state from inside the tab list container, if applicable.
        // Put it back into the tab list container, if not.
        if (target.is('.add-tab-button, .tab-more')) {
          if (!this.focusState.parent().is(this.element)) {
            this.focusState.prependTo(this.element);
          }
        } else {
          if (!this.focusState.parent().is(this.tablistContainer)) {
            this.focusState.prependTo(this.tablistContainer);
          }
        }

        var focusStateElem = this.focusState[0],
          targetPos = Soho.DOM.getDimensions(target[0]),
          targetClassList = target[0].classList,
          isNotHeaderTabs = (!this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate')),
          isVerticalTabs = this.isVerticalTabs(),
          isRTL = Locale.isRTL(),
          tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0,
          parentContainer = this.element,
          scrollingTablist = this.tablistContainer,
          accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

        function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
          var parentRect = parentElement[0].getBoundingClientRect(),
            parentPadding,
            tabLeftMargin,
            tablistScrollWidth,
            tablistScrollLeft;

          // Adjust from the top
          targetRectObj.top = targetRectObj.top - parentRect.top;
          if (isVerticalTabs) {
            targetRectObj.top = targetRectObj.top + parentElement[0].scrollTop;
          }

          if (isRTL) {
            targetRectObj.right = parentRect.right - targetRectObj.right;
          } else {
            targetRectObj.left = targetRectObj.left - parentRect.left;
          }

          // If inside a scrollable tablist, account for the scroll position
          if (tablistContainer) {
            tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
            tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

            if (isRTL && !isVerticalTabs) {
              // TODO: Improve this calculation because there's something off
              var tmpLeft = targetRectObj.left;
              if (isNotHeaderTabs) {
                tabLeftMargin = parseInt(window.getComputedStyle(target[0]).marginLeft);
                targetRectObj.left = tablistScrollWidth - tabLeftMargin - targetRectObj.right + tablistScrollLeft;
                targetRectObj.right = tablistScrollWidth - tabLeftMargin - tmpLeft + tablistScrollLeft;
              } else {
                targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + (tabMoreWidth) + 32);
                targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + (tabMoreWidth) + 32);
              }
            } else {
              targetRectObj.left = targetRectObj.left + tablistScrollLeft;
              targetRectObj.right = targetRectObj.right + tablistScrollLeft;
            }

            if (accountForPadding) {
              parentPadding = parseInt(window.getComputedStyle(parentElement[0])[ 'padding' + (isRTL ? 'Right' : 'Left') ]);
              targetRectObj.left = targetRectObj.left + (isRTL ? parentPadding : (parentPadding * -1));
              targetRectObj.right = targetRectObj.right + (isRTL ? parentPadding : (parentPadding * -1));
            }
          }

          // Alternate Header Tabs have 1px removed from bottom to prevent overlap onto the bottom border
          if (isNotHeaderTabs && !isVerticalTabs) {
            targetRectObj.height = targetRectObj.height - 1;
          }

          return targetRectObj;
        }

        // Adjust the values one more time if we have tabs contained inside of a page-container, or some other scrollable container.
        targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist);

        // build CSS string containing each prop and set it:
        var targetPosString = '';
        for (var property in targetPos) {
          if (targetPos.hasOwnProperty(property)) {
            if (targetPosString.length) {
              targetPosString += ' ';
            }
            targetPosString += '' + property + ': ' + targetPos[property] + 'px;';
          }
        }
        focusStateElem.setAttribute('style', targetPosString);

        var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
        focusStateElem.classList[selected]('is-selected');

        var doHide = unhide === true ? 'add' : 'remove';
        focusStateElem.classList[doHide]('is-visible');
      },

      checkFocusedElements: function() {
        var self = this,
          focusableItems = self.tablist;

        if (this.hasSquareFocusState() && focusableItems.find('.is-focused').length === 0 && !self.moreButton.hasClass('is-focused') && !self.moreButton.hasClass('popup-is-open')) {
          self.focusState.removeClass('is-visible');
        }

        if (this.hasAnimatedBar() && focusableItems.find('.is-selected').length === 0 && !self.moreButton.hasClass('is-selected')) {
          self.defocusBar();
        }
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Disables all tabs in the
      disableOtherTabs: function() {
        return this.disable(true);
      },

      disable: function(isPartial) {
        if (!isPartial) {
          this.element.prop('disabled', true).addClass('is-disabled');
        }

        if (!this.disabledElems) {
          this.disabledElems = [];
        }

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');
          if (isPartial) {
            tabs = tabs.filter(':not(.application-menu-trigger)');
          }


        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          if (isPartial && self.isActive(a.attr('href'))) {
            return;
          }

          if (li.is('.is-disabled') || a.prop('disabled') === true) {
            self.disabledElems.push({
              elem: li,
              originalTabindex: li.attr('tabindex'),
              originalDisabled: a.prop('disabled')
            });
          }

          li.addClass('is-disabled');
          a.prop('disabled', true);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.addClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (t.is('input.dropdown, input.multiselect')) {
              return;
            }

            if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
              self.disabledElems.push({
                elem: t,
                originalTabindex: t.attr('tabindex'),
                originalDisabled: t.prop('disabled')
              });
            }

            t.disable();
          });
        });

        this.moreButton.addClass('is-disabled');

        if (this.isModuleTabs() && !isPartial) {
          this.element.children('.toolbar').disable();
        }

        this.updateAria($());
      },

      enable: function() {
        this.element.prop('disabled', false).removeClass('is-disabled');

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');

        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          li.removeClass('is-disabled');
          a.prop('disabled', false);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.removeClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);
            if (t.enable && typeof t.enable === 'function') {
              t.enable();
            }
          });

          $.each(self.disabledElems, function(i, obj) {
            var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;
            if (obj.elem.disable && typeof obj.elem.disable === 'function') {
              obj.elem.disable();
            }

            if (obj.elem.is('li')) {
              obj.elem.addClass('is-disabled');
              return;
            }

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (obj.elem.is('input.dropdown, input.multiselect')) {
              return;
            }

            obj.elem.attr('tabindex', obj.originalTabindex);
            attrTarget.prop('disabled', obj.originalDisabled);
          });
        });

        this.moreButton.removeClass('is-disabled');

        if (this.isModuleTabs()) {
          this.element.children('.toolbar').enable();
        }

        this.disabledElems = [];

        this.updateAria(this.tablist.find('.is-selected > a'));
      },

      closeDismissibleTab: function(tabId) {
        return this.remove(tabId);
      },

      teardown: function() {
        this.panels.removeAttr('style');

        this.tablist
          .off()
          .removeAttr('role')
          .removeAttr('aria-multiselectable');

        var tabs = this.tablist.children('li');
        tabs
          .off()
          .removeAttr('role')
          .removeClass('is-selected');

        var dds = tabs.filter('.has-popupmenu');
        dds.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.menu.children('li:not(.separator)').each(function() {
              var li = $(this),
                a = li.children('a'),
                panel = a.data('panel-link');

              $.removeData(a[0], 'panel-link');
              if (panel && panel.length) {
                $.removeData(panel[0], 'tab-link');
              }
            });
            popup.destroy();
          }
        });

        this.panels
          .off();

        this.anchors
          .off()
          .removeAttr('role')
          .removeAttr('aria-expanded')
          .removeAttr('aria-selected')
          .removeAttr('tabindex');

        if (this.settings.moduleTabsTooltips) {
          this.anchors.each(function() {
            var api = $(this).data('tooltip');
            if (api && typeof api.destroy === 'function') {
              api.destroy();
            }
          });
        }

        this.element.off('focusout.tabs updated.tabs activated.tabs');
        $('body').off('resize.tabs' + this.tabsIndex);
        this.tabsIndex = undefined;

        if (this.moreButton.data('popupmenu')) {
          var popup = this.moreButton.data('popupmenu');
          popup.menu.find('li:not(.separator)').each(function() {
            var li = $(this),
              a = li.children('a');

            if (a.data('original-tab')) {
              $.removeData(a[0], 'original-tab');
            }
          });
          popup.destroy();
        }

        this.removeHelperMarkupEvents();

        if (this.tablistContainer) {
          this.tablistContainer.off('mousewheel.tabs');
        }

        if (this.hasSquareFocusState()) {
          this.focusState.remove();
          this.focusState = undefined;
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.remove();
          this.animatedBar = undefined;
        }

        return this;
      },

      destroy: function(){
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tabs(this, settings));
      }
    });
  };

  // Deprecated the old Vertical Tabs code in favor of using the Tabs class.
  $.fn.verticaltabs = $.fn.tabs;


  $.fn.tag = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'tag',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tag(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tag Methods
    Tag.prototype = {

      /**
       * @private
       */
      init: function() {
        this.element.hideFocus();
        this.handleEvents();
      },

      /**
       * Remove the tag from the DOM
       */
      remove: function(event, el) {
        el = el instanceof jQuery ? el : $(el);
        var parent = el.parent();
        this.element.triggerHandler('beforetagremove', {event: event, element: el});
        el.remove();
        parent.triggerHandler('aftertagremove', {event: event});
      },

      /**
       * Destroy this component instance and remove the link from its base element.
       */
      destroy: function() {
        this.element.off('keydown.tag');
        $('.dismissable-btn, .dismissible-btn', this.element).off('click.tag').remove();

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Tag#events
       * @param {Object} click  &nbsp;-&nbsp; Fires when the tag is clicked (if enabled).
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when the tag is focused.
       */
      handleEvents: function() {
        var self = this,
          btnDismissable = $(
            '<span class="dismissible-btn">' +
              $.createIcon('close') +
              '<span class="audible"> '+ Locale.translate('Close') +'</span>' +
            '</span>'),
          dismissibleClass = '.is-dismissable, .is-dismissible';

        // EPC: Deprecating "dismissable" in favor of "dismissible" as of 4.3.0
        if (self.element.is(dismissibleClass)) {
          self.element.append(btnDismissable);

          // Handle Click
          btnDismissable.on('click.tag', function(event) {
            self.remove(event, self.element);
          });

          // Handle Keyboard
          self.element.on('keydown.tag', function(event) {
            var e = event || window.event;
            if (e.keyCode === 8) { // Backspace
              self.remove(event, this);
            }
          });
        }
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tag(this, settings));
      }
    });
  };


  $.fn.textarea = function(options) {

    // Settings and Options
    var pluginName = 'textarea',
        defaults = {
          characterCounter: true,
          printable: true,
          charRemainingText: null,
          charMaxText: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * The Textarea Component wraps a standard HTML Textarea element and provides additional features.
     *
     * @class Textarea
     * @param {boolean} characterCounter &nbsp;-&nbsp; Displays a counter that counts down from the maximum length allowed.
     * @param {boolean} printable &nbsp;-&nbsp; Determines whether or not the text area can be displayed on a printed page.
     * @param {null|String} charRemainingText  &nbsp;-&nbsp; Text that will be used in place of the "remaining" text.
     * @param {null|String} charMaxText  &nbsp;-&nbsp; Text that will be used in place of the "Max" text.
     */
    function Textarea(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Textarea.prototype = {

      /**
       * @private
       */
      init: function() {
        this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        this.isSafari = (
          navigator.userAgent.indexOf('Safari')  !== -1 &&
          navigator.userAgent.indexOf('Chrome') === -1 &&
          navigator.userAgent.indexOf('Android') === -1
        );

        this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' :
            this.element.is('.textarea-sm') ? 'input-sm' :
            this.element.is('.textarea-lg') ? 'input-lg' : '');

        if (this.settings.characterCounter && this.element.attr('maxlength')) {
          this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
        }
        if (this.settings.printable) {
          this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
        }
        this.handleEvents();
        this.updateCounter(this);
      },

      /**
       * @private
       */
      // TODO: What does this do?
      isSelected: function (input) {
        if (typeof input.selectionStart === 'number') {
          return input.selectionStart === 0 && input.selectionEnd === input.value.length;
        } else if (typeof document.selection !== 'undefined') {
          input.focus();
          return document.selection.createRange().text === input.value;
        }
      },

      /**
       * Checks a keycode value and determines if it belongs to a printable character.
       * @param {Number} keycode - a number representing an ASCII keycode value
       * @returns {boolean}
       */
      isPrintable: function(keycode) {
        var valid =
          (keycode > 47 && keycode < 58)   || // number keys
          (keycode > 64 && keycode < 91)   || // letter keys
          (keycode > 95 && keycode < 112)  || // numpad keys
          (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
          (keycode > 218 && keycode < 223);   // [\]' (in order)
        return valid;
      },

      /**
       * Counts the number of line breaks in a string
       * @param {String} s
       * @returns {Number}
       */
      countLinebreaks: function(s) {
        return (s.match(/\n/g) || []).length;
      },

      /**
       * Updates the descriptive markup (counter, etc) to notify the user how many characters can be typed.
       * @private
       * @param {TextArea} self
       */
      updateCounter: function (self) {
        var value = self.element.val(),
          isExtraLinebreaks = this.isChrome || this.isSafari,
          length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0),
          max = self.element.attr('maxlength'),
          remaining = (parseInt(max)-length),
          text = (self.settings.charRemainingText ? self.settings.charRemainingText : (Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft'))).replace('{0}', remaining.toString());

        if (self.counter) {
          if (length === 0) {
            text = (self.settings.charMaxText ? self.settings.charMaxText : Locale.translate('CharactersMax')) + max;
            self.counter.text(text);
            self.counter.removeClass('almost-empty');
          } else {
            self.counter.text(text);
            if (remaining < 10) {
              self.counter.addClass('almost-empty');
            } else {
              self.counter.removeClass('almost-empty');
            }
          }
        }

        if (self.printarea) {
          self.printarea.text(self.element.val());
        }
      },

      /**
       * Enables this component instance.
       */
      enable: function () {
        this.element.prop('disabled', false).prop('readonly', false);
      },

      /**
       * Disables this component instance.
       */
      disable: function () {
        this.element.prop('disabled', true);
      },

      /**
      * Returns true if the texarea is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Sets this component instance to "readonly"
       */
      readonly: function () {
        this.element.prop('readonly', true);
      },

      /**
       * Call whenever the plugin's settings are changed
       */
      updated: function () {
        this.destroy();
        this.init();
      },

      /**
       * Destroys this component instance and unlinks it from its element.
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        if (this.printarea && this.printarea.length) {
          this.printarea.remove();
        }
        if (this.counter && this.counter.length) {
          this.counter.remove();
        }
        this.element.off('keyup.textarea, focus.textarea, updated.dropdown, keypress.textarea, blur.textarea');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Textarea#events
       * @param {Object} keyup  &nbsp;-&nbsp; Fires when the button is clicked (if enabled).
       * @param {Object} focus  &nbsp;-&nbsp; Fires when the menu is focused.
       * @param {Object} keypress  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       */
      handleEvents: function() {
        var self = this;

        this.element.on('keyup.textarea', function () {
          self.updateCounter(self);
        }).on('focus.textarea', function () {
          if (self.counter) {
            self.counter.addClass('focus');
          }
        }).on('updated.dropdown', function () {
          self.updated();
        }).on('keypress.textarea', function (e) {
          var length = self.element.val().length,
          max = self.element.attr('maxlength');

          if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
            self.updateCounter(self);
            return;
          }

          if (!self.isPrintable(e.which)) {
            return;
          }

          if (length >= max && !self.isSelected(this)) {
            e.preventDefault();
          }

        })
        .on('blur.textarea', function () {
          self.updateCounter(self);
          if (self.counter) {
            self.counter.removeClass('focus');
          }
        });
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Textarea(this, settings));
      }
    });
  };


  $.fn.timepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'timepicker',
        defaults = {
          timeFormat: Locale.calendar().timeFormat || 'h:mm a', // The time format
          minuteInterval: 5,
          secondInterval: 5,
          mode: 'standard',
          roundToInterval: false,
          parentElement: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Timepicker Component provides a click/touch user interface for setting a time.
    *
    * @class TimePicker
    * @param {String} timeFormat &nbsp;-&nbsp; The time format
    * @param {Number} minuteInterval  &nbsp;-&nbsp; Integer from 1 to 60.  Multiples of this value are displayed as options in the minutes dropdown.
    * @param {Number} secondInterval  &nbsp;-&nbsp; Integer from 1 to 60.
    * @param {String} mode  &nbsp;-&nbsp; can be set to 'standard', 'range',
    * @param {boolean} roundToInterval  &nbsp;-&nbsp; if `true`, automatically rounds user-entered values from the pickers to their nearest interval.
    * @param {null|jQuery[]} [parentElement] &nbsp;-&nbsp;  if defined as a jQuery-wrapped element, will be used as the target element.
    */
    function TimePicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    TimePicker.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        this
          .setup()
          .build()
          .handleEvents()
          .roundMinutes();
      },

      /**
       * Configure any settings for the Timepicker
       * @private
       * @returns {this}
       */
      setup: function() {

        function sanitizeIntervals(value, type) {
          if (!type || ['minute', 'second'].indexOf(type) < 0) {
            type = 'minute';
          }

          var defaultInterval = defaults[(type + 'Interval')];
          if (value === undefined || isNaN(value)) {
            return defaultInterval;
          }
          var intValue = parseInt(value, 10);
          return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
        }

        function sanitizeTimeFormat(value) {
          if (!value || (!value.match('h') && !value.match('HH')) || !value.match('mm')) {
            return defaults.timeFormat;
          }

          return value;
        }

        function sanitizeRoundToInterval(value) {
          return value === true;
        }

        function sanitizeMode(value) {
          var modes = ['standard', 'range'];
          return $.inArray(value, modes) > -1 ? value : defaults.mode;
        }

        if (this.element.is('[data-round-to-interval]')) {
          this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
        }
        if (this.element.is('[data-minute-interval]')) {
          this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
        }

        this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode')) === 24 ? 'HH:mm' : this.settings.timeFormat);
        this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
        this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
        this.settings.mode = sanitizeMode(this.settings.mode);
        this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);

        this.dayPeriods = Locale.calendar().dayPeriods;

        return this;
      },

      /**
       * Add any markup
       * @private
       * @returns {this}
       */
      build: function() {
        //With this option forgoe the input and append the dropdowns/popup to the parent element
        if (this.settings.parentElement) {
          this.trigger = $();
          this.buildStandardPopup();
          this.setupStandardEvents();
          return this;
        }

        //Append a Button
        this.trigger = this.element.next('svg.icon');
        if (this.trigger.length === 0) {
          this.trigger = $.createIconElement('clock').insertAfter(this.element);
        }

        this.addAria();

        // Add Mask and Validation plugins for time
        this.mask();

        return this;
      },

      /**
       * Adds ARIA-related attributes
       * @private
       * @returns {this}
       */
      addAria: function () {
        this.element.attr({
          'aria-expanded': 'false',
          'role': 'combobox'
        });

        //TODO: Confirm this with Accessibility Team
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      /**
       * Sets up a `keydown` event listener.
       */
      handleKeys: function() {
        var self = this;

        this.element.on('keydown.timepicker', function (e) {
          var handled = false;

          // Esc closes an open popup with no action
          if (e.which === 27 && self.isOpen()) {
            handled = true;
            self.closeTimePopup();
          }

          //Arrow Down or Alt first opens the dialog
          if (e.which === 40 && !self.isOpen()) {
            handled = true;
            self.openTimePopup();
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        });
      },

      /**
       * Sets up a `blur` event listener.
       */
      handleBlur: function() {
        var self = this;

        this.element.on('blur.timepicker', function() {
          self.roundMinutes();

          // The action of closing the popup menu is set on a timer because technically there are no fields focused
          // on frame 0 of the popup menu's existence, which would cause it to close immediately on open.
          setTimeout(function() {
            if (self.isOpen() && self.popup.find(':focus').length === 0) {
              self.closeTimePopup();
            }
          }, 20);
        });
      },

      /**
       * Checks a time format value to see if it is a Military (24-hour) format.
       * @param {String} value - a string value representing a time format.
       * @returns {boolean}
       */
      is24HourFormat: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('HH') || []).length > 0;
      },

      /**
       * Checks a time format value to see if it includes seconds.
       * @param {String} value - a string value representing a time format.
       * @returns {boolean}
       */
      hasSeconds: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('ss') || []).length > 0;
      },

      /**
       * Gets a Locale-defined version of the time separator.
       * @returns {String}
       */
      getTimeSeparator: function() {
        return Locale.calendar().dateFormat.timeSeparator;
      },

      /**
       * Rounds the current value of the minutes picker to its nearest interval value.
       */
      roundMinutes: function() {
        if (!this.getBoolean(this.settings.roundToInterval)) {
          return;
        }

        // separate out the minutes value from the rest of the value.
        var val = this.element.val(),
          timeSeparator = this.getTimeSeparator(),
          parts = val ? val.split(timeSeparator) : [],
          interval = this.settings.minuteInterval;

        if (!parts[1]) {
          return;
        }

        if (!this.is24HourFormat(this.settings.timeFormat)) {
          var periodParts = parts[1].split(' ');
          parts[1] = periodParts[0];
          if (periodParts[1]) {
            parts.push(periodParts[1]);
          }
        }

        parts[1] = parseInt(parts[1], 10);
        if (parts[1] % interval === 0) {
          return;
        }

        parts[1] = Math.round(parts[1] / interval) * interval;

        parts[1] = parts[1].toString();
        parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

        if (parts[1] === '60') {
          parts[1] = '00';
          parts[0] = (parseInt(parts[0]) + 1).toString();
        }

        var newVal = parts[0] + timeSeparator + parts[1] + ' ' + (parts[2] ? parts[2] : '');
        this.element.val(newVal);
      },

      // Add masking with the mask function
            mask: function () {
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }
        this.element.data('mask', undefined);

        var timeSeparator = this.getTimeSeparator(),
          mask = '##' + timeSeparator + '##' + (this.hasSeconds() ? timeSeparator + '##' : '') + (!this.is24HourFormat() ? ' am' : ''),
          maskMode = 'group',
          validation = 'time',
          events = {'time': 'blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events');

        if (customValidation === 'required' && !customEvents) {
            validation = customValidation + ' ' + validation;
            $.extend(events, {
                'required': 'change blur'
            });
        } else if (!!customValidation && !!customEvents) {
            // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
            if (customValidation.indexOf('no-default-validation') > -1) {
                validation = customValidation.replace(/no-default-validation/g, '');
                events = $.fn.parseOptions(this.element, 'data-validation-events');
            }
                // Keep default validation along custom validation
            else {
                validation = customValidation + ' ' + validation;
                $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
            }
        }

        this.element
          .attr('data-validate', validation)
          .attr('data-validation-events', JSON.stringify(events))
          .mask({
            pattern: mask,
            mode: maskMode
          })
          .validate()
          .triggerHandler('updated');
      },

      /**
       * Constructs all markup and subcomponents needed to build the standard Timepicker popup.
       * @private
       */
      buildStandardPopup: function() {
        var self = this,
          popupContent = $('<div class="timepicker-popup-content"></div>'),
          timeSeparator = this.getTimeSeparator(),
          textValue = '',
          secondSelect,
          selected;

        this.initValues = self.getTimeFromField();
        var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent);

        // Build the inner-picker HTML
        var is24HourFormat = this.is24HourFormat(),
          hasSeconds = this.hasSeconds(),
          hourCounter = is24HourFormat ? 0 : 1,
          maxHourCount = is24HourFormat ? 24 : 13;

        this.hourSelect = $('<select id="timepicker-hours" class="hours dropdown"></select>');

        while(hourCounter < maxHourCount) {
          selected = '';
          if (parseInt(self.initValues.hours, 10)  === hourCounter) {
            selected = ' selected';
          }
          self.hourSelect.append($('<option' + selected + '>' + hourCounter + '</option>'));
          hourCounter++;
        }
        timeParts.append($('<label for="timepicker-hours" class="audible">' + Locale.translate('Hours') + '</label>'));
        timeParts.append(this.hourSelect);
        timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));

        // Minutes Picker
        var minuteCounter = 0;
        this.minuteSelect = $('<select id="timepicker-minutes" class="minutes dropdown"></select>');

        while(minuteCounter <= 59) {
          textValue = minuteCounter < 10 ? '0' + minuteCounter : minuteCounter;

          selected = '';
          if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
            selected = ' selected';
          }
          self.minuteSelect.append($('<option' + selected + '>' + textValue + '</option>'));
          minuteCounter = minuteCounter + self.settings.minuteInterval;
        }

        // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
        if (!this.minuteSelect.find('option[selected]').length) {
          this.minuteSelect.prepend($('<option selected>' + self.initValues.minutes + '</option>'));
        }

        timeParts.append($('<label for="timepicker-minutes" class="audible">' + Locale.translate('Minutes') + '</label>'));
        timeParts.append(this.minuteSelect);

        // Seconds Picker
        if (hasSeconds) {
          var secondCounter = 0;
          secondSelect = $('<select id="timepicker-seconds" class="seconds dropdown"></select>');

          while(secondCounter <= 59) {
            textValue = secondCounter < 10 ? '0' + secondCounter : secondCounter;

            selected = '';
            if (parseInt(self.initValues.seconds, 10) === secondCounter || (!self.initValues.seconds && textValue === '00')) {
              selected = ' selected';
            }
            secondSelect.append($('<option' + selected + '>' + textValue + '</option>'));
            secondCounter = secondCounter + self.settings.secondInterval;
          }

          // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
          if (!secondSelect.find('option[selected]').length) {
            secondSelect.prepend($('<option selected>' + self.initValues.seconds + '</option>'));
          }

          timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));
          timeParts.append($('<label for="timepicker-seconds" class="audible">' + Locale.translate('Seconds') + '</label>'));
          timeParts.append(secondSelect);
        }

        this.periodSelect = $('<select id="timepicker-period" class="period dropdown"></select>');
        if (!is24HourFormat) {
          timeParts.append($('<span class="label colons"></span>'));
          var localeDays = Locale.calendar().dayPeriods,
            localeCount = 0,
            regexDay = new RegExp(self.initValues.period, 'i'),
            realDayValue = 'AM'; // AM

          while(localeCount < 2) {
            realDayValue = localeCount === 0 ? 'AM' : 'PM';  // ? AM : PM
            selected = '';
            if (regexDay.test(localeDays[localeCount])) {
              selected = ' selected';
            }
            this.periodSelect.append($('<option value="' + realDayValue + '"'+ selected +'>' + localeDays[localeCount] + '</option>'));

            localeCount++;
          }
          timeParts.append($('<label for="timepicker-period" class="audible">' + Locale.translate('TimePeriod') + '</label>'));
          timeParts.append(this.periodSelect);
        }

        if (this.settings.parentElement) {
          this.settings.parentElement.append(popupContent);
          //self.afterShow(this.settings.parentElement);
          self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
        } else {

          popupContent.append('<div class="modal-buttonset"><button type="button" class="btn-modal-primary set-time">' + Locale.translate('SetTime') + '</button></div>');

          var placementParent = this.element,
            placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
            parent = this.element.parent();

          if (parent.is('.datagrid-cell-wrapper')) {
            placementParentXAlignment = 'center';
            placementParent = this.element.next('.icon');
          }

          this.trigger.popover({
            content: popupContent,
            trigger: 'immediate',
            placement: 'bottom',
            placementOpts: {
              parent: placementParent,
              parentXAlignment: placementParentXAlignment,
              strategies: ['flip', 'nudge', 'shrink']
            },
            tooltipElement: '#timepicker-popup'})
          .on('show.timepicker', function(e, ui) {
            self.afterShow(ui);
          }).on('hide.timepicker', function() {
            self.element.focus();
          });
        }

        // Make adjustments to the popup HTML specific to the timepicker
        if (this.trigger.data('tooltip')) {
          var tooltip = self.popup = this.trigger.data('tooltip').tooltip;
          tooltip.addClass('timepicker-popup');
        }
      },

      afterShow: function (ui) {
        var self = this;

        ui.find('button').button();

        // Set default values based on what's retrieved from the Timepicker's input field.
        this.hourSelect.val(this.initValues.hours);
        this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
        this.minuteSelect.val(this.initValues.minutes);
        this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);

        if (!self.is24HourFormat()) {
          this.periodSelect.val(this.initValues.period);
          this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
        }

        ui.find('div.dropdown').first().focus();
        ui.find('.set-time').off('click.timepicker').onTouchClick('timepicker').on('click.timepicker', function(e) {
          e.preventDefault();
          self.setTimeOnField();
          self.closeTimePopup();
        });
      },

      /**
       * Sets up events that need to be bound to a standard time picker.
       * @private
       */
      setupStandardEvents: function() {
        var self = this;

        self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function(e) {
          e.preventDefault();
          e.target.click();
        }).on('keydown.timepicker', 'input.dropdown', function(e) {
          var handled = false;

          // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.
          if (e.which === 27) {
            handled = true;
            self.closeTimePopup();
            self.element.focus();
          }

          // Pressing Spacebar while the popup is open submits with the new time value.
          if (e.which === 32) {
            handled = true;
            self.popup.find('.set-time').click();
          }

          // Left & Right Arrows will switch between the available dropdowns
          if (e.which === 37 || e.which === 39) {
            handled = true;
            var inputs = self.popup.find('input[id$="-shdo"]');

            if (e.which === 37) {
              var prev = inputs.eq(inputs.index(this) - 1);
              if (!prev || prev.length === 0) {
                prev = inputs.eq(inputs.length);
              }
              prev.focus();
            }

            if (e.which === 39) {
              var next = inputs.eq(inputs.index(this) + 1);
              if (!next || next.length === 0) {
                next = inputs.eq(0);
              }
              next.focus();
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Listen to the popover/tooltip's "hide" event to properly close out the popover's inner controls.
        self.trigger.on('hide.timepicker', function() {
          self.onPopupHide();
        });
      },

      /**
       * @private
       */
      buildRangePopup: function() {
        // TODO: Build this
      },

      /**
       * @private
       */
      setupRangeEvents: function() {
        // TODO: Build this
      },

      /**
       * Gets the value of the Timepicker field as an object separated into hours, minutes, (optional) seconds, and (optional) day period.
       * @param {String} [value] - this method can optionally be passed a string-based time value to calculate instead of the current field's value.
       * @returns {Object}
       * @returns {Object.hours}
       * @returns {Object.minutes}
       * @returns {Object.seconds}
       * @returns {Object.period}
       */
      getTimeFromField: function(value) {
        var self = this,
          val = value || this.element.val(),
          sep = this.getTimeSeparator(),
          parts = val.split(sep),
          endParts,
          timeparts = {};

        // Check the last element in the array for a time period, and add it as an array
        // member if necessary
        if (!this.is24HourFormat()) {
          endParts = parts[parts.length - 1].split(' ');
          parts.pop();
          parts = parts.concat(endParts);
        }

        function isDayPeriod(value) {
          return self.dayPeriods.indexOf(value) > -1;
        }

        function removeLeadingWhitespace(value) {
          return value.replace(/^\s+|\s+$/g, '');
        }

        function addLeadingZero(value) {
          if (!value || isNaN(value)) {
            return '00';
          }
          value = parseInt(value);
          value = value < 10 ? '0' + value : value;
          return value;
        }

        // Handle Hours
        if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
          parts[0] = '1';
        }

        parts[0] = parseInt(parts[0], 10);
        if (isNaN(parts[0])) {

        } else {
          parts[0] = '' + parseInt(parts[0], 10);
        }
        timeparts.hours = parts[0];

        // Handle Minutes
        if (parts[1]) {
          // remove leading whitespace
          parts[1] = removeLeadingWhitespace(parts[1]);
          parts[1] = addLeadingZero(parts[1]);
          timeparts.minutes = parts[1];
        } else {
          timeparts.minutes = '00';
        }

        // Handle Seconds/Period (slot 3)
        function handleSlot2(value) {
          // Should not kick off at all if we don't pass it a value, OR if this field is 24-hour display with no seconds
          if (!value) {
            if (!self.is24HourFormat()) {
              if (self.hasSeconds()) {
                value = '00';
                timeparts.seconds = value;
              } else {
                value = Locale.translateDayPeriod('AM');
                timeparts.period = value;
              }
            }

            return value;
          }

          value = removeLeadingWhitespace(value);

          // Has seconds
          if (self.hasSeconds()) {
            value = addLeadingZero(value);
            timeparts.seconds = value;
            return value;
          }
          // No seconds, but has a day period
          if (!isDayPeriod(value)) {
            value = Locale.translateDayPeriod('AM');
          }
          timeparts.period = value;
          return;
        }
        handleSlot2(parts[2]);

        // Handle Period after seconds (slot 4)
        if (parts[3]) {
          parts[3] = removeLeadingWhitespace(parts[3]);
          timeparts.period = parts[3];
        } else {
          if (!this.is24HourFormat() && this.hasSeconds()) {
            timeparts.period = Locale.translateDayPeriod('AM');
          }
        }

        return timeparts;
      },

      /**
       * Retrieves the values from the Timepicker popup's pickers and uses those values to set
       * the contents of the Timepicker field.
       */
      setTimeOnField: function() {
        var hours = $('#timepicker-hours').val() || '',
          minutes = $('#timepicker-minutes').val() || '',
          seconds = $('#timepicker-seconds').val() || '',
          period = ($('#timepicker-period').val() || '').toUpperCase(),
          sep = this.getTimeSeparator(),
          timeString = '' + hours + sep + minutes + (this.hasSeconds() ? sep + seconds : '');

        period = (!this.is24HourFormat() && period === '') ? $('#timepicker-period-shdo').val() : period;
        timeString += period ? ' ' + Locale.translateDayPeriod(period) : '';

        this.element.val(timeString)
          .trigger('change');

        this.element
          .focus();
      },

      /**
       * Return whether or not the Timepicker popup is open.
       * @returns {boolean}
       */
      isOpen: function () {
        return (this.popup && !this.popup.hasClass('is-hidden'));
      },

      /**
       * Opens the Timepicker popup, intializing all the dropdown elements and setting up internal events.
       */
      openTimePopup: function() {
        var self = this;

        // Get all current settings.
        self.setup();

        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        if (this.popup && !this.popup.hasClass('is-hidden')) {
          self.closeTimePopup();
        }

        this.element.addClass('is-active');

        // Build a different Time Popup based on settings
        if (self.settings.mode === 'range') {
          self.buildRangePopup();
          self.setupRangeEvents();
        } else {
          self.buildStandardPopup();
          self.setupStandardEvents();
        }

        this.element.attr({'aria-expanded': 'true'});
        this.popup.find('div.dropdown').first().focus();
      },

      /**
       * Triggers the "hide" method on the tooltip plugin.  The Timepicker officially "closes" after the popover's
       * hide event fully completes because certain events need to be turned off and certain markup needs to be
       * removed only AFTER the popover is hidden.
       */
      closeTimePopup: function() {
        if (this.trigger.data('tooltip')) {
          this.trigger.data('tooltip').hide();
        }
      },

      /**
       * This gets fired on the popover's "hide" event
       */
      onPopupHide: function() {
        if (this.settings.mode === 'standard') {
          $('#timepicker-hours').data('dropdown').destroy();
          $('#timepicker-minutes').data('dropdown').destroy();
          if (this.hasSeconds()) {
            $('#timepicker-seconds').data('dropdown').destroy();
          }
          if (!this.is24HourFormat()) {
            $('#timepicker-period').data('dropdown').destroy();
          }
          this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
        }
        this.element.attr({'aria-expanded': 'false'});
        this.trigger.off('hide.timepicker show.timepicker');
        this.trigger.data('tooltip').destroy();
        this.trigger.data('tooltip', undefined);
        $('#timepicker-popup').remove();
        this.element.removeClass('is-active');
      },

      /**
       * Toggles the visibility of the Timepicker popup.
       */
      toggleTimePopup: function() {
        if (this.isOpen()) {
          this.closeTimePopup();
        } else {
          this.openTimePopup();
        }
      },

      /**
       * Getter method for retrieving the value of the Timepicker.
       * @param {boolean} [removePunctuation] - Gets rid of all the value's punctatuion on return.
       * @returns {String}
       */
      value: function(removePunctuation) {
        var val = this.element.val();
        if (!removePunctuation || removePunctuation === false) {
          return val;
        }

        var timeSeparator = Locale.calendar().dateFormat.timeSeparator,
          sepRegex = new RegExp(timeSeparator, 'g');

        // Remove punctuation
        val = val.replace(sepRegex, '');

        // Add leading zero for times without a double digit hour
        var parts = val.split(' ');
        if (parts[0].length < 4) {
          val = '0' + parts[0] + (parts[1] ? parts[1] : '');
        }

        return val;
      },

      /**
       * Enables the Timepicker
       */
      enable: function() {
        this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
      },

      /**
      * Set input to readonly.
      */
      readonly: function() {
        this.enable();
        this.element.attr('readonly', 'readonly');
      },

      /**
       * Disables the Timepicker
       */
      disable: function() {
        this.enable();
        this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
      },

      /**
       * Detects whether or not the component is disabled
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Convert a string to boolean
       * @param {String} val - a text string ("true" or "false") that can be converted to a boolean.
       * @returns {boolean}
       */
      // TODO: Move this to Soho.utils?
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      /**
       * Updates the component instance.  Can be used after being passed new settings.
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Removes all event bindings, subcomponents and unnecessary markup from this component instance.
       * @private
       * @returns {this}
       */
      teardown: function() {
        this.trigger.off('keydown.timepicker');
        this.element.off('focus.timepicker blur.timepicker keydown.timepicker');
        if (this.popup) {
          this.closeTimePopup();
        }

        this.trigger.remove();

        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        this.label.find('.audible').remove();

        return this;
      },

      /**
       * Destroys the component instance.
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], 'validate');
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Add any markup
       * @fires TimePicker#events
       * @param {Object} click  &nbsp;-&nbsp;
       * @param {Object} touchstart  &nbsp;-&nbsp;
       * @param {Object} touchmove  &nbsp;-&nbsp;
       * @param {Object} touchend  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       */
      handleEvents: function () {
        var self = this;
        this.trigger.onTouchClick('timepicker').on('click.timepicker', function () {
          self.toggleTimePopup();
        });

        this.handleKeys();
        this.handleBlur();

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new TimePicker(this, settings));
      }
    });
  };

/**
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  @private
 */


  var Tmpl = window.Tmpl = {};

  Tmpl.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  };

  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope === 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get === 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o === token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c === close && tags[i].o === open) {
        return true;
      }
    }
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\'')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {}
    PartialTemplate.prototype = instance;
    function Substitutions() {}
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) {
        stackSubs[key] = subs[key];
      }
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) {
       stackPartials[key] = partials[key];
      }
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) !== tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) !== tag.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  function TmplEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  Tmpl.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; }, // jshint ignore:line

    // variable escaping
    v: TmplEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base === template) {
        return partial.instance;
      }

      if (typeof template === 'string') {
        if (!this.c) {
          throw new Error('No compiler available.');
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) {
          partials.stackText = {};
        }
        for (var key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!$.isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if ($.isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val === 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val === 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && $.isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val === 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : '';
      }

      if (!returnFound && typeof val === 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result === 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result === 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }
  };

  Tmpl.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Tmpl.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)}); // jshint ignore:line
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Tmpl.tags[tokens[j].tag] < Tmpl.tags._v) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null); // jshint ignore:line
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag === '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString();
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state === IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) === '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state === IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Tmpl.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType === '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType === '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType === '{') {
            if (ctag === '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);
    return tokens;
  };

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag === '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Tmpl.tags[token.tag] <= Tmpl.tags.$ || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag === '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n !== opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag === '\n') {
        token.last = (tokens.length === 0) || (tokens[0].tag === '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return '{ ' + items.join(',') + ' }';
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + '}');
    }
    return 'partials: {' + partials.join(',') + '}, subs: ' + stringifySubstitutions(codeObj.subs);
  }

  Tmpl.stringify = function(codeObj, text, options) { // jshint ignore:line
    return '{code: function (c,p,i) { ' + Tmpl.wrapMain(codeObj.code) + ' },' + stringifyPartials(codeObj) +  '}';
  };

  var serialNo = 0;
  Tmpl.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Tmpl.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  };

  Tmpl.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  };

  Tmpl.template = Tmpl.Template;

  Tmpl.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code)); // jshint ignore:line
    return new this.template(template, text, this, options);
  };

  Tmpl.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]); // jshint ignore:line
    }
    return template;
  };

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = '<' + (context.prefix || '');
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  Tmpl.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + ' ' + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Tmpl.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Tmpl.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Tmpl.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Tmpl.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  };

  Tmpl.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Tmpl.codegen[nodelist[i].tag];
      if (func) {
        func(nodelist[i], context);
      }
    }
    return context;
  };

  Tmpl.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  };

  Tmpl.cache = {};

  Tmpl.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  };

  Tmpl.compile = function(text, options) {
    options = options || {};
    var key = Tmpl.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    this.cache[key] = template;
    return template;
  };



  $.fn.toolbar = function(options) {
    'use strict';

    var pluginName = 'toolbar',
        defaults = {
          rightAligned: false,
          maxVisibleButtons: 3,
          resizeContainers: true,
          favorButtonset: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * The Toolbar Component manages various levels of application navigation.  It contains a group of buttons that functionally
     * related content. Each panel consists of two levels: the top level identifies the
     * category or section header, and the second level provides the associated options.
     *
     * @class Toolbar
     *
     * @param {boolean} rightAligned   &nbsp;-&nbsp; Will always attempt to right-align the contents of the toolbar.
     * @param {Number} maxVisibleButtons   &nbsp;-&nbsp; Total amount of buttons that can be present, not including the More button.
     * @param {boolean} resizeContainers   &nbsp;-&nbsp; If true, uses Javascript to size the Title and Buttonset elements in a way that shows as much of the Title area as possible.
     * @param {boolean} favorButtonset   &nbsp;-&nbsp; If "resizeContainers" is true, setting this to true will try to display as many buttons as possible while resizing the toolbar.  Setting to false attempts to show the entire title instead.
     */
    function Toolbar(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Toolbar.prototype = {

      /**
       * Initializes the Toolbar Component
       * @private
       * @chainable
       * @returns {this}
       */
      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      /**
       * Detects discrepencies in settings.  In general, configures the component based on user settings.
       * @private
       * @chainable
       * @returns {this}
       */
      setup: function() {
        // Can't have zero buttons
        if (this.settings.maxVisibleButtons <= 0) {
          this.settings.maxVisibleButtons = defaults.maxVisibleButtons;
        }

        return this;
      },

      /**
       * Adds additional markup, wraps some internal elements, and helps construct a complete Toolbar representation in the HTML Markup.  This method also builds the "More Actions" menu and ties its elements to the toolbar items.
       * @private
       * @chainable
       * @returns {this}
       */
      build: function() {
        var self = this;

        this.element.attr('role', 'toolbar');
        if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
          this.element[0].classList.add('do-resize');
        }

        this.buildAriaLabel();

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10));
        }

        // Check for a "title" element.  This element is optional.
        // If a title element exists, a tooltip will be created for when it's not
        // possible to show the entire title text on screen.
        this.title = this.element.children('.title');
        if (this.title.length) {
          this.element[0].classList.add('has-title');

          this.cutoffTitle = false;
          this.title.on('beforeshow.toolbar', function() {
            return self.cutoffTitle;
          }).tooltip({
            content: '' + this.title.text().trim()
          });
        } else {
          this.element[0].classList.remove('has-title');
        }

        // Container for main group of buttons and input fields.  Only these spill into the More menu.
        this.buttonset = this.element.children('.buttonset');
        if (!this.buttonset.length) {
          this.buttonset = $('<div class="buttonset"></div>');
          if (this.title.length) {
            this.buttonset.insertAfter(this.title);
          } else {
            this.buttonset.prependTo(this.element);
          }
        }

        this.buttonset[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned');

        // Add and invoke More Button, if it doesn't exist
        this.more = this.element.find('.btn-actions');
        if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
          var moreContainer = this.element.find('.more');

          if (!moreContainer.length) {
            moreContainer = $('<div class="more"></div>').appendTo(this.element);
          }

          this.more = $('<button class="btn-actions" type="button"></button>')
            .html($.createIcon({icon: 'more'}) +
              '<span class="audible">'+Locale.translate('MoreActions')+'</span>')
            .appendTo(moreContainer);
        }

        // Reference all interactive items in the toolbar
        this.buttonsetItems = this.buttonset.children('button')
          .add(this.buttonset.find('input')); // Searchfield Wrappers

        // Items contains all actionable items in the toolbar, including the ones in the title, and the more button
        this.items = this.buttonsetItems
          .add(this.title.children('button'))
          .add(this.more);

        // Invoke buttons
        var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
        buttons.each(function() {
          var buttonControl = $(this).data('button');
          if (!buttonControl) {
            $(this).button();
          }
        });

        // Invoke searchfields
        var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
        searchfields.each(function(i, item) {
          var sf = $(item);
          if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
            sf = sf.children('.searchfield');
          }

          if (!sf.data('searchfield')) {
            var searchfieldOpts = $.extend({}, $.fn.parseOptions(sf[0]));
            sf.toolbarsearchfield(searchfieldOpts);
          }
        });

        // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in the toolbar, but
        // hide them initially.  They are revealed when overflow checking happens as the menu is opened.
        var popupMenuInstance = this.more.data('popupmenu'),
          moreAriaAttr = this.more.attr('aria-controls');

        if (!popupMenuInstance) {
          this.moreMenu = $('#' + moreAriaAttr);
          if (!this.moreMenu.length) {
            this.moreMenu = this.more.next('.popupmenu');
          }
          if (!this.moreMenu.length) {
            this.moreMenu = $('<ul id="popupmenu-toolbar-'+ this.id +'" class="popupmenu"></ul>').insertAfter(this.more);
          }
        } else {
          this.moreMenu = popupMenuInstance.menu;
        }

        this.defaultMenuItems = this.moreMenu.children('li:not(.separator)').length > 0;

        function menuItemFilter() {
          //jshint validthis:true
          return $(this).parent('.buttonset, .inline').length;
        }

        var menuItems = [];
        this.items.not(this.more).filter(menuItemFilter).each(function() {
          menuItems.push(self.buildMoreActionsMenuItem($(this)));
        });

        menuItems.reverse();
        $.each(menuItems, function(i, item) {
          if (item.text() !== '') {
            item.prependTo(self.moreMenu);
          }
        });

        // Setup an Event Listener that will refresh the contents of the More Actions
        // Menu's items each time the menu is opened.
        if (popupMenuInstance) {
          this.more
            .on('beforeopen.toolbar', function() {
              self.refreshMoreActionsMenu(self.moreMenu);
            })
            .triggerHandler('updated');
        } else {
          var actionButtonOpts = $.fn.parseOptions(this.more[0]);

          this.more.popupmenu($.extend({}, actionButtonOpts, {
            trigger: 'click',
            menu: this.moreMenu
          })).on('beforeopen.toolbar', function() {
            self.refreshMoreActionsMenu(self.moreMenu);
          });
        }

        // Setup the tabindexes of all items in the toolbar and set the starting active button.
        function setActiveToolbarItem() {
          self.items.attr('tabindex', '-1');

          var active = self.items.filter('.is-selected');
          if (active.length) {
            self.activeButton = active.first().attr('tabindex', '0');
            self.items.not(self.activeButton).removeClass('is-selected');
            return;
          }

          // Set active to the first item in the toolbar.
          active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
          self.activeButton = active;

          // If the whole toolbar is hidden (contextual toolbars, etc),
          // automatically set the first non-disabled item as visible
          if (self.element.is(':hidden, .is-hidden')) {
            self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
            return;
          }

          if (self.isItemOverflowed(active)) {
            active.attr('tabindex', '-1');
            self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
          }
          return;
        }

        setActiveToolbarItem();

        // Toggles the More Menu based on overflow of toolbar items
        this.adjustMenuItemVisibility();
        this.handleResize();

        this.element.triggerHandler('rendered');
        return this;
      },

      /**
       * Builds a single "More Actions Menu" item from a source toolbar item.
       * Also sets up linkage between the menu item and the original toolbar item to allow events/properties
       * to propagate when the More Actions item is acted upon.
       * @param {jQuery[]} item - the source item from the toolbar.
       * @returns {jQuery[]} - a jQuery-wrapped <li> representing a More Actions menu implementation of the toolbar item.
       */
      buildMoreActionsMenuItem: function(item) {
        var isSplitButton = false;

        // If this item should be skipped, just return out
        if (item.data('skipit') === true) {
          item.data('skipit', undefined);
          return;
        }

        // Attempt to re-use an existing <li>, if possible.
        // If a new one is created, setup the linkage between the original element and its
        // "More Actions" menu counterpart.
        var a = item.data('action-button-link'),
          popupLi;

        if (!a || !a.length) {
          popupLi = $('<li></li>');
          a = $('<a href="#"></a>').appendTo(popupLi);

          // Setup data links between the buttons and their corresponding list items
          item.data('action-button-link', a);
          a.data('original-button', item);
        } else {
          popupLi = a.parent();
        }

        // Refresh states
        if (item.hasClass('hidden')) {
          popupLi.addClass('hidden');
        }
        if (item.is(':disabled')) {
          popupLi.addClass('is-disabled');
        } else {
          popupLi.removeClass('is-disabled');
        }

        // Refresh Text
        a.text(this.getItemText(item));

        // Pass along any icons except for the dropdown (which is added as part of the submenu design)
        var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
        var icon = item.children('.icon').filter(function() {
          var iconName = $(this).getIconName();
          return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
        });

        if (icon && icon.length) {
          a.html('<span>' + a.text() + '</span>');
          icon.clone().detach().prependTo(a);
        }

        var linkspan = popupLi.find('b');
        if (linkspan.length) {
          this.moreMenu.addClass('has-icons');
          linkspan.detach().prependTo(popupLi);
        }

        function addItemLinksRecursively(menu, diffMenu, parentItem) {
          var children = menu.children('li'),
            id = diffMenu.attr('id');

          diffMenu.children('li').each(function(i, diffMenuItem) {
            var dmi = $(diffMenuItem), // "Diffed" Menu Item
              omi = children.eq(i), // Corresponding "Original" menu item
              dmiA = dmi.children('a'), // Anchor inside of "Diffed" menu item
              omiA = omi.children('a'), // Anchor inside of "Original" menu item
              dmiID = dmi.attr('id'),
              dmiAID = dmiA.attr('id');

            // replace menu item ids with spillover-menu specific ids.
            if (dmiID) {
              dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
            }
            if (dmiAID) {
              dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
            }

            omiA.data('action-button-link', dmiA);
            dmiA.data('original-button', omiA);

            var omiSubMenu = omi.children('.wrapper').children('.popupmenu'),
              dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

            if (omiSubMenu.length && dmiSubMenu.length) {
              addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
            }

            if (isSplitButton) {
              dmi.removeClass('is-checked');
            }
          });

          diffMenu.removeAttr('id').attr('data-original-menu', id);
          parentItem.addClass('submenu');

          var appendTarget;
          if (parentItem.is(popupLi)) {
            appendTarget = parentItem.children('.wrapper');
            if (!appendTarget || !appendTarget.length) {
              appendTarget = $('<div class="wrapper"></div>');
            }
            appendTarget.html(diffMenu);
            parentItem.append(appendTarget);
          }
        }

        if (item.is('.btn-menu')) {
          if (!item.data('popupmenu')) {
            item.popupmenu();
          } else {
            if (!a.children('.icon.arrow').length) {
              a.append($.createIcon({
                classes: 'icon arrow icon-dropdown',
                icon: 'dropdown'
              }));
            }
          }

          var menu = item.data('popupmenu').menu,
            diffMenu = menu.clone();

          addItemLinksRecursively(menu, diffMenu, popupLi);
        }

        if (item.is('[data-popdown]')) {
          item.popdown();
        }

        return popupLi;
      },

      /**
       * Refreshes the More Actions Menu items' text content, icons, states, and submenu content
       * based on changes made directly to their counterpart elements in the Toolbar.  Can also
       * optionally refresh only part of the menu.
       * @param {jQuery[]} menu - the menu/submenu to be refreshed.
       */
      refreshMoreActionsMenu: function(menu) {
        var self = this;

        $('li > a', menu).each(function () {
          var a = $(this),
              li = a.parent(),
              item = a.data('originalButton'),
              itemParent,
              text = self.getItemText(item),
              submenu;

          if (item) {
            if (a.find('span').length) {
              a.find('span').text(text.trim());
            } else {
              a.text(text.trim());
            }

            if (item.is('.hidden') || item.parent().is('.hidden')) {
              li.addClass('hidden');
            } else {
              li.removeClass('hidden');
            }

            if (item.parent().is('.is-disabled') || item.is(':disabled')) { // if it's disabled menu item, OR a disabled menu-button
              li.addClass('is-disabled');
              a.attr('tabindex', '-1');
            } else {
              li.removeClass('is-disabled');
              a.removeAttr('disabled');
            }

            if (item.is('a')) {
              itemParent = item.parent('li');

              if (itemParent.is('.is-checked')) {
                li.addClass('is-checked');
              } else {
                li.removeClass('is-checked');
              }
            }

            if (item.is('.btn-menu')) {
              submenu = a.parent().find('.popupmenu').first();
              self.refreshMoreActionsMenu(submenu);
            }
          }
        });
      },

      /**
       * Gets the complete text contnts of a Toolbar Item, in order to create its corresponding "more actions" menu item.
       *
       * Order of operations for populating the List Item text:
       * 1. span contents (.audible), then
       * 2. button title attribute, then
       * 3. tooltip text (if applicable)
       * @param {jQuery[]} item - the item being evaluated.
       * @returns {string} - the complete text representation.
       */
      getItemText: function (item) {
        if (!item) {
          return;
        }
        var span = item.find('.audible'),
          title = item.attr('title'),
          tooltip = item.data('tooltip'),
          tooltipText = tooltip && typeof tooltip.content === 'string' ? tooltip.content : undefined;

        var popupLiText = span.length ? span.text() :
          title !== '' && title !== undefined ? item.attr('title') :
          tooltipText ? tooltipText : item.text();

        return popupLiText;
      },

      /**
       * Sets up all necessary event handling on a Toolbar component
       * @private
       * @chainable
       * @returns {this}
       */
      handleEvents: function() {
        var self = this;

        this.items
          .off('keydown.toolbar').on('keydown.toolbar', function(e) {
            self.handleKeys(e);
          }).off('click.toolbar').on('click.toolbar', function(e) {
            self.handleClick(e);
          });

        this.items.filter('.btn-menu, .btn-actions')
          .off('close.toolbar').on('close.toolbar', function onClosePopup() {
            var el = $(this),
              last;

            if (el.is('.is-overflowed')) {
              last = self.getLastVisibleButton();
              if (last && last.length) {
                last[0].focus();
              }
              return;
            }

            el.focus();
            self.buttonset.scrollTop(0);
          });

        this.items.not(this.more).off('selected.toolbar').on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        this.more.on('keydown.toolbar', function(e) {
          self.handleKeys(e);
        }).on('beforeopen.toolbar', function() {
          self.adjustMenuItemVisibility();
        }).on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        // Handle possible AJAX calls on Toolbar Menu buttons
        // TODO: Need to handle mouseenter/touchstart/keydown events that will cause this to trigger,
        // instead of directly handling this itself.
        this.more
          .off('show-submenu.toolbar')
          .on('show-submenu.toolbar', function(e, li) {
          self.handleTransferToMenuButtonItem(e, li);
        });

        this.element.off('updated.toolbar').on('updated.toolbar', function(e) {
          e.stopPropagation();
          self.updated();
        }).off('recalculate-buttons.toolbar').on('recalculate-buttons.toolbar', function(e, containerDims) {
          self.handleResize(containerDims);
        }).off('scrollup.toolbar').on('scrollup.toolbar', function() {
          var moduleTabsParent = self.element.parents('.tab-container.module-tabs');
          if (moduleTabsParent.length) {
            moduleTabsParent.scrollTop(0);
          }
        });

        $('body').off('resize.toolbar-' + this.id).on('resize.toolbar-' + this.id, function() {
          self.handleResize();
        });

        // Trigger _handleResize()_ once to fix container sizes.
        this.handleResize();

        return this;
      },

      /**
       * Event Handler for the Soho Popupmenu's custom 'show-submenu' event, specifically for
       * the case of a menu button that's been spilled over into this Toolbar's More Actions menu.
       * @param {jQuery.Event} e
       * @param {jQuery[]} li - the `li.submenu` element.
       */
      handleTransferToMenuButtonItem: function(e, li) {
        var originalMenuButton = li.children('a').data('original-button');
        if (!originalMenuButton) {
          return;
        }

        var popupAPI = originalMenuButton.data('popupmenu');
        if (!popupAPI || typeof popupAPI.settings.beforeOpen !== 'function') {
          return;
        }

        // Call out to the MenuButton's AJAX source, get its contents, and populate
        // the corresponding More Actions menu sub-item.
        popupAPI.callSource(e);
        this.buildMoreActionsMenuItem(originalMenuButton);
      },

      /**
       * Event handler for the Soho `selected` event on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleSelected: function(e, anchor) {
        var itemLink = anchor.data('original-button'),
          li = anchor.parent(),
          itemEvts,
          toolbarEvts,
          popup, popupTrigger;

        // Don't continue if hidden/readonly/disabled
        if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
          e.preventDefault();
          return;
        }

        if (itemLink && itemLink.length > 0) {
          itemEvts = itemLink.listEvents();
          toolbarEvts = this.element.listEvents();

          // Make sure the active button is set properly
          this.setActiveButton(itemLink);

          // Fire Angular Events
          if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
            itemLink.trigger('click');
            return;
          }

          // Check the Toolbar Button for the existence of certain event types.
          // Checks the button, and checks the toolbar container element for delegated events.
          var evtTypes = ['click', 'touchend', 'touchcancel'];
          for (var i = 0; i < evtTypes.length; i++) {
            var type = evtTypes[i];

            // Check toolbar element for delegated-down events first
            if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
              var el = this.element,
                evt = $.Event(type);

              evt.target = el.find(itemLink)[0];
              el.trigger(evt);
              return;
            }

            // Check for events directly on the element
            if ((itemEvts && itemEvts[type]) || itemLink[0]['on' + type]) {
              itemLink.trigger(type);
              return;
            }
          }

          // If the linked element is a child of a menu button, trigger its 'selected' event.
          popup = itemLink.parents('.popupmenu');
          popupTrigger = popup.data('trigger');
          if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
            popupTrigger.triggerHandler('selected', [itemLink]);
            return;
          }

          // Manually Trigger Select on the linked item, since it won't be done by another event
          this.triggerSelect(itemLink);
          return;
        }

        // If no item link exists, it's a pre-defined menu item.
        // Trigger 'selected' manually on the toolbar element.
        // Normally this would happen by virtue of triggering the "click" handlers on a linked button above.
        this.triggerSelect(anchor);
      },

      /**
       * Event handler for clicks on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {false}
       */
      handleClick: function(e) {
        this.setActiveButton($(e.currentTarget));
        this.triggerSelect($(e.currentTarget));
        return false;
      },

      /**
       * Event handler for key presses on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleKeys: function(e) {
        var self = this,
          key = e.which,
          target = $(e.target),
          isActionButton = target.is('.btn-actions'),
          isRTL = Locale.isRTL();

        if ((key === 37 && target.is(':not(input)')) ||
          (key === 37 && target.is('input') && e.shiftKey) || // Shift + Left Arrow should be able to navigate away from Searchfields
          (key === 38 && target.is(':not(input.is-open)'))) { // Don't navigate away if Up Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton() );
          } else {
            self.navigate( isRTL ? 1 : -1 );
          }
        }

        if ((key === 39 && target.is(':not(input)')) ||
          (key === 39 && target.is('input') && e.shiftKey) || // Shift + Right Arrow should be able to navigate away from Searchfields
          (key === 40 && target.is(':not(input.is-open)'))) { // Don't navigate away if Down Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton() );
          } else {
            self.navigate( isRTL ? -1 : 1 );
          }
        }

        return;
      },

      /**
       * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
       * @param {Object} [containerDims] - an object containing dimensions that can be set on the Toolbar's title and buttonset elements.
       * @param {number} [containerDims.title] - represents the width that will be applied to the title element
       * @param {number} [containerDims.buttonset] - represents the width that will be applied to the buttonset element
       * @returns {undefined}
       */
      handleResize: function(containerDims) {
        if (this.settings.resizeContainers) {
          var title = containerDims ? containerDims.title : undefined,
            buttonset = containerDims ? containerDims.buttonset : undefined;

          this.sizeContainers(title, buttonset);
        }

        var buttons = this._getButtonsetButtons();
        for (var i = 0; i < buttons.length; i++) {
          buttons[i].removeClass('is-overflowed');
        }

        if (this.element.is(':not(:hidden)')) {
          this.adjustMenuItemVisibility();
          this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
        }
      },

      /**
       * Resizes the Toolbar's internal container areas (title, buttonset) to make efficient use of their space.
       * @private
       * @chainable
       * @param {number} titleSize - desired size of the title element.
       * @param {number} buttonsetSize - desired size of the buttonset element.
       * @returns {this}
       */
      sizeContainers: function(titleSize, buttonsetSize) {
        var containerElem = this.element[0],
          titleElem = this.title[0],
          buttonsetElem = this.buttonset[0],
          moreElem = this.more[0];

        // Don't do this at all unless we have a title element (which is optional)
        if (!this.title || !this.title.length) {
          return;
        }

        // If the element's hidden and has defined sizes, remove them so we can use the defaults.
        if (this.element.is(':hidden')) {
          buttonsetElem.style.width = '';
          titleElem.style.width = '';
          containerElem.classList.remove('do-resize');
          return;
        }

        var WHITE_SPACE = 30,
          MIN_TITLE_SIZE = 44 + WHITE_SPACE,
          MIN_BUTTONSET_SIZE = 0;

        buttonsetElem.style.width = '';
        titleElem.style.width = '';

        if (!containerElem.classList.contains('do-resize')) {
          containerElem.classList.add('do-resize');
        }

        var toolbarDims = $(containerElem).getHiddenSize(),
          buttonsetDims = $(buttonsetElem).getHiddenSize(),
          titleDims = $(titleElem).getHiddenSize(),
          moreDims = $(moreElem).getHiddenSize(),
          toolbarPadding = parseInt(toolbarDims.padding.left) + parseInt(toolbarDims.padding.right);

        if (isNaN(moreDims.width)) {
          moreDims.width = 50;
        }

        if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
          buttonsetDims.width = MIN_BUTTONSET_SIZE;
        }

        function addPx(val) {
          return val + 'px';
        }

        // Get the target size of the title element
        var targetTitleWidth, targetButtonsetWidth, d;
        this.cutoffTitle = false;

        // Setter functionality
        if (titleSize && buttonsetSize && !isNaN(titleSize) && !isNaN(buttonsetSize)) {
          targetTitleWidth = parseInt(titleSize);
          targetButtonsetWidth = parseInt(buttonsetSize);
        } else {
          if ((buttonsetDims.scrollWidth + titleDims.scrollWidth + moreDims.width + toolbarPadding) > toolbarDims.width) {
            if (this.settings.favorButtonset) {
              targetButtonsetWidth = buttonsetDims.width;
              targetTitleWidth = toolbarDims.width - (toolbarPadding + buttonsetDims.width + moreDims.width);
            } else {
              targetTitleWidth = titleDims.scrollWidth;
              targetButtonsetWidth = toolbarDims.width - (toolbarPadding + titleDims.scrollWidth + moreDims.width);
            }
          }
        }

        if (this.settings.favorButtonset) {
          // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
          if (targetTitleWidth < MIN_TITLE_SIZE) {
            this.cutoffTitle = true;
            d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
            targetTitleWidth = MIN_TITLE_SIZE;
            targetButtonsetWidth = targetButtonsetWidth - d;
          }

          buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
          titleElem.style.width = addPx(targetTitleWidth - 2);

          return this;
        }
        //==========================
        // Favor the title element
        // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!
        if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
          targetButtonsetWidth = MIN_BUTTONSET_SIZE;
          targetTitleWidth = targetTitleWidth - d;
        }

        // Always favor the title by one extra px for Chrome
        titleElem.style.width = addPx(targetTitleWidth + 2);
        buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
        return this;
      },

      /**
       * Changes the "active" button on the toolbar.
       * @param {number} direction - can be `-1` (previous), `1` (next), or `0` (remain on current).
       * @returns {jQuery[]}
       */
      navigate: function (direction) {
        var items = this.items.filter(':visible:not(:disabled)'),
          current = items.index(this.activeButton),
          next = current + direction,
          target;

        if (next >= 0 && next < items.length) {
          target = items.eq(next);
        }

        if (next >= items.length) {
          target = items.first();
        }

        if (next === -1) {
          target = items.last();
        }

        if (this.isItemOverflowed(target)) {
          target = this.more;
        }

        this.setActiveButton(target);
        return false;
      },

      /**
       * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getLastVisibleButton: function() {
        var items = $(this.items.get().reverse()).not(this.more),
          target;

        var i = 0,
          elem;

        while(!target && i < items.length) {
          elem = $(items[i]);
          if (!this.isItemOverflowed(elem)) {
            target = elem;
            break;
          }
          i++;
        }

        if (!target || target.length === 0) {
          target = items.first();
        }

        while(target.length && target.is('.separator, *:disabled, *:hidden')) {
          target = target.prev();
        }

        return target;
      },

      /**
       * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getFirstVisibleButton: function() {
        var i = 0,
          items = this.items,
          target = items.eq(i);

        while(target.is('.separator, *:disabled, *:hidden')) {
          i++;
          target = items.eq(i);
        }

        return target;
      },

      /**
       * Sets the currently "active" (focused) Toolbar item
       * @param {jQuery[]} activeButton - the preferred target element to make active.
       * @param {boolean} [noFocus] - if defined, prevents this method from giving focus to the new active button.
       */
      setActiveButton: function(activeButton, noFocus) {
        // Return out of this if we're clicking the currently-active item
        if (activeButton[0] === this.activeButton[0]) {
          return;
        }

        var self = this;

        function getMoreOrLast() {
          if (self.hasNoMoreButton() || !self.element.hasClass('has-more-button')) {
            return self.getLastVisibleButton();
          }

          return self.more;
        }

        function getActiveButton() {
          // Menu items simply set the "More Actions" button as active
          if (activeButton.is('a')) {
            return getMoreOrLast();
          }

          // If it's the more button, hide the tooltip and set it as active
          var tooltip = self.more.data('tooltip');
          if (activeButton[0] === self.more[0]) {
            if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
              tooltip.hide();
            }
            return getMoreOrLast();
          }

          // Overflowed items also set
          if (self.isItemOverflowed(activeButton)) {
            if (!activeButton.is('.searchfield')) {
              return getMoreOrLast();
            }
          }

          return activeButton;
        }

        this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');

        this.activeButton = getActiveButton();
        this.activeButton.addClass('is-selected').attr('tabindex', '0');

        if (!noFocus) {
          this.activeButton[0].focus();
          this.element.triggerHandler('navigate', [this.activeButton]);
        }
      },

      /**
       * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
       * @param {HTMLElement|SVGElement|jQuery[]} element - a jQuery Object containing an anchor tag, button, or input field.
       */
      triggerSelect: function(element) {
        var elem = $(element);
        if (elem.is(this.more) || (elem.is('.btn-menu, li.submenu'))) {
          return;
        }

        this.element.triggerHandler('selected', [elem]);
      },

      /**
       * Assembles and returns a list of all buttons inside the Buttonset element.
       * @returns {Array}
       */
      _getButtonsetButtons: function() {
        var buttons = [],
          items = this.buttonsetItems,
          item;

        for (var i = 0; i < items.length; i++) {
          item = items.eq(i);
          if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
            buttons.push(item);
          }
        }

        return buttons;
      },

      /**
       * Gets and Iterates through a list of toolbar items and determines which are currently overflowed, and which are visible.
       * @param {Array} buttons - an Array of jQuery-wrapped elements that represents toolbar items.
       * @returns {VisibilitySortedToolbarItems}
       * @returns {VisibilitySortedToolbarItems.Array} visible - An array containing all visible items.
       * @returns {VisibilitySortedToolbarItems.Array} hidden - An array containing all hidden (overflowed) items.
      */
      getVisibleButtons: function(buttons) {
        var self = this,
          hiddenButtons = [],
          visibleButtons = [],
          i;

        if (!buttons || !Array.isArray(buttons)) {
          buttons = this._getButtonsetButtons();
        }

        for (i = 0; i < buttons.length; i++) {
          buttons[i][0].classList.remove('is-overflowed');
        }

        function getButtonVisibility(i, button) {
          if (!self.isItemOverflowed(button)) {
            visibleButtons.push(button);
          } else {
            hiddenButtons.push(button);
          }
        }

        for (i = 0; i < buttons.length; i++) {
          getButtonVisibility(i, buttons[i]);
        }

        return {
          visible: visibleButtons,
          hidden: hiddenButtons
        };
      },

      /**
       * Gets and Iterates through the full list of Toolbar Items and determines which ones should currently be present in the More Actions menu.
       * @param {Object} items - an object (normally generated by `_.getVisibleButtons()`) containing arrays of currently visible and hidden buttons, along with some meta-data.
       * @returns {undefined}
       */
      adjustMenuItemVisibility: function(items) {
        var iconDisplay = 'removeClass';

        if (!items) {
          items = this.getVisibleButtons();
        }

        function toggleClass($elem, doHide) {
          var elem = $elem[0],
            li = $elem.data('action-button-link').parent()[0],
            elemIsHidden = elem.classList.contains('hidden');

          if (doHide) {
            li.classList.add('hidden');
            elem.classList.remove('is-overflowed');

            /*
            if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
              $elem.last().last().removeClass('is-overflowed');
            }
            */
            return;
          }

          if (!elemIsHidden) {
            li.classList.remove('hidden');
          }
          elem.classList.add('is-overflowed');

          /*
          if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
            $elem.last().last().addClass('is-overflowed');
          }
          */

          if ($elem.find('.icon').length) {
            iconDisplay = 'addClass';
          }
        }

        var i = 0;
        for (i; i < items.visible.length; i++) {
          toggleClass(items.visible[i], true);
        }
        for (i = 0; i < items.hidden.length; i++) {
          toggleClass(items.hidden[i], false);
        }

        if (this.moreMenu.find('.icon').length) {
          iconDisplay = 'addClass';
        }

        this.moreMenu[iconDisplay]('has-icons');
      },

      /**
       * Detects whether or not a toolbar item is currently overflowed.  In general, toolbar items are considered overflow if their right-most edge sits past the right-most edge of the buttonset border.  There are some edge-cases.
       * @param {jQuery[]} item - the Toolbar item being tested.
       * @returns {boolean}
       */
      isItemOverflowed: function(item) {
        if (this.hasNoMoreButton()) {
          return false;
        }

        if (!item || item.length === 0) {
          return true;
        }

        // In cases where a Title is present and buttons are right-aligned, only show up to the maximum allowed.
        if (this.title.length && this.buttonsetItems.filter(':not(.hidden)').index(item) >= this.settings.maxVisibleButtons) { // Subtract one to account for the More Button
          // ONLY cause this to happen if there are at least two items that can be placed in the overflow menu.
          // This prevents ONE item from being present in the menu by itself
          //if (!this.buttonsetItems.last().is(item)) {
            //return true;
          //}
          return true;
        }

        if (this.buttonset.scrollTop() > 0) {
          this.buttonset.scrollTop(0);
        }

        // unwrap from jQuery
        if (item instanceof $ && item.length) {
          item = item[0];
        }

        var classList = item.classList,
          style = window.getComputedStyle(item);

        if (classList.contains('btn-actions')) {
          return true;
        }
        if (classList.contains('searchfield')) {
          return false;
        }
        if (style.display === 'none') {
          return true;
        }

        var isRTL = Locale.isRTL(),
          itemRect = item.getBoundingClientRect(),
          buttonsetRect = this.buttonset[0].getBoundingClientRect(),
          itemOutsideXEdge = isRTL ? (itemRect.left <= buttonsetRect.left) : (itemRect.right >= buttonsetRect.right),
          itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;

        return (itemBelowYEdge === true || itemOutsideXEdge === true);
      },

      /**
       * Detection for this toolbar to have a More Button
       * @returns {boolean}
       */
      hasNoMoreButton: function() {
        return this.element[0].classList.contains('no-more-button');
      },

      /**
       * Determines whether or not the "more actions" button should be displayed.
       * @private
       * @returns {undefined}
       */
      toggleMoreMenu: function() {
        if (this.element.hasClass('no-actions-button')) {
          return;
        }

        var overflowItems = this.moreMenu.children('li:not(.separator)'),
          hiddenOverflowItems = overflowItems.not('.hidden');

        var method = 'removeClass';
        if (this.defaultMenuItems || hiddenOverflowItems.length > 0) {
          method = 'addClass';
        }

        this.element[method]('has-more-button');

        var popupAPI = this.more.data('popupmenu');
        if (method === 'removeClass') {
          if (!popupAPI) {
            return;
          }

          popupAPI.close();

          var menuItems = popupAPI.menu.find('li:not(.separator)').children('a'),
            shouldFocus = false;

          menuItems.add(this.more).each(function() {
            if (document.activeElement === this) {
              shouldFocus = true;
            }
          });

          if (shouldFocus) {
            this.getLastVisibleButton()[0].focus();
          }
        }
      },

      /**
       * Creates an `aria-label` attribute on the toolbar, for bettery accessibility
       * @private
       * @returns {undefined}
       */
      buildAriaLabel: function() {
        // Set up an aria-label as per AOL guidelines
        // http://access.aol.com/dhtml-style-guide-working-group/#toolbar
        if (!this.element.attr('aria-label')) {
          var isHeader = (this.element.closest('.header').length ===1),
            id = this.element.attr('id') || '',
            title = this.element.children('.title'),
            prevLabel = this.element.prev('label'),
            prevSpan = this.element.prev('.label'),
            labelText = isHeader ? $('header.header').find('h1').text() :
            title.length ? title.filter('div').text() :
            prevLabel.length ? prevLabel.text() :
            prevSpan.length ? prevSpan.text() : id + ' ' + Locale.translate('Toolbar');

          this.element.attr('aria-label', labelText.replace(/\s+/g,' ').trim());
        }
      },

      updated: function() {
        this
          .unbind()
          .teardown()
          .init();
      },

      /**
       * Enables the entire Toolbar component
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.items.prop('disabled', false);
        this.more.prop('disabled', false);
      },

      /**
       * Disables the entire Toolbar component
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.items.prop('disabled', true);
        this.more.prop('disabled', true).data('popupmenu').close();
      },

      /**
       * Removes currently associated event listeners from the Toolbar.
       * @private
       * @chainable
       * @returns {this}
       */
      unbind: function() {
        this.items
          .offTouchClick('toolbar')
          .off('keydown.toolbar click.toolbar focus.toolbar blur.toolbar');

        this.more.off('keydown.toolbar beforeopen.toolbar selected.toolbar');
        $('body').off('resize.toolbar-' + this.id);
        return this;
      },

      /**
       * Returns the Toolbar's internal markup to its original state.
       * @chainable
       * @returns {this}
       */
      teardown: function() {
        var self = this;

        if (this.title && this.title.length) {
          var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');
          if (dataTooltip) {
            dataTooltip.destroy();
          }
        }

        this.moreMenu.children('li').each(function() {
          self.teardownMoreActionsMenuItem($(this), true);
        });
        return this;
      },

      /**
       * Tears down a More Actions Menu item.
       * @param {jQuery[]} item - the existing <li> from inside the More Actions menu.
       * @param {boolean} doRemove - if defined, causes the list item to be removed from the more actions menu.
       */
      teardownMoreActionsMenuItem: function(item, doRemove) {
        var self = this,
          li = $(item),
          a = li.children('a'),
          itemLink = a.data('original-button');

        a.off('updated.toolbar mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar recalculate-buttons.toolbar');

        var icons = li.find('.icon');
        if (icons.length) {
          icons.remove();
        }

        var submenuContainer;
        if (li.is('.submenu')) {
          submenuContainer = li.children('.wrapper').children('.popupmenu');
          submenuContainer.children('li').each(function(){
            self.teardownMoreActionsMenuItem($(this), true);
          });
        }

        if (itemLink && itemLink.length) {
          $.removeData(a[0], 'original-button');
          $.removeData(itemLink[0], 'action-button-link');
          a.remove();

          if (submenuContainer) {
            submenuContainer
              .off()
            .parent('.wrapper')
              .off()
              .remove();
          }

          if (doRemove) {
            li.remove();
          }
        }
      },

      /**
       * Destroys this Toolbar Component instance and completely disassociates it from its corresponding DOM Element.
       * @returns {undefined}
       */
      destroy: function() {
        this
          .unbind()
          .teardown();

        if (this.buttonset.children('.searchfield-wrapper').length) {
          var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
          if (searchFields.data('toolbarsearchfield')) {
            searchFields.data('toolbarsearchfield').destroy();
          }
        }

        /*
        // Remove split button wrappers
        if (this.splitButtonWrappers.length) {
          $.each(this.splitButtonWrappers, function(wrapper) {
            var els = wrapper.children().detach();
            els.insertAfter(wrapper);
            wrapper.remove();
          });
        }
        */

        if (this.more.length && this.more.data('popupmenu') !== undefined) {
          this.more.data('popupmenu').destroy();
        }

        this.element[0].classList.remove('do-resize');
        this.buttonset[0].style.width = '';
        if (this.title && this.title.length) {
          this.title[0].style.width = '';
        }

        this.element.removeAttr('role').removeAttr('aria-label');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Toolbar(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.
  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 230,
    MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;

  $.fn.toolbarsearchfield = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toolbarsearchfield',
        defaults = {
          clearable: true,
          collapsible: true,
          collapsibleOnMobile: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * Searchfield Component Wrapper that extends normal Searchfield functionality and provides collapse/expand behavior.  For use inside of Toolbars.
     *
     * @class ToolbarSearchfield
     *
     * @param {boolean} clearable  &nbsp;-&nbsp;  If "true", provides an "x" button on the right edge that clears the field
     * @param {boolean} collapsible  &nbsp;-&nbsp;  If "true", allows the field to expand/collapse on larger breakpoints when focused/blurred respectively
     * @param {boolean} collapsibleOnMobile &nbsp;-&nbsp;  If true, overrides `collapsible` only on mobile settings.
     */
    function ToolbarSearchfield(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ToolbarSearchfield.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      /**
       * Creates and manages any markup the control needs to function.
       * @returns {this}
       */
      build: function() {
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = this.element.uniqueId('toolbar-searchfield');
        }

        // Build the searchfield element
        this.input = this.element;

        // If inside a toolbar, make sure to append it to the root toolbar element.
        this.toolbarParent = this.element.parents('.toolbar');
        this.containmentParent = this.toolbarParent;
        var moduleTabs = this.containmentParent.closest('.module-tabs');
        if (moduleTabs.length) {
          this.containmentParent = moduleTabs;
        }

        this.getToolbarElements();

        // Setup ARIA
        var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();
        if (!label || label === '') {
          label = Locale.translate('Keyword');
        }
        this.input.attr({
          'aria-label': label,
        });

        // Invoke Searchfield, pass settings on
        var sfSettings = $.extend({ 'noToolbarSearchfieldInvoke': true }, this.settings, $.fn.parseOptions(this.input[0]));
        this.input.searchfield(sfSettings);
        this.inputWrapper = this.input.parent();
        this.inputWrapper.addClass('toolbar-searchfield-wrapper');

        if (sfSettings.categories) {
          this.button = this.inputWrapper.find('.searchfield-category-button');
        }

        // Add/remove the collapsible setting
        var collapsibleMethod = this.settings.collapsible ? 'removeClass' : 'addClass';
        this.inputWrapper[collapsibleMethod]('non-collapsible');

        this.xButton = this.inputWrapper.children('.icon.close');

        this.adjustOnBreakpoint();

        return this;
      },

      /**
       * TODO: Deprecate in 4.4.0
       * @private
       */
      handleDeactivationEvents: function() {
        return this.addDocumentDeactivationEvents();
      },

      /**
       * @private
       * Sets up event listeners that need to be handled at the global (document) level, since they deal
       * with general keystrokes.
       */
      addDocumentDeactivationEvents: function() {
        var self = this;

        if (!this.handleOutsideStr) {
          var arr = ['click'].map(function(v) {
            return v +'.'+ self.id;
          });
          this.handleOutsideStr = arr.join(' ');
        }

        $(document).on(self.handleOutsideStr, function(e) {
          self.handleOutsideClick(e);
        });
      },

      /**
       * @private
       * Removes global (document) level event handlers.
       */
      removeDocumentDeactivationEvents: function() {
        var self = this;
        $(document).off(this.handleOutsideStr, function(e) {
          self.handleOutsideClick(e);
        });
      },

      /**
       * Detects whether or not the Toolbar Searchfield has focus.
       * @returns {boolean}
       */
      hasFocus: function() {
        return this.element.data('searchfield').hasFocus();
      },

      /**
       * Handles the focus of the searchfield, expanding it on time delay.
       */
      handleFocus: function() {
        var self = this;
        clearTimeout(this.focusTimer);

        this.inputWrapper.addClass('has-focus');

        function searchfieldActivationTimer() {
          self.expand();
        }

        if (this.fastExpand) {
          searchfieldActivationTimer();
          return;
        }

        this.focusTimer = setTimeout(searchfieldActivationTimer, 0);
      },

      /**
       * Triggers an artificial "blur" of the searchfield, resulting in a time-delayed collapse.
       */
      handleFakeBlur: function() {
        var self = this;
        clearTimeout(this.focusTimer);

        function searchfieldCollapseTimer() {
          self.collapse();
        }

        this.focusTimer = setTimeout(searchfieldCollapseTimer, 100);
      },

      /**
       * Event Handler for dealing with global (document) level clicks.
       */
      handleOutsideClick: function() {
        if (this.hasFocus()) {
          return;
        }

        $(document).off(this.outsideEventStr);
        this.collapse();
      },

      /**
       * Handles Keydown Events
       * @param {jQuery.Event} e - jQuery-wrapped Keydown event.
       */
      handleKeydown: function(e) {
        var key = e.which;

        if (key === 9) { // Tab
          return this.handleFakeBlur();
        }
      },

      /**
       * Handles global (document) level keydown events that are established to help
       * collapse/de-highlight searchfields on a timer.
       * @param {jQuery.Event} e - jQuery-wrapped Keydown event
       */
      handleOutsideKeydown: function(e) {
        var key = e.which;

        this.fastExpand = false;
        if (key === 9) { // Tab
          this.fastExpand = true;
          return this.handleFakeBlur();
        }

        var wasInputTheTarget = ($(e.target).is(this.input) || $(e.target).is(this.inputWrapper));
        if (wasInputTheTarget && (key === 37 || key === 38 || key === 39 || key === 40)) {
          return this.handleFakeBlur();
        }
      },

      /**
       * Event Handler for the Popupmenu Component's custom `beforeopen` event.
       * @param {jQuery.Event} e - jQuery-wrapped `beforeopen` Event
       */
      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return false;
        }

        if (!this.inputWrapper.is('.is-open')) {
          this.button.focus();
          return false;
        }

        return true;
      },

      /**
       * Retrieves the distance between a left and right boundary.
       * Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
       * @param {Number|jQuery[]} leftBoundary
       * @param {Number|jQuery[]} rightBoundary
       * @returns {Number}
       */
      getFillSize: function(leftBoundary, rightBoundary) {
        var leftBoundaryNum = 0,
          rightBoundaryNum = 0;

        function sanitize(boundary) {
          if (!boundary) {
            return 0;
          }

          // Return out if the boundary is just a number
          if (!isNaN(parseInt(boundary))) {
            return parseInt(boundary);
          }

          if (boundary instanceof jQuery) {
            if (!boundary.length) {
              return;
            }

            if (boundary.is('.title')) {
              boundary = boundary.next('.buttonset');
            }

            boundary = boundary[0];
          }

          return boundary;
        }

        function getEdgeFromBoundary(boundary, edge) {
          if (!isNaN(boundary)) {
            return (boundary === null || boundary === undefined) ? 0 : boundary;
          }

          if (!edge || typeof edge !== 'string') {
            edge = 'left';
          }

          var edges = ['left', 'right'];
          if ($.inArray(edge, edges) === -1) {
            edge = edges[0];
          }

          var rect;

          if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
            rect = boundary.getBoundingClientRect();
          }

          return rect[edge];
        }

        leftBoundary = sanitize(leftBoundary);
        rightBoundary = sanitize(rightBoundary);

        function whichEdge() {
          var e = 'left';
          if (leftBoundary === rightBoundary || ($(rightBoundary).length && $(rightBoundary).is('.buttonset'))) {
            e = 'right';
          }

          return e;
        }

        leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
        rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

        if (!leftBoundaryNum && !rightBoundaryNum) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        var distance = rightBoundaryNum - leftBoundaryNum;

        // TODO: Remove this once we figure out how to definitively fix the searchfield sizing.
        // Toolbar Searchfield needs a way to demand that the parent toolbar increase the size of its buttonset
        // and decrease the size of its title under this condition -- currently there is no way.
        if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        return distance;
      },

      /**
       * @private
       */
      setClosedWidth: function() {
        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if ((this.button instanceof $) && this.button.length) {
          var buttonStyle = window.getComputedStyle(this.button[0]),
            buttonWidth = parseInt(buttonStyle.width),
            buttonPadding = parseInt(buttonStyle.paddingLeft) + parseInt(buttonStyle.paddingRight);

          if (this.inputWrapper[0]) {
            this.inputWrapper[0].style.width = (buttonWidth + buttonPadding) + 'px';
          }
        }
      },

      /**
       * @private
       */
      setOpenWidth: function() {
        if (this.inputWrapper[0]) {
          this.inputWrapper[0].style.width = this.openWidth;
        }

        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if ((this.button instanceof $) && this.button.length) {
          var buttonStyle = window.getComputedStyle(this.button[0]),
            buttonWidth = parseInt(buttonStyle.width),
            buttonPadding = parseInt(buttonStyle.paddingLeft) + parseInt(buttonStyle.paddingRight),
            buttonBorder = (parseInt(buttonStyle.borderWidth) * 2),
            inputWidth = 'calc(100% - ' + (buttonWidth + buttonPadding + buttonBorder - 2) + 'px)';

          this.input[0].style.width = inputWidth;
        }
      },

      /**
       * @private
       */
      calculateOpenWidth: function() {
        var buttonset = this.element.parents('.toolbar').children('.buttonset'),
          nextElem = this.inputWrapper.next(),
          width;

        // If small form factor, use the right edge
        if (nextElem.is('.title')) {
          nextElem = buttonset;
        }

        if (this.shouldBeFullWidth()) {
          width = '100%';

          if (this.toolbarParent.closest('.header').length) {
            width = 'calc(100% - 40px)';
          }
          if (this.toolbarParent.closest('.tab-container.module-tabs').length) {
            width = 'calc(100% - 1px)';
          }

          this.openWidth = width;
          return;
        }

        if (!buttonset.length) {
          return;
        }

        // Figure out boundaries
        // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
        // into the spillover menu whenever the searchfield opens.
        var leftBoundary = buttonset.offset().left + 10;
        var rightBoundary = nextElem;

        // If the search input sits alone, just use the other side of the buttonset to measure
        if (!rightBoundary.length) {
          rightBoundary = buttonset.offset().left + 10 + buttonset.outerWidth(true);
        }

        width = this.getFillSize(leftBoundary, rightBoundary);
        this.openWidth = (width - 1) + 'px';
      },

      /**
       * Detects whether or not one of the components inside of this searchfield is the document's "active" element.
       * @returns {boolean}
       */
      isActive: function() {
        return this.inputWrapper.hasClass('active');
      },

      /**
       * Detects whether or not this searchfield instance is currently expanded.
       * @returns {boolean}
       */
      isOpen: function() {
        return this.inputWrapper.hasClass('is-open');
      },

      /**
       * Makes necessary adjustments to the DOM surrounding the Searchfield element to accommodate
       * breakpoint changes.
       */
      adjustOnBreakpoint: function() {
        // On smaller form-factor (tablet/phone)
        if (this.shouldBeFullWidth()) {

          if (this.hasFocus()) {
            this.appendToParent();

            this.calculateOpenWidth();
            this.setOpenWidth();

            if (this.isExpanded) {
              return;
            }

            this.expand();
          } else {
            if (this.settings.collapsibleOnMobile === true && this.isExpanded) {
              this.collapse();
            }
          }

          return;
        }

        // On larger form-factor (desktop)
        this.appendToButtonset();

        if (!this.settings.collapsible) {
          this.calculateOpenWidth();
          this.setOpenWidth();

          if (!this.isExpanded) {
            this.expand();
          }
        }

        if (!this.hasFocus() && this.settings.collapsible === true && this.isExpanded) {
          this.collapse();
        }
      },

      /**
       * Angular may not be able to get these elements on demand so we need to be
       * able to call this during the expand method.
       * @private
       */
      getToolbarElements: function() {
        this.buttonsetElem = this.toolbarParent.children('.buttonset')[0];
        if (this.toolbarParent.children('.title').length) {
          this.titleElem = this.toolbarParent.children('.title')[0];
        }
      },

      /**
       * Expands the Searchfield
       */
      expand: function(noFocus) {
        var self = this,
          notFullWidth = !this.shouldBeFullWidth();

        if (this.isActive()) {
          return;
        }

        var dontRecalculateButtons = false,
          toolbarAPI = this.toolbarParent.data('toolbar'),
          toolbarSettings,
          containerSizeSetters;

        if (toolbarAPI) {
           toolbarSettings = this.toolbarParent.data('toolbar').settings;
        }

        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
        }

        if (this.buttonsetElem === undefined) {
          this.getToolbarElements();
        }

        function expandCallback() {

          if (!self.isOpen()) {
            self.inputWrapper.addClass('is-open');
            self.calculateOpenWidth();
            self.setOpenWidth();
          }

          var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
          if (!noFocus || iOS) {
            self.input.focus();
          }

          var eventArgs = [];
          if (containerSizeSetters) {
            eventArgs.push(containerSizeSetters);
          }

          self.toolbarParent.triggerHandler('recalculate-buttons', eventArgs);
          self.inputWrapper.triggerHandler('expanded');
          self.isExpanded = true;
        }

        // Places the input wrapper into the toolbar on smaller breakpoints
        if (!notFullWidth) {
          this.appendToParent();
        } else {

          // Re-adjust the size of the buttonset element if the expanded searchfield would be
          // too large to fit.
          var buttonsetWidth = parseInt(window.getComputedStyle(this.buttonsetElem).width),
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE;

          if (buttonsetWidth < TOOLBARSEARCHFIELD_EXPAND_SIZE) {
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE - buttonsetWidth;
          }

          var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
          containerSizeSetters = {
            buttonset: buttonsetElemWidth
          };

          if (toolbarSettings && toolbarSettings.favorButtonset === true && this.titleElem) {
            var toolbarStyle = window.getComputedStyle(this.toolbarParent[0]),
              titleStyle = window.getComputedStyle(this.titleElem),
              toolbarElemWidth = parseInt(toolbarStyle.width),
              toolbarPadding = parseInt(toolbarStyle.paddingLeft) + parseInt(toolbarStyle.paddingRight),
              titleElemWidth = parseInt(titleStyle.width),
              moreElem = this.toolbarParent.children('more'),
              moreStyle, moreElemWidth = 0;

            if (moreElem.length) {
              moreStyle = window.getComputedStyle(moreElem[0]);
              moreElemWidth = moreStyle.width;
            }

            if (toolbarElemWidth < (toolbarPadding + titleElemWidth + buttonsetElemWidth + moreElemWidth)) {
              containerSizeSetters.title = (titleElemWidth - d);
            }
          }

          dontRecalculateButtons = true;
        }

        this.inputWrapper.addClass('active');
        this.addDocumentDeactivationEvents();

        if (this.shouldExpandOnMobile()) {
          expandCallback();
          return;
        }

        this.animationTimer = setTimeout(expandCallback, 0);
      },

      /**
       * Collapses the Searchfield
       */
      collapse: function() {
        var self = this,
          textMethod = 'removeClass';

        function closeWidth() {
          if (self.button instanceof $ && self.button.length) {
            self.setClosedWidth();
          } else {
            self.inputWrapper.removeAttr('style');
          }
        }

        function collapseCallback() {
          self.fastExpand = false;

          closeWidth();

          if (self.button && self.button.length) {
            self.button.data('popupmenu').close(false, true);
          }

          self.inputWrapper
            .removeClass('is-open')
            .triggerHandler('collapsed');

          self.removeDocumentDeactivationEvents();

          self.isExpanded = false;

          if (Soho.env.os.name === 'ios') {
            $('head').triggerHandler('enable-zoom');
          }

          // TODO: Make this process more solid, without FOUC/jumpiness and better focus handling (EPC)
          // See http://jira/browse/SOHO-6347
          self.inputWrapper.one($.fn.transitionEndName(), function() {
            self.toolbarParent.triggerHandler('recalculate-buttons');
          });
        }

        // Puts the input wrapper back where it should be if it's been moved due to small form factors.
        this.appendToButtonset();

        if (this.input.val().trim() !== '') {
          textMethod = 'addClass';
        }
        this.inputWrapper[textMethod]('has-text');

        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
        }

        self.inputWrapper.removeClass('active');
        if (!self.hasFocus()) {
          self.inputWrapper.removeClass('has-focus');
        }

        // Return out without collapsing or handling callbacks for the `collapse` event if:
        // Searchfield is not collapsible in general -OR-
        // Searchfield is only collapsible on mobile, and we aren't below the mobile breakpoint
        if ((self.settings.collapsible === false && self.settings.collapsibleOnMobile === false) ||
           (self.settings.collapsible === false && self.settings.collapsibleOnMobile === true && !self.shouldBeFullWidth())) {
          return;
        }

        if (this.fastExpand || !this.shouldExpandOnMobile()) {
          collapseCallback();
          return;
        }

        this.animationTimer = setTimeout(collapseCallback, 310);
      },

      /**
       * If focused, we need to store a reference to the element with focus (searchfield, internal buttons, etc)
       * because once the element becomes removed from the DOM, focus is lost.
       * @private
       */
      saveFocus: function() {
        if (!this.hasFocus()) {
          return;
        }
        this.focusElem = document.activeElement;
      },

      /**
       * Restores focus to an element reference that was previously focused.
       * @private
       */
      restoreFocus: function() {
        if (!this.focusElem) {
          return;
        }

        this.focusElem.focus();
        this.focusElem = undefined;
      },

      /**
       * Appends this searchfield to the `containmentParent` element
       * Used when the small-form-factor searchfield needs to be established.
       * @private
       */
      appendToParent: function() {
        if (this.inputWrapper.parent().is(this.containmentParent)) {
          return;
        }

        this.saveFocus();

        this.elemBeforeWrapper = this.inputWrapper.prev();
        this.inputWrapper.detach().prependTo(this.containmentParent);
        Soho.utils.fixSVGIcons(this.inputWrapper);

        this.restoreFocus();
      },

      /**
       * Removes this searchfield from the `containmentParent` element, and places it back into the buttonset.
       * Used when the small-form-factor searchfield needs to be established.
       * @private
       */
      appendToButtonset: function() {
        if (!this.inputWrapper.parent().is(this.containmentParent)) {
          return;
        }

        this.saveFocus();

        if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
          this.inputWrapper.prependTo(this.toolbarParent.children('.buttonset'));
        } else {
          this.inputWrapper.detach().insertAfter(this.elemBeforeWrapper);
          this.elemBeforeWrapper = null;
        }

        this.removeDocumentDeactivationEvents();
        this.toolbarParent.triggerHandler('scrollup');
        Soho.utils.fixSVGIcons(this.inputWrapper);

        this.restoreFocus();
      },

      /**
       * Determines whether or not the full-size Searchfield should open over top of its sibling Toolbar elements.
       * @private
       * @returns {boolean}
       */
      shouldBeFullWidth: function() {
        var header = this.inputWrapper.closest('.header'),
          headerCondition = false;

        if (header.length) {
          headerCondition = header.width() < Soho.breakpoints.phone;
        }

        return headerCondition || Soho.breakpoints.isBelow('phone-to-tablet');
      },

      /**
       * Determines whether or not the Searchfield should expand on the Mobile breakpoint.
       * @private
       * @returns {boolean}
       */
      shouldExpandOnMobile: function() {
        if (this.settings.collapsible === true) {
          return false;
        }
        if (this.settings.collapsibleOnMobile === true) {
          return true;
        }
        return this.shouldBeFullWidth();
      },

      /**
       * Used when the control has its settings or structural markup changed.  Rebuilds key parts of the control that
       * otherwise wouldn't automatically update.
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Enables the Searchfield
       */
      enable: function() {
        this.inputWrapper.addClass('is-disabled');
        this.input.prop('disabled', true);
      },

      /**
       * Disables the Searchfield
       */
      disable: function() {
        this.inputWrapper.removeClass('is-disabled');
        this.input.prop('disabled', false);
      },

      /**
       * Tears down events, properties, etc. and resets the control to "factory" state
       * @returns {this}
       */
      teardown: function() {
        this.inputWrapper.off('mousedown.toolbarsearchfield focusin.toolbarsearchfield keydown.toolbarsearchfield collapse.toolbarsearchfield');
        this.inputWrapper.find('.icon').remove();
        $(document).off(this.outsideEventStr);

        this.toolbarParent.off('navigate.toolbarsearchfield');
        this.element.off('blur.toolbarsearchfield');

        if (this.xButton && this.xButton.length) {
          this.xButton.remove();
        }

        // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
        $(document).off('keydown.' + this.id);
        $('body').off('resize.' + this.id);

        return this;
      },

      /**
       * Removes the entire control from the DOM and from this element's internal data
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires ToolbarSearchfield#events
       * @param {Object} mousedown  &nbsp;-&nbsp; Fires when the searchfield is clicked (if enabled).
       * @param {Object} focusin  &nbsp;-&nbsp; Fires when the searchfield is focused.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a key is pressed inside of the searchfield.
       * @param {Object} collapse  &nbsp;-&nbsp; Fires when a `collapse` event is triggered externally on the searchfield.
       *
       * @param {Object} beforeopen  &nbsp;-&nbsp; Fires when a `beforeopen` event is triggered on the searchfield's optional categories menubutton.
       *
       * @param {Object} navigate  &nbsp;-&nbsp; Fires when a `navigate` event is triggered on the searchfield's parent toolbar.
       *
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a `keydown` event is triggered at the `document` level.
       * @param {Object} resize  &nbsp;-&nbsp; Fires when a `resize` event is triggered at the `body` level.
       */
      handleEvents: function() {
        var self = this;

        this.inputWrapper.on('mousedown.toolbarsearchfield', function() {
          self.fastExpand = true;
        }).on('focusin.toolbarsearchfield', function(e) {
          self.handleFocus(e);
        }).on('keydown.toolbarsearchfield', function(e) {
          self.handleKeydown(e);
        }).on('collapse.toolbarsearchfield', function() {
          self.collapse();
        });

        if (this.button && this.button.length) {
          this.button.on('beforeopen.toolbarsearchfield', function(e, menu) {
            return self.handlePopupBeforeOpen(e, menu);
          });
        }

        this.toolbarParent.on('navigate.toolbarsearchfield', function() {
          if (!self.hasFocus()) {
            self.collapse();
          }
        });

        // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
        $(document).on('keydown.' + this.id, function(e) {
          self.handleOutsideKeydown(e);
        });

        $('body').on('resize.' + this.id, function() {
          self.adjustOnBreakpoint();
        });
        self.adjustOnBreakpoint();

        if (Soho.env.os.name === 'ios') {
          this.element.on('blur.toolbarsearchfield', function() {
            $('head').triggerHandler('disable-zoom');
          });
        }

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ToolbarSearchfield(this, settings));
      }
    });
  };


  $.fn.tooltip = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'tooltip',
      defaults = {
        content: null,
        offset: {top: 10, left: 10},
        placement: 'top',
        trigger: 'hover',
        title: null,
        beforeShow: null,
        popover: null ,
        closebutton: null,
        isError: false,
        isErrorColor: false,
        tooltipElement: null,
        parentElement: null,
        keepOpen: false,
        extraClass: null,
        placementOpts: undefined,
        maxWidth: null
      };

    /**
     * Tooltip and Popover Control
     * @constructor
     * @param {Object} element
     * @param {Object|Function} options
     * @param {(string|Function)} [options.content] - Takes title attribute or feed content. Can be a string or jQuery markup
     * @param {Object} [options.offset={top: 10, left: 10}] - How much room to leave
     * @param {string} [options.placement=top|bottom|right|offset]
     * @param {string} [options.trigger=hover] - supports click and immediate and hover (and maybe in future focus)
     * @param {string} [options.title] - Title for Infor Tips
     * @param {string} [options.beforeShow] - Call back for ajax tooltip
     * @param {string} [options.popover] - force it to be a popover (no content)
     * @param {string} [options.closebutton] - Show X close button next to title in popover
     * @param {Boolean} [options.isError=false] - Add error classes
     * @param {Boolean} [options.isErrorColor=false] - Add error color only not description
     * @param {string} [options.tooltipElement] - ID selector for an alternate element to use to contain the tooltip classes
     * @param {Object} [options.parentElement=this.element] - jQuery-wrapped element that gets passed to the 'place' behavior as the element to place the tooltip against.
     * @param {Boolean} [options.keepOpen=false] - Forces the tooltip to stay open in situations where it would normally close.
     * @param {string} [options.extraClass] - Extra css class
     * @param {string} [options.maxWidth] - Toolip max width
     */
    function Tooltip(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Tooltip.prototype = {
      init: function() {
        this.setup();
        this.appendTooltip();

        // Initial Content Setting.
        // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
        // display time in that case.
        var shouldRender = this.settings.trigger !== 'immediate';
        if (shouldRender) {
          this.setContent(this.settings.content, true);
        }

        this.handleEvents();
      },


      setup: function() {
        // "this.activeElement" is the target element that the Tooltip will display itself against
        this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;

        this.descriptionId = $('.tooltip-description').length + 1;
        this.description = this.element.parent().find('.tooltip-description');
        if (!this.description.length && this.settings.isError) {
          this.description = $('<span id="tooltip-description-'+ this.descriptionId +'" class="tooltip-description audible"></span>').insertAfter(this.element);
        }

        if (this.element.is('.dropdown, .multiselect')) {
          this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
        }

        var titleAttr = this.element.attr('title');
        if ((!this.settings.popover && titleAttr && titleAttr.length) || (!this.settings.popover && this.settings.title)) {
          this.settings.content = this.settings.title ? this.settings.title : titleAttr;
          this.element.removeAttr('title');
        }

        this.isPopover = (this.settings.content !== null && typeof this.settings.content === 'object') || this.settings.popover === true;

        this.settings.closebutton = (this.settings.closebutton || this.element.data('closebutton')) ? true : false;

        if (this.element.data('extraClass') && this.element.data('extraClass').length) {
          this.settings.extraClass = this.element.data('extraClass');
        }

        this.isRTL = Locale.isRTL();
      },

      addAria: function() {
        if (!this.content) {
          return;
        }

        this.description.text(this.content);
        this.content = this.addClassToLinks(this.content, 'links-clickable');

        if (!this.isPopover) {
          this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
        }

        if (this.isPopover && this.settings.trigger === 'click') {
          this.element.attr('aria-haspopup', true);
        }
      },

      addClassToLinks: function(content, thisClass) {
        var isjQuery = (content instanceof $ && content.length > 0);
        if (isjQuery) {
          return content;
        }

        var d = $('<div/>').html(content);
        $('a', d).addClass(thisClass);
        return d.html();
      },

      appendTooltip: function() {
        this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');
        if (!this.tooltip.length) {
          var name = (this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip');
          this.tooltip = $('<div class="' + (this.isPopover ? 'popover' : 'tooltip') + ' bottom is-hidden" role="tooltip" id="' + name + '"><div class="arrow"></div><div class="tooltip-content"></div></div>');
        }

        this.tooltip.place({
          container: this.scrollparent,
          parent: this.activeElement,
          placement: this.settings.placement,
          strategy: 'flip'
        });

        this.setTargetContainer();
      },

      handleEvents: function() {
        var self = this, timer, delay = 400;

        if (this.settings.trigger === 'hover' && !this.settings.isError) {
          ((this.element.is('.dropdown, .multiselect')) ? this.activeElement : this.element)
            .on('mouseenter.tooltip', function() {
              timer = setTimeout(function() {
                self.show();
              }, delay);
            })
            .on('mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip', function() {
                clearTimeout(timer);
                setTimeout(function() {
                  self.hide();
                }, delay);
            })
            .on('updated.tooltip', function() {
              self.updated();
            });
        }

        function toggleTooltipDisplay() {
          if (!self.tooltip.hasClass('is-hidden')) {
            self.hide();
          }
          self.show();
        }

        if (this.settings.trigger === 'click') {
          this.element.on('click.tooltip', function() {
            toggleTooltipDisplay();
          });
        }

        if (this.settings.trigger === 'immediate') {
          timer = setTimeout(function() {
            toggleTooltipDisplay();
          }, 1);
        }

        // Uncomment the line below to get focus support on some elements all the time, regardless of trigger setting.
        //var isFocusable = (this.element.filter('button, a').length && this.settings.trigger !== 'click') || this.settings.trigger === 'focus';
        var isFocusable = this.settings.trigger === 'focus';
        if (isFocusable) {
          this.element.on('focus.tooltip', function() {
            self.show();
          })
          .on('blur.tooltip', function() {
            if (!self.settings.keepOpen) {
              self.hide();
            }
          });
        }

        // Media Query Listener to detect a menu closing on mobile devices that change orientation.
        this.matchMedia = window.matchMedia('(orientation: landscape)');
        this.mediaQueryListener = function() {
          // Match every time.
          if (self.tooltip.hasClass('is-hidden')) {
            return;
          }
          self.close();
        };
        this.matchMedia.addListener(this.mediaQueryListener);
      },

      setContent: function(content, dontRender) {
        var self = this,
          specified,
          settingsContent = this.settings.content,
          noIncomingContent = (content === undefined || content === null),
          noSettingsContent = (settingsContent === undefined || settingsContent === null);

        function doRender() {
          if (dontRender === true) {
            return;
          }
          self.addAria();
          self.render();
        }

        // If all sources of content are undefined, just return false and don't show anything.
        if (noIncomingContent && noSettingsContent) {
          return false;
        }

        // If the settingsContent type is a function, we need to re-run that function to update the content.
        // NOTE: If you need to use a function to generate content, understand that the tooltip/popover will not
        // cache your content for future reuse.  It will ALWAYS override incoming content.
        if (typeof settingsContent === 'function') {
          content = settingsContent;
        }

        // Use the pre-set content if we have no incoming content
        if (noIncomingContent) {
          content = settingsContent;
        }

        // If the incoming/preset content is exactly the same as the stored content, don't continue with this step.
        // Deep object comparison for jQuery objects is done further down the chain.
        if (content === this.content) {
          doRender();
          return true;
        }

        // jQuery-wrapped elements don't get manipulated.
        // Simply store the reference, render, and return.
        if (content instanceof $ && content.length) {
          this.content = content.addClass('hidden');
          doRender();
          return true;
        }

        // Handle setting of content based on its Object type.
        // If type isn't handled, the tooltip will not display.
        if (typeof content === 'string') {
          if (!content.length) {
            return false;
          }

          // Could be a translation definition
          content = Locale.translate(content) || content;

          // Could be an ID attribute
          // If it matches an element already on the page, grab that element's content and store the reference only.
          if (content.indexOf('#') === 0) {
            var contentCheck = $('' + content);
            if (contentCheck.length) {
              this.content = contentCheck;
              doRender();
              return true;
            }
            return false;
          }

        // functions
        } else if (typeof content === 'function') {
          var callbackResult = content.call(this.element);
          if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
            return false;
          }
          content = callbackResult;

        // if type isn't handled, return false
        } else {
          return false;
        }

        // Store an internal copy of the processed content
        this.content = $.sanitizeHTML(content);

        // Wrap tooltip content in <p> tags if there isn't already one present.
        // Only happens for non-jQuery markup.
        if (!specified) {
          this.content = '<p>' + this.content + '</p>';
        }

        doRender();
        return true;
      },

      render: function() {
        if (this.isPopover) {
          return this.renderPopover();
        }
        return this.renderTooltip();
      },

      renderTooltip: function() {
        var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0],
          contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0],
          extraClass = this.settings.extraClass,
          content = this.content,
          tooltip = this.tooltip[0],
          classes = 'tooltip is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }
        tooltip.setAttribute('class', classes);

        if (titleArea) {
          titleArea.style.display = 'none';
        }

        if (!contentArea.previousElementSibling.classList.contains('arrow')) {
          contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
        }

        if (typeof this.content === 'string') {
          contentArea.innerHTML = content;
        } else {
          contentArea.innerHTML = content[0].innerHTML;
        }
      },

      renderPopover: function() {
        var self = this,
          extraClass = this.settings.extraClass,
          content = this.content,
          contentArea = this.tooltip.find('.tooltip-content'),
          title = this.tooltip[0].querySelector('.tooltip-title'),
          classes = 'popover is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }

        this.tooltip[0].setAttribute('class', classes);

        if (typeof content === 'string') {
          content = $(content);
          contentArea.html(content);
          contentArea.find('.hidden').removeClass('hidden');
        } else {
          contentArea.html(content);
        }

        content[0].classList.remove('hidden');
        contentArea[0].firstElementChild.classList.remove('hidden');

        if (this.settings.title !== null) {
          if (!title) {
            var titleFrag = document.createDocumentFragment();
            title = document.createElement('div');
            title.innerHTML = this.settings.title;
            title.classList.add('tooltip-title');
            titleFrag.appendChild(title);
            this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
          } else {
            title.childNodes[0].nodeValue = this.settings.title;
          }
        }

        if (this.settings.closebutton && title && !title.firstElementChild) {
          var closeBtnX = $(
            '<button type="button" class="btn-icon l-pull-right" style="margin-top: -9px">' +
              $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
              '<span>Close</span>' +
            '</button>'
          ).on('click', function() {
            self.hide();
          });

          title.appendChild(closeBtnX[0]);
        }

        content.initialize();
      },

      // Alias for _show()_.
      open: function() {
        return this.show();
      },

      show: function(newSettings, ajaxReturn) {
        var self = this;
        this.isInPopup = false;

        if (newSettings) {
          this.settings = $.extend({}, this.settings, newSettings);
        }

        if (this.settings.beforeShow && !ajaxReturn) {
          var response = function (content) {
            self.show({content: content}, true);
          };

          if (typeof this.settings.beforeShow === 'string') {
            window[this.settings.beforeShow](response);
            return;
          }

          this.settings.beforeShow(response);
          return;
        }

        var okToShow = true;

        okToShow = this.setContent(this.content);
        if (okToShow === false) {
          return;
        }

        okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);
        if (okToShow === false) {
          return;
        }

        this.tooltip[0].setAttribute('style', '');
        this.tooltip[0].classList.add(this.settings.placement);


        if (this.settings.isError || this.settings.isErrorColor) {
          this.tooltip[0].classList.add('is-error');
        }

        this.position();
        this.element.trigger('show', [this.tooltip]);

        setTimeout(function () {
          $(document).on('mouseup.tooltip', function (e) {
            var target = $(e.target);

            if (self.settings.isError || self.settings.trigger === 'focus') {
             return;
            }

            if (target.is(self.element) && target.is('svg.icon')) {
              return;
            }

            if ($('#editor-popup').length && $('#colorpicker-menu').length) {
              return;
            }

            if (target.closest('.popover').length === 0 &&
                target.closest('.dropdown-list').length === 0) {
              self.hide(e);
            }
          })
          .on('keydown.tooltip', function (e) {
            if (e.which === 27 || self.settings.isError) {
              self.hide();
            }
          });

          if (self.settings.isError && !self.element.is(':visible') && !self.element.is('.dropdown')) {
            self.hide();
          }

          if (window.orientation === undefined) {
            $('body').on('resize.tooltip', function() {
              self.hide();
            });
          }

          // Hide on Page scroll
          $('body').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.modal-body-wrapper').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.scrollable').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.datagrid-body').on('scroll.tooltip', function() {
            self.hide();
          });

          // Click to close
          if (self.settings.isError) {
            self.tooltip.on('click.tooltip', function () {
              self.hide();
            });
          }

          self.element.trigger('aftershow', [self.tooltip]);
        }, 400);

      },

      // Places the tooltip element itself in the correct DOM element.
      // If the current element is inside a scrollable container, the tooltip element goes as high as possible in the DOM structure.
      setTargetContainer: function() {
        var targetContainer = $('body');

        // adjust the tooltip if the element is being scrolled inside a scrollable DIV
        this.scrollparent = this.element.closest('.page-container.scrollable');
        if (this.scrollparent.length) {
          targetContainer = this.scrollparent;
        }

        if (this.settings.parentElement) {
          targetContainer = this.settings.parentElement;
        }

        //this.tooltip.detach().appendTo(targetContainer);
        targetContainer[0].appendChild(this.tooltip[0]);
      },

      // Placement behavior's "afterplace" handler.
      // DO NOT USE FOR ADDITIONAL POSITIONING.
      handleAfterPlace: function(e, placementObj) {
        this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
        this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      },

      position: function () {
        this.setTargetContainer();
        this.tooltip[0].classList.remove('is-hidden');

        var self = this,
          distance = this.isPopover ? 20 : 10,
          tooltipPlacementOpts = this.settings.placementOpts || {},
          opts = $.extend({}, {
            x: 0,
            y: distance,
            container: this.scrollparent,
            containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
            containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
            parent: tooltipPlacementOpts.parent || this.activeElement,
            placement: tooltipPlacementOpts.placement || this.settings.placement,
            strategies: ['flip', 'nudge']
          }, tooltipPlacementOpts);

        if (opts.placement === 'left' || opts.placement === 'right') {
          opts.x = distance;
          opts.y = 0;
        }

        this.tooltip.one('afterplace.tooltip', function(e, placementObj) {
          self.handleAfterPlace(e, placementObj);
        });

        this.tooltip.data('place').place(opts);
        return this;
      },

      // Alias for _hide()_ that works with the global _closeChildren()_ method.
      close: function() {
        return this.hide();
      },

      hide: function() {
        if (this.settings.keepOpen) {
          return;
        }

        if (this.isInPopup) {
          this.settings.content.addClass('hidden');
          return;
        }

        this.tooltip[0].classList.add('is-hidden');
        this.tooltip[0].style.left = '';
        this.tooltip[0].style.top = '';
        this.tooltip.find('.arrow').removeAttr('style');

        this.detachOpenEvents();

        if ($('.popover').not('.is-hidden').length === 0) {
          $(document).off('mouseup.tooltip keydown.tooltip');
          $('body').off('resize.tooltip');
        }

        this.element.trigger('hide', [this.tooltip]);
      },

      updated: function() {
        var self = this;

        if (self.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.show();
          }, 100);
        } else {
          self.setContent();
        }

        return this;
      },

      detachOpenEvents: function () {

        this.tooltip.off('click.tooltip');
        $(document).off('mouseup.tooltip');
        $('body').off('resize.tooltip scroll.tooltip');
        this.element.closest('.modal-body-wrapper').off('scroll.tooltip');
        this.element.closest('.scrollable').off('scroll.tooltip');
        this.element.closest('.datagrid-body').off('scroll.tooltip');

      },

      teardown: function() {
        this.description.remove();
        this.descriptionId = undefined;
        this.activeElement = undefined;

        this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');
        if (!this.tooltip.hasClass('is-hidden')) {
          this.hide();
        }

        this.element.off('mouseenter.tooltip mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip updated.tooltip focus.tooltip blur.tooltip');
        this.detachOpenEvents();

        if (this.matchMedia) {
          this.matchMedia.removeListener(this.mediaQueryListener);
        }

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {

      var instance = $.data(this, pluginName);

      //Allow one tooltip and one popover
      if (instance /*&& (instance.settings.popover == null || instance.settings.popover !== settings.popover)*/) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }

        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();

        return;
      }

      instance = $.data(this, pluginName, new Tooltip(this, options));
    });
  };

  // Popover & Tooltip are the same control
  $.fn.popover = $.fn.tooltip;


  //TODO: - Context Menus
  //      - Search
  $.fn.tree = function(options) {

    /**
     * @class {Tree}
     *
     * @param {string} selectable &nbsp;-&nbsp; 'single' or 'multiple'
     * @param {boolean} hideCheckboxes &nbsp;-&nbsp; Only applies when `selectable` is set to 'multiple'.
     * @param {null|string} menuId &nbsp;-&nbsp; if defined, will be used to identify a Context Menu by ID attribute in which to add nodes.
     * @param {boolean} useStepUI &nbsp;-&nbsp; if `true`, turns this tree instance into a "Stepped" tree.
     * @param {string} folderIconOpen &nbsp;-&nbsp; the icon used when a tree folder node is open.
     * @param {string} folderIconClosed &nbsp;-&nbsp; the icon used when a tree folder node is closed.
     * @param {boolean} sortable &nbsp;-&nbsp; if `true`, allows nodes to become sortable.
     * @param {null|function} onBeforeSelect &nbsp;-&nbsp; if defined as a function, fires that function as a callback before the selection on a node occurs.
     */
    var pluginName = 'tree',
      defaults = {
        selectable: 'single', // ['single'|'multiple']
        hideCheckboxes: false, // [true|false] -apply only with [selectable: 'multiple']
        menuId: null, //Context Menu to add to nodes
        useStepUI: false, // When using the UI as a stepped tree
        folderIconOpen: 'open-folder',
        folderIconClosed: 'closed-folder',
        sortable: false, // Allow nodes to be sortable
        onBeforeSelect: null
      },
      settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tree(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tree Methods
    Tree.prototype = {

      /**
       * @private
       * @returns {undefined}
       */
      init: function() {
        this.settings = $.extend({}, settings);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.initTree();
        this.handleKeys();
        this.setupEvents();
        this.loadData(this.settings.dataset);
        this.syncDataset(this.element);
        this.initSelected();
        this.focusFirst();
        this.attachMenu(this.settings.menuId);
        this.createSortable();
      },

      /**
       * Init Tree from ul, li, a markup structure in DOM
       */
      initTree: function() {
        var self = this,
          s = this.settings,
          links = this.element.find('a'),
          selectableAttr = this.element.attr('data-selectable');

        // Set attribute "data-selectable"
        s.selectable = ((typeof selectableAttr !== 'undefined') &&
         (selectableAttr.toLowerCase() === 'single' ||
           selectableAttr.toLowerCase() === 'multiple')) ?
            selectableAttr : s.selectable;

        // Set isMultiselect and checkboxes show/hide
        this.isMultiselect = s.selectable === 'multiple';
        s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;

        this.element.addClass(this.isMultiselect ? ' is-muliselect' : '');

        links.each(function() {
          var a = $(this);
          self.decorateNode(a);
        });
      },

      /**
       * Init selected notes
       */
      initSelected: function () {
        var self = this;
        this.element.find('li').each(function() {
          self.setNodeStatus($('a:first', this));
        });
      },

      /**
       * Focus the first tree node
       */
      focusFirst: function () {
        this.element.find('a:first').attr('tabindex', '0');
      },

      /**
       * Set focus
       * @param {jQuery[]} node
       */
      setFocus: function (node) {
        node.focus();
      },

      /**
       * From the LI, Read props and add stuff
       * @param {jQuery[]} a - an anchor tag reference wrapped in a jQuery object.
       */
      decorateNode: function(a) {
        var subNode,
        parentCount = 0,
        badgeData = a.attr('data-badge'),
        alertIcon = a.attr('data-alert-icon'),
        badge = {elem: $('<span class="tree-badge badge"></span>')},
        isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0,
        isDisabled = a.hasClass('is-disabled') || isParentsDisabled;

        if (typeof badgeData !== 'undefined') {
          badgeData = $.fn.parseOptions(a, 'data-badge');
        }

        //set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)
        a.attr({'role': 'treeitem', 'tabindex': '-1', 'aria-selected': 'false'});

        // Add Aria disabled
        if (isDisabled) {
          a.addClass('is-disabled').attr('aria-disabled','true');
          var childSection = a.next();

          if (childSection.is('ul.is-open')) {
            $('a', childSection).addClass('is-disabled').attr('aria-disabled','true');
            $('ul', a.parent()).addClass('is-disabled');
          }
        }

        //parentCount 'aria-level' to the node's level depth
        parentCount = a.parentsUntil(this.element, 'ul').length - 1;
        a.attr('aria-level', parentCount + 1);

        //Set the current tree item node position relative to its aria-setsize
        var posinset = a.parent().index();
        a.attr('aria-posinset', posinset + 1);

        //Set the current tree item aria-setsize
        var listCount = a.closest('li').siblings().addBack().length;
        a.attr('aria-setsize', listCount);

        //Set the current tree item node expansion state
        if (a.next('ul').children().length > 0) {
          a.attr('aria-expanded', a.next().hasClass('is-open') ? 'true' : 'false');
        }

        //adds role=group' to all subnodes
        subNode = a.next();

        //Inject Icons
        var text = a.contents().filter(function() {
          return !$(this).is('.tree-badge');// Do not include badge text
        }).text();

        a.text('');
        if (a.children('svg.icon-tree').length === 0) {
          a.prepend($.createIcon({ icon: 'tree-node', classes: ['icon-tree'] }));

          if (this.settings.useStepUI) {
            a.prepend($.createIcon({ icon: alertIcon, classes: ['step-alert', 'icon-' + alertIcon] }));
          }
        }

        //Inject checkbox
        if (this.isMultiselect && !this.settings.hideCheckboxes) {
          a.append('<span class="tree-checkbox"></span>');
        }

        //Inject badge
        if (badgeData && !badgeData.remove) {
          badge.text = '';

          if (typeof badgeData.text !== 'undefined') {
            badge.text = badgeData.text.toString();
            badge.elem.html(badge.text);
            if (badge.text.length === 1) {
              badge.elem.addClass('round');
            }
          }
          if (/info|good|error|alert|pending/i.test(badgeData.type)) {
            badge.elem.addClass(badgeData.type);
          } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
              badge.elem.css('background-color', badgeData.type);
          }

          if (badge.elem.text() !== '') {
            a.append(badge.elem);
          }
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.elem.text('');
          }
        }

        a.append('<span class="tree-text">' + text + '</span>');

        if (a.is('[class^="icon"]')) {
          //createIconPath
          this.setTreeIcon(a.find('svg.icon-tree'), a.attr('class'));
        }

        if (subNode.is('ul')) {
          subNode.attr('role', 'group').parent().addClass('folder');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);

          if (a.attr('class') && a.attr('class').indexOf('open') === -1 && a.attr('class').indexOf('closed') === -1) {
            a.attr('class', isDisabled ? 'is-disabled' : '');
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);
          }

          if (a.is('[class^="icon"]')) {
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ?  a.attr('class') : a.attr('class').replace('open', 'closed') );
          }
        }

        a.addClass('hide-focus');
        a.hideFocus();
      },

      /**
       * Sets the correct icon to use on a particular SVG element.
       * @param {jQuery[]} svg - an SVG element reference wrapped in a jQuery object
       * @param {string} icon - the ID of a Soho Icon type.
       */
      setTreeIcon: function(svg, icon) {
        // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
        var iconStr = icon.replace(/#?icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

      /**
       * Expands a collection of tree nodes.
       * @param {jQuery[]} nodes - a jQuery-wrapped collection of tree node elements.  If left undefined, this will automatically use all `ul[role=group]` elements.
       */
      expandAll: function(nodes) {
        var self = this;
        nodes = nodes || this.element.find('ul[role=group]');

        nodes.each(function () {
          var node = $(this);
          node.addClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconOpen);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class'));
          }

        });
      },

      /**
       * Collapses a collection of tree nodes.
       * @param {jQuery[]} nodes - a jQuery-wrapped collection of tree node elements.  If left undefined, this will automatically use all `ul[role=group]` elements.
       */
      collapseAll: function (nodes) {
        var self = this;
        nodes = nodes || this.element.find('ul[role=group]');

        nodes.each(function () {
          var node = $(this);
          node.removeClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconClosed);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('a').find('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', '') );
          }

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed'));
          }

        });
      },

      /**
       * Check if an object is an instance of a jQuery object
       * @param {Object} obj - the object being tested.
       * @returns {boolean}
       */
      isjQuery: function (obj) {
        // TODO: Move this to a Soho utility object?
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      /**
       * Selects a tree node specifically using it's ID attribute.
       * @param {string} id - the ID string to use.
       */
      selectNodeById: function (id) {
        this.selectNodeByJquerySelector('#'+ id);
      },

      /**
       * Selects a tree node by [jquery selector] -or- [jquery object]
       * @param {string|jQuery[]} selector - uses a string that represents a jQuery-wrapped element's ID attribute, or a jQuery-wrapped reference to the element itself.
       */
      selectNodeByJquerySelector: function (selector) {
        var target = this.isjQuery(selector) ? selector : $(selector);
        if (target.length && !target.is('.is-disabled')) {
          var nodes = target.parentsUntil(this.element, 'ul[role=group]');
          this.expandAll(nodes);
          this.selectNode(target, true);
        }
      },

      /**
       * Deselects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      unSelectedNode: function (node, focus) {
        if (node.length === 0) {
          return;
        }

        var self = this,
          aTags = $('a', this.element);

        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');

        this.syncNode(node);
        this.setNodeStatus(node);

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('unselected', {node: node, data: jsonData});
        }, 0);
      },

      /**
       * Selects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      selectNode: function (node, focus) {
        var self = this;

        if (node.length === 0) {
          return;
        }

        // Possibly Call the onBeforeSelect
        var result;
        if (typeof self.settings.onBeforeSelect === 'function') {

          result = self.settings.onBeforeSelect(node);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode) {
              if (continueSelectNode) {
                self.selectNodeFinish(node, focus);
              }
            });
          } else if (result) { // Boolean is returned instead of a promise
            self.selectNodeFinish(node, focus);
          }

        } else { // No Callback specified
          self.selectNodeFinish(node, focus);
        }
      },

      /**
       * ?
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      selectNodeFinish: function(node, focus) {
        var self = this;
        var aTags = $('a', this.element);
        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        if (this.isMultiselect) {
          $('a:not(.is-disabled)', node.parent())
            .attr('aria-selected', 'true').parent().addClass('is-selected');
        }
        else {
          aTags.attr('aria-selected', 'false').parent().removeClass('is-selected');
          aTags.attr('aria-selected', 'false').removeClass('is-selected');
          node.attr('aria-selected', 'true').parent().addClass('is-selected');
        }

        this.syncNode(node);
        if (!this.loading) {
          this.setNodeStatus(node);
        }

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('selected', {node: node, data: jsonData});
        }, 0);
      },

      /**
       * Deselects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       */
      setNodeStatus: function(node) {
        var self = this,
          data = node.data('jsonData'),
          nodes;

        // Not multiselect
        if (!this.isMultiselect) {
          node.removeClass('is-selected is-partial');
          if (data && data.selected) {
            node.addClass('is-selected');
          }
          return;
        }

        var setStatus = function (nodes, isFirstSkipped) {
          nodes.each(function() {
            var node = $('a:first', this),
              parent = node.parent(),
              status = self.getSelectedStatus(node, isFirstSkipped);

            if (status === 'mixed') {
              parent.removeClass('is-selected is-partial').addClass('is-partial');
            }
            else if (status) {
              parent.removeClass('is-selected is-partial').addClass('is-selected');
            }
            else {
              parent.removeClass('is-selected is-partial');
            }
            self.syncNode(node);
          });
        };

        // Multiselect
        var isFirstSkipped = false;
        nodes = node.parent().find('li.folder');
        setStatus(nodes, isFirstSkipped);

        isFirstSkipped = (!nodes.length && data && !data.selected) ? false : true;
        nodes = node.parentsUntil(this.element, 'li.folder');
        setStatus(nodes, isFirstSkipped);
      },

      /**
       * Get's a tree node's current 'selected' status
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} isFirstSkipped - ?
       */
      getSelectedStatus: function(node, isFirstSkipped) {
        var status,
          total = 0,
          selected = 0,
          unselected = 0,
          data;

        node.parent().find('a').each(function(i) {
          if (isFirstSkipped && i === 0) {
            return;
          }
          total++;
          data = $(this).data('jsonData');
          if (data && data.selected) {
            selected++;
          } else {
            unselected++;
          }
        });

        status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
        return status;
      },

      /**
       * Changes a node's selected status to its opposite form.
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       */
      toggleNode: function(node) {
        var next = node.next(),
          self = this;

        if (next.is('ul[role="group"]')) {
          if (next.hasClass('is-open')) {

            self.setTreeIcon(node.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

            if (node.closest('.folder a').is('[class^="icon"]')) {
              self.setTreeIcon(node.closest('.folder a').find('svg.icon-tree'),
                node.closest('.folder a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', ''));
            }

            self.isAnimating = true;

            if (!self.isMultiselect) {
              self.unSelectedNode(node.parent().find('li.is-selected'), false);
              node.removeClass('is-selected');
            }

            next.one('animateclosedcomplete', function() {
              next.removeClass('is-open');
              self.isAnimating = false;
            }).animateClosed();

            node.attr('aria-expanded', node.attr('aria-expanded')!=='true');



          } else {
            var nodeData = node.data('jsonData');

            if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
              var response = function (nodes) {
                var id = nodeData.id,
                elem = self.findById(id);

                //Add DB and UI nodes
                elem.children = nodes;
                self.addChildNodes(elem, node.parent());
                node.removeClass('is-loading');
                self.loading = false;

                //open
                self.openNode(next, node);

                //sync data on node
                nodeData.children = nodes;
                node.data('jsonData', nodeData);
                self.selectNode(node, true);
                self.initSelected();
              };

              var args = {node: node, data: node.data('jsonData')};
              self.settings.source(args, response);
              node.addClass('is-loading');
              self.loading = true;

              return;
            }
            self.openNode(next, node);
          }
        }
      },

      //Open the node
      openNode: function(next, node) {
        var self = this;

        self.setTreeIcon(node.closest('.folder').addClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconOpen);

        if (node.is('[class^="icon"]')) {
          self.setTreeIcon(node.find('svg.icon-tree'), node.attr('class').replace(' hide-focus', '').replace(' is-selected', ''));
        }

        self.isAnimating = true;

        next.one('animateopencomplete', function() {
          self.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
        node.attr('aria-expanded', node.attr('aria-expanded')!=='true');
      },

      //Setup event handlers
      setupEvents: function () {
        var self = this;
        self.element.on('updated.tree', function () {
          self.initTree();
        });
      },

      //Handle Keyboard Navigation
      handleKeys: function () {

        //Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
        var self = this;
        //on click give clicked element 0 tabindex and 'aria-selected=true', resets all other links
        this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
          var target = $(this),
            parent = target.parent();
          if (!target.is('.is-disabled, .is-loading')) {
            if (self.isMultiselect) {
              if ($(e.target).is('.icon') && parent.is('.folder')) {
                self.toggleNode(target);
              }
              else if (parent.is('.is-selected, .is-partial')) {
                self.unSelectedNode(target, true);
              }
              else {
                self.selectNode(target, true);
              }
            }
            else {
              self.selectNode(target, true);
              self.toggleNode(target);
            }
            e.stopPropagation();
          }
          return false; //Prevent Click from Going to Top
        });

        this.element
        //Focus on "a" elements
        .on('focus.tree', 'a', function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.tree');
              e.keyCode = 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        //Handle Up/Down Arrow Keys and Space
        this.element.on('keydown.tree', 'a', function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.tree');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find('a:first');
                self.setFocus(prev);
              } else {
                self.toggleNode(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                prev = target.closest('.folder').find('a:first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                next = target.closest('.folder').find('a:first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find('a:first');
                self.setFocus(next);
              } else {
                self.toggleNode(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          //Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.element.find('a:first:visible');
            self.setFocus(next);
          }

          //End (fn-right on mac)
          if (charCode === 35) {
            next = self.element.find('a:last:visible');
            self.setFocus(next);
          }

        });

        //Handle Left/Right Arrow Keys
        this.element.on('keypress.tree', 'a', function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest('li').nextAll().find('a:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }

        });
      },

      //handle Loading JSON
      loadData: function (dataset) {
        var self = this;
        if (!dataset) {
          return;
        }

        self.element.empty();

        self.loading = true;
        for (var i = 0; i < dataset.length; i++) {
          self.addNode(dataset[i], 'bottom');
        }

        self.loading = false;
        self.syncDataset(self.element);
      },

      //Functions to Handle Internal Data Store
      addToDataset: function (node, location) {
        var elem;

        if (node.parent) {
          elem = this.findById(node.parent);
        }

        if (location === 'bottom' && !node.parent && !elem) {
          this.settings.dataset.push(node);
        }

        if (location === 'top' && !node.parent && !elem) {
          this.settings.dataset.unshift(node);
        }

        if (node.parent && elem) {

          if (!elem.children) {
            elem.children = [];
          }

          if (location === 'bottom') {
            elem.children.push(node);
          } else {
            elem.children.unshift(node);
          }
        }

        return ((node.parent && !elem) ? false : true);
      },

      //Find the Node (Dataset) By Id
      findById: function (id, source) {
        var key,
          self = this;

        if (!source) {
          source = this.settings.dataset;
        }

        for (key in source) {
            var item = source[key];
            if (item.id === id) {
              return item;
            }

            if (item.children) {
              var subresult = self.findById(id, item.children);

              if (subresult) {
                return subresult;
              }
            }
        }
        return null;
      },

      // Get node by ID if selected
      getNodeByIdIfSelected: function (id, source) {
        var node = this.findById(id, source);
        return (node && node.selected) ? node : null;
      },

      // Get selected nodes
      getSelectedNodes: function () {
        var node, data,
          selected = [];

        $('li.is-selected', this.element).each(function() {
          node = $('a:first', this);
          data = node.data('jsonData');
          selected.push({'node': node, 'data': data});
        });
        return selected;
      },

      getNextNode: function(target) {
        var next = target.parent().next().find('a:first'),
          subTarget = target.next();

        //Move Into Children
        if (subTarget.is('ul.is-open')) {
          next = subTarget.find('a:first');
        }

        //skip disabled
        if (next.hasClass('is-disabled')) {
          next = next.parent().next().find('a:first');
        }

        //bottom of a group..{l=1000: max folders to be deep }
        if (next.length === 0) {
          for (var i = 0, l = 1000, closest = target; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find('a:first');
            if (next.length) {
              break;
            }
          }
        }

        //another check for disabled
        if (next.hasClass('is-disabled')) {
          next = this.getNextNode(next);
        }

        return next;
      },

      getPreviousNode: function(target) {
        var prev = target.parent().prev().find('a:first'),
          subTarget = prev.parent();

        //move into children at bottom
        if (subTarget.is('.folder.is-open') &&
            subTarget.find('ul.is-open a').length &&
            !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }

        //skip disabled
        if (prev.hasClass('is-disabled')) {
          prev = prev.parent().prev().find('a:first');

          //another check if get to prev open folder
          subTarget = prev.parent();
          if (subTarget.is('.folder.is-open') &&
              subTarget.find('ul.is-open a').length &&
              !subTarget.find('ul.is-disabled').length) {
            prev = subTarget.find('ul.is-open a:last');
          }
        }

        //top of a group
        if (prev.length === 0) {
          prev = target.closest('ul').prev('a');
        }

        //another check for disabled
        if (prev.hasClass('is-disabled')) {
          prev = this.getPreviousNode(prev);
        }

        return prev;
      },


      //Sync the tree with the underlying dataset
      syncDataset: function (node) {

        var json = [],
          self = this;

        node.children('li').each(function () {
          var elem = $(this),
            tag = elem.find('a:first');

          var entry = self.syncNode(tag);
          json.push(entry);

        });

        this.settings.dataset = json;
      },

      //Sync a node with its dataset 'record'
      syncNode: function (node) {
        var entry = {},
          self = this,
          jsonData = node.data('jsonData');

        entry.node = node;
        entry.id = node.attr('id');
        entry.text = node.find('.tree-text').text();

        if (node.hasClass('is-open')) {
          entry.open = true;
        }

        if (node.attr('href')) {
          entry.href = node.attr('href');
        }

        if (node.parent().is('.is-selected')) {
          entry.selected = true;
        }

        //icon
        var clazz = node.attr('class');
        if (clazz && clazz.indexOf('icon') > -1) {
          entry.icon = node.attr('class');
        }

        if (node.next().is('ul')) {
          var ul = node.next();
          entry.children = [];

          ul.children('li').each(function () {
            var elem = $(this),
              tag = elem.find('a:first');

            entry.children.push(self.syncNode(tag));
          });
        }

        if (jsonData) {
          delete jsonData.selected;
          entry = $.extend({}, jsonData, entry);
        }

        node.data('jsonData', entry);
        return entry;
      },

      // Add a node and all its related markup
      addNode: function (nodeData, location) {
        var li = $('<li></li>'),
          a = $('<a href="#"></a>').appendTo(li),
          badgeAttr = typeof nodeData.badge === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;

        location = (!location ? 'bottom' : location); //supports button or top or jquery node

        a.attr({
          'id': nodeData.id,
          'href': nodeData.href,
          'data-badge': badgeAttr,
          'data-alert-icon': nodeData.alertIcon
        }).text(nodeData.text);

        if (nodeData.open) {
          a.parent().addClass('is-open');
        }

        if (nodeData.disabled) {
          a.addClass('is-disabled');
        }

        if (nodeData.icon) {
          a.addClass(nodeData.icon);
        }

        //Handle Location
        var found = this.loading ? true : this.addToDataset(nodeData, location);

        if (nodeData.parent instanceof jQuery) {
          found = true;
        }

        if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery)) {
          location.append(li);
          found = true;
        }

        if (location === 'bottom' && (!nodeData.parent || !found)) {
          this.element.append(li);
        }

        if (location === 'top' && (!nodeData.parent || !found)) {
          this.element.prepend(li);
        }

        // Support ParentId in JSON Like jsTree
        if (nodeData.parent) {

          if (found && typeof nodeData.parent === 'string') {
            li = this.element.find('#'+nodeData.parent).parent();

            if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
              nodeData.selected = true;
            }
            this.addAsChild(nodeData, li);
          }

          if (nodeData.parent && nodeData.parent instanceof jQuery) {
            li = nodeData.parent;
            if (nodeData.parent.is('a')) {
              li = nodeData.parent.parent();
            }
            this.addAsChild(nodeData, li);
          }
          nodeData.node = li.find('ul li a#'+ nodeData.id);

        } else {
          this.addChildNodes(nodeData, li);
          nodeData.node = li.children('a').first();
        }

        this.decorateNode(a);

        if (nodeData.selected) {
          this.selectNode(a, nodeData.focus);
        }

        a.data('jsonData', nodeData);
        return li;
      },

      //Add a node to an exiting node, making it a folder if need be
      addAsChild: function (nodeData, li) {
        var ul = li.find('ul').first();
        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass('folder');
        }

        ul.addClass(nodeData.open ? 'is-open' : '');
        this.decorateNode(li.find('a').first());

        nodeData.parent = '';
        this.addNode(nodeData, ul);
      },

      //Add the children for the specified node element
      addChildNodes: function (nodeData, li) {
        var self = this,
          ul = li.find('ul');

        if (!nodeData.children) {
          ul.remove();
          return;
        }

        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass(nodeData.open ? 'is-open' : '');
          ul.addClass('folder');
        }

        ul.empty();

        if (nodeData.children) {
          for (var i = 0; i < nodeData.children.length; i++) {
            var elem = nodeData.children[i];
            self.addNode(elem, ul);
          }
        }
      },

      // Check for true value
      isTrue: function(v) {
        return (typeof v !== 'undefined' && v !== null && ((typeof v === 'boolean' && v === true) || (typeof v === 'string' && v.toLowerCase() === 'true')));
      },

      // Check for false value
      isFalse: function(v) {
        return (typeof v !== 'undefined' && v !== null && ((typeof v === 'boolean' && v === false) || (typeof v === 'string' && v.toLowerCase() === 'false')));
      },

      //Update fx rename a node
      updateNode: function (nodeData) {
        //Find the node in the dataset and ui and sync it
        var elem = this.findById(nodeData.id);

        //Passed in the node element
        if (nodeData.node) {
          elem = {};
          elem.node = nodeData.node;
        }

        if (!elem) {
          return;
        }

        var parent = elem.node.parent(),
          isDisabled = this.isTrue(nodeData.disabled) || this.isFalse(nodeData.enabled),
          isEnabled = this.isTrue(nodeData.enabled) || this.isFalse(nodeData.disabled);

        // Update badge
        if (nodeData.badge) {
          var badge = elem.node.find('.tree-badge:first');
          // Add badge if not exists
          if (!badge.length && !nodeData.badge.remove) {
            if (!nodeData.badge.remove && typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
              $('<span class="tree-badge badge"></span>').insertBefore(elem.node.find('.tree-text:first'));
              badge = elem.node.find('.tree-badge:first');
            }
          }
          // Make update changes
          if (badge.length) {
            if (typeof nodeData.badge.text !== 'undefined') {
              nodeData.badge.text = nodeData.badge.text.toString();
              badge.text(nodeData.badge.text).removeClass('round');
              if (nodeData.badge.text.length === 1) {
                badge.addClass('round');
              }
            }
            if (typeof nodeData.badge.type !== 'undefined') {
              badge.removeClass('info good error alert pending');
              if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
                badge.addClass(nodeData.badge.type);
              } else if (nodeData.type && nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
                badge.elem.css('background-color', nodeData.badge.type);
              }

              if (nodeData.badge.type.indexOf('pending') !== -1) {
                badge.text('');
              }
            }
            elem.badge = nodeData.badge;

            //Remove badge
            if (this.parseBool(nodeData.badge.remove)) {
              badge.remove();
              if (typeof elem.badge !== 'undefined') {
                delete elem.badge;
              }
            }
          }
        }

        if (nodeData.text) {
          elem.node.find('.tree-text').first().text(nodeData.text);
          elem.text = nodeData.text;
        }

        if (nodeData.icon) {
          this.setTreeIcon(elem.node.find('svg.icon-tree').first(), nodeData.icon);
          elem.icon = nodeData.icon;
        }

        if (isDisabled) {
          elem.node.addClass('is-disabled').attr('aria-disabled','true');

          if (parent.is('.folder.is-open')) {
            $('a, ul[role=group]', parent).addClass('is-disabled').attr('aria-disabled','true');
          }
        }

        if (isEnabled) {
          var isParentsDisabled = elem.node.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;

          if (!isParentsDisabled) {
            elem.node.removeClass('is-disabled').removeAttr('aria-disabled');

            if (parent.is('.folder.is-open')) {
              $('a, ul[role=group]', parent).removeClass('is-disabled').removeAttr('aria-disabled');
            }
          }
        }

        if (nodeData.node) {
          this.syncDataset(this.element);
        }

        if (nodeData.children) {
          if (nodeData.children.length) {
            this.addChildNodes(nodeData, parent);
          }
          else {
            this.removeChildren(nodeData, parent);
          }
        }

      },

      // Performs the usual Boolean coercion with the exception of
      // the strings "false" (case insensitive) and "0"
      parseBool: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      // Delete children nodes
      removeChildren: function (nodeData, li) {
        var ul = li.find('ul');

        this.setTreeIcon(li.find('svg.icon-tree').first(), (nodeData.icon || 'icon-tree-node'));
        li.removeClass('folder is-open');
        ul.remove();
      },

      //Delete a node from the dataset or tree
      removeNode: function (nodeData) {
        var elem = this.findById(nodeData.id);

        if (nodeData instanceof jQuery) {
          elem = nodeData;
          elem.parent().remove();
        } else if (elem) {
          elem.node.parent().remove();
        }

        if (!elem) {
          return;
        }
        this.syncDataset(this.element);
      },

      //Attach Context Menus
      attachMenu: function (menuId) {
        var self = this;

        if (!menuId) {
          return;
        }

        this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
          var node = $(this);
          e.preventDefault();

          $(e.currentTarget).popupmenu({menuId: menuId, eventObj: e, trigger: 'immediate', attachToBody: true}).off('selected').on('selected', function (e, args) {
            self.element.triggerHandler('menuselect', {node: node, item: args});
          });

          self.element.triggerHandler('menuopen', {menu: $('#' +menuId), node: node});
          return false;
        });

      },

      // Create sortable
      createSortable: function() {
        if (!this.settings.sortable) {
          return;
        }

        var self = this,
          clone, interval, doDrag;

        self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        self.linkSelector = 'a:not(.is-dragging-clone, .is-disabled)';

        if (!self.targetArrow.length) {
          $('<div class="tree-drag-target-arrow"></div>').insertBefore(self.element);
          self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        }

        function isReady() {
          // Make sure all dynamic nodes sync
          if (!self.loading) {
            clearInterval(interval);

            $(self.linkSelector, self.element).each(function() {
              var a = $(this);

              // Don't drag with folder icon, save for toggle nodes
              a.on('mousedown.tree', function(e) {
                e.preventDefault();
                doDrag = (e.which === 3) ? false : // 3 - Right mouse button clicked
                  ($(e.target).is('.icon') ? !a.parent().is('.folder') : true);
              })

              // Invoke drag
              .drag({
                clone: true,
                cloneAppendTo: a.closest('li'),
                clonePosIsFixed: true
              })

              // Drag start =======================================
              .on('dragstart.tree', function (e, pos, thisClone) {
                if (!thisClone || !doDrag) {
                  a.removeClass('is-dragging');
                  if (thisClone) {
                    thisClone.remove();
                  }
                  return;
                }
                clone = thisClone;
                clone.removeAttr('id').addClass('is-dragging-clone');
                clone.find('.tree-checkbox, .tree-badge').remove();

                self.sortable = {
                  // Do not use index from each loop, get updated index on drag start
                  startIndex: $(self.linkSelector, self.element).index(a),
                  startNode: a,
                  startIcon: $('svg.icon-tree', a).getIconName(),
                  startUl: a.closest('ul'),
                  startFolderNode: a.closest('ul').prev('a'),
                  startWidth: a.outerWidth()
                };

                e.preventDefault();
                e.stopImmediatePropagation();
              })

              // While dragging ===================================
              .on('drag.tree', function (e, pos) {
                if (!clone) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';
                clone[0].style.opacity = '1';
                self.setDragOver(clone, pos);
              })

              // Drag end =========================================
              .on('dragend.tree', function (e, pos) {
                self.targetArrow.hide();
                $(self.linkSelector, self.element).removeClass('is-over');

                if (!clone || !self.sortable.overDirection) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';

                var start = self.sortable.startNode.parent(),
                  end = self.sortable.overNode.parent();

                // Over
                if (self.sortable.overDirection === 'over') {
                  if (!end.is('.folder')) {
                    self.convertFileToFolder(self.sortable.overNode);
                  }
                  $('ul:first', end).append(start);
                  if (!end.is('.is-open')) {
                    self.toggleNode(self.sortable.overNode);
                  }
                }

                // Up
                else if (self.sortable.overDirection === 'up') {
                  start.insertBefore(end);
                }
                // Down
                else if (self.sortable.overDirection === 'down') {
                  if (end.is('.is-open')) {
                    $('ul:first', end).prepend(start);
                  }
                  else {
                    start.insertAfter(end);
                  }
                }

                // Restore file type
                if ($('li', self.sortable.startUl).length === 0 &&
                  !!self.sortable.startFolderNode.data('oldData') &&
                    self.sortable.startFolderNode.data('oldData').type === 'file') {
                  self.convertFolderToFile(self.sortable.startFolderNode);
                }

                // Fix: On windows 10 with IE-11 icons disappears
                if (self.isIe11) {
                  start.find('.icon-tree').each(function() {
                    var svg = $(this);
                    self.setTreeIcon(svg, svg.find('use').attr('xlink:href'));
                  });
                }

                // Sync dataset and ui
                self.syncDataset(self.element);
                if (self.isMultiselect) {
                  self.initSelected();
                }

              });
            });

          }
        }
        // Wait for make sure all dynamic nodes sync
        interval = setInterval(isReady, 10);
      },

      // Set actions while drag over
      setDragOver: function(clone, pos) {
        var self = this,
          treeRec = self.element[0].getBoundingClientRect(),
          extra = 20,
          exMargin, isParentsStartNode, isBeforeStart, isAfterSttart,
          li, a, ul, links, rec, i, l, left, top, direction, doAction,

          // Set as out of range
          outOfRange = function() {
            self.sortable.overNode = null;
            self.sortable.overIndex = null;
            self.sortable.overDirection = null;

            self.targetArrow.hide();
            self.setTreeIcon($('svg.icon-tree', clone), 'icon-cancel');
          };

        // Moving inside tree
        if (pos.top > (treeRec.top - extra) &&
            pos.top < (treeRec.bottom + extra) &&
            pos.left > (treeRec.left - extra - self.sortable.startWidth) &&
            pos.left < (treeRec.left + treeRec.height + extra)) {

          links = $(self.linkSelector, self.element);
          extra = 2;

          for (i = 0, l = links.length; i < l; i++) {
            direction = null;
            rec = links[i].getBoundingClientRect();

            // Moving on/around node range
            if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
              a = $(links[i]);

              // Moving on/around node has parents as same node need to rearrange
              // Cannot rearrange parents to child
              isParentsStartNode = !!a.parentsUntil(self.element, '.folder')
                .filter(function() {
                  return $('a:first', this).is(self.sortable.startNode);
                }).length;
              if (isParentsStartNode) {
                outOfRange();
                continue;
              }

              li = a.parent();
              left = rec.left;
              ul = a.closest('ul');
              exMargin = parseInt(li[0].style.marginTop, 10) > 0 ? 2 : 0;
              isBeforeStart = ((i-1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              isAfterSttart = ((i+1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              links.removeClass('is-over');

              // Apply actions
              doAction = function() {
                if (!direction) {
                  outOfRange();
                  return;
                }

                // Reset icon
                self.setTreeIcon($('svg.icon-tree', clone), self.sortable.startIcon);

                // Over
                if (direction === 'over') {
                  self.targetArrow.hide();
                  if (!a.is('.is-disabled')) {
                    a.addClass('is-over');
                  }
                }
                // Up -or- Down
                else {
                  links.removeClass('is-over');
                  top = (direction === 'up') ?
                    (rec.top - 1.5 - (li.is('.is-active') ? 3 : 0)) :
                    (rec.bottom + (li.next().is('.is-active') ? -1 : 1.5) + exMargin);
                  self.targetArrow[0].style.left = left + 'px';
                  self.targetArrow[0].style.top = top + 'px';
                  self.targetArrow.show();
                }

                // Set changes
                self.sortable.overNode = a;
                self.sortable.overIndex = i;
                self.sortable.overDirection = direction;
              };

              // Set moveing directions
              if (i !== self.sortable.startIndex) {
                // If hover on link
                if (pos.left > rec.left - extra - self.sortable.startWidth &&
                  pos.left < rec.right + extra) {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart && pos.top > rec.top + (extra * 2)) {
                    direction = 'down';
                  }
                  else {
                    direction = 'over';
                  }
                }
                // Not hover on link
                else {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart) {
                    direction = 'down';
                  }
                }
              }
              doAction(direction);
            }
          }

        }
        else {
          // Out side from tree area
          outOfRange();
        }
      },

      // Convert file node to folder type
      convertFileToFolder: function(node) {
        var newFolder = $('<ul role="group"></ul>'),
          oldData = {
            icon: $('svg.icon-tree', node).getIconName(),
            type: 'file'
          };
        if (node.is('[class^="icon"]')) {
          var iconClass = node.attr('class').replace(' hide-focus', '').replace(' is-selected', '');
          oldData.iconClass = iconClass;
          node.removeClass(iconClass);
        }
        node.data('oldData', oldData);
        node.parent('li').addClass('folder').append(newFolder);
        this.setTreeIcon($('svg.icon-tree', node), this.settings.folderIconClosed);
      },

      // Convert folder node to file type
      convertFolderToFile: function(node) {
        var parent = node.parent('.folder');
        parent.removeClass('folder is-open');
        $('ul:first', parent).remove();
        if (parent.length) {
          this.setTreeIcon(
            $('svg.icon-tree', node),
            node.data('oldData') ? node.data('oldData').icon : 'tree-node'
          );
          if (node.data('oldData') && node.data('oldData').iconClass) {
            node.addClass(node.data('oldData').iconClass);
          }
          node.data('oldData', null);
        }
      },

      // Tree Related Functions
      destroy: function() {
        if (this.settings.sortable) {
          this.element.find('a').each(function() {
            var a = $(this), dragApi = a.data('drag');
            a.off('mousedown.tree');
            if (!!dragApi && !!dragApi.destroy) {
              dragApi.destroy();
            }
          });
          this.element.prev('.tree-drag-target-arrow').remove();
        }
        this.element.removeData(pluginName);
        this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Tree(this, settings));
      }
    });

  };


  /**
   * @class Validator
   * @constructor
   * @param {Object} element
   */
  function Validator(element) {
    this.element = $(element);
    Soho.logTimeStart('Validator');
    this.init();
    Soho.logTimeEnd('Validator');
  }

  // Plugin Object
  Validator.prototype = {

    /**
     * @private
     * @returns {undefined}
     */
    init: function() {
      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input'));//placeholder native support is-exists

      //If we initialize with a form find all inputs
      this.inputs = this.element.find(this.fields);

      //Or Just use the current input
      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.timeout = null;
    },

    /**
     * Gets a list of events
     * @private
     */
    extractEvents: function (events) {
      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if (typeof events === 'object') {
        var e = '';
        for (var k in events) {
          if (e.indexOf(events[k]) === -1) {
            e += events[k] +' ';
          }
        }
        e = e.split(' ').join('.validate ');
        events = e;
      }

      return events;
    },

    /**
     * @private
     */
    filterValidations: function (events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if(typeof events === 'object') {
        for (var k in events) {
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },

    /**
     * @private
     */
    attachEvents: function () {
      var self = this,
        attribs = '[data-validate],[data-validation]';

      //Attach required
      this.inputs.each(function () {
        var field = $(this),
        attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      });

      //Link on to the current object and perform validation.
      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=checkbox], [readonly]').each(function () {
        var field = $(this),
        attribs = field.attr('data-validation-events'),
        events = (attribs ? attribs : 'blur.validate change.validate keyup.validate');

        events = self.extractEvents(events);

        field.on(events, function (e) {

          //Skip on Tab
          if (e.type === 'keyup' && e.keyCode === 9) {
            return;
          }

          var field = $(this);
          setTimeout(function () {
            if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field[0].style.visibility === 'is-hidden' || !field.is(':visible')) {
              return;
            }

            if (field.closest('.modal-engaged').length && !field.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });

      this.inputs.filter('input[type=checkbox]').filter(attribs).on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      this.inputs.filter(':radio').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip');

          field.next('.dropdown-wrapper').next('.error-message').hide();
          if (tooltip && document.activeElement === field.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }
          $('#validation-tooltip').hide();

        }).on('listclosed.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip');

          field.next('.dropdown-wrapper').next('.error-message').show();
          if (tooltip && document.activeElement !== field.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });

        selects.filter(function() {
          return $(this).data('dropdown') !== undefined;
        }).data('dropdown').pseudoElem.on('blur.validate', function(e) {
          var select = $(this).closest('.field, .field-short').find('select');
          self.validate(select, true, e);
        });
      }

      //Attach to Form Submit and Validate
      if (this.element.is('form')) {

        var submitHandler = function (e) {
          e.stopPropagation();
          e.preventDefault();
          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.trigger('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.on('submit.validate', submitHandler);
      }

    },

    /**
     * @private
     */
    validateForm: function (callback) {
      var self = this,
        deferreds = [];

      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);
        if (field.attr('data-validate')) {

          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return true;
          }

          var dfds = self.validate(field, false, e);
          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }

      });

      $.when.apply($, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },

    /**
     * Set disable/enable primary button in modal
     * @private
     */
    setModalPrimaryBtn: function(field, modalBtn, isValid) {
      var modal = field.closest('.modal'),
        modalFields = modal.find('[data-validate]:visible').add('select[data-validate], :checkbox[data-validate]'),
        allValid = true;

      if (modalFields.length > 0) {
        modalFields.each(function () {
          var modalField = $(this);
          modalField.data('isValid', isValid);
          if (modalField.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }
          var isVisible = modalField[0].offsetParent !== null;
          if (modalField.is('.required')) {
            if ((isVisible || modalField.is('select, :checkbox'))  && !modalField.val()) {
              allValid = false;
            }
          } else {
            if ((isVisible  || modalField.is('select, :checkbox')) && !modalField.isValid()) {
              allValid = false;
            }
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },

    /**
     * Gets the current value of a field
     * @private
     * @param {jQuery[]} field
     * @returns {?}
     */
    value: function(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }
      if (field.is('div')) { // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }
      return field.val();
    },

    /**
     *
     * @private
     * @param {jQuery[]}
     * @param {jQuery.Event} e
     * @returns {Array}
     */
    getTypes: function(field, e) {
      var filters = this.filterValidations(field.attr('data-validation-events'), e.type),
        validations;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      }

      //Filter out not needed events
      if (filters.length > 0) {
        validations = validations.filter(function(n) {
          return filters.indexOf(n) !== -1;
        });
      }

      //Filter out specific events that should not use keyup
      if (e.type === 'keyup') {
        validations = validations.filter(function(n) {
          return n !== 'date' && n !== 'time';
        });
      }

      return validations;
    },

    /**
     * Set Error icon on parent tabs/expandable
     * @private
     * @param {jQuery[]} field
     * @returns {undefined}
     */
    setErrorOnParent: function (field) {
      var errorIcon = $.createIcon({ classes: ['icon-error'], icon: 'error' }),
        parent = field.closest('.tab-panel, .expandable-pane'),
        parentContainer = field.closest('.tab-container, .tab-panel-container, .expandable-area'),
        iconTarget = parent.attr('id'),
        iconContainer,
        dropdown,
        dropdownParent,
        menuitem;

      //Tabs
      if (parentContainer.is('.tab-panel-container')) {
        parentContainer = parentContainer.prev('.tab-container');
      }
      if (parentContainer.is('.tab-container')) {
        //Default Tabs
        iconContainer = $('.tab-list a[href="#'+ iconTarget +'"]', parentContainer).closest('.tab');

        //Tabs with Counts
        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        }
        //Dropdown Tabs(with popupmenu)
        else {
          iconTarget = $('a[href="#'+ iconTarget +'"]', '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $('.tab-list .tab[aria-controls="'+ iconTarget +'"]', parentContainer);
          dropdown = iconTarget;
        }
      }

      //Expandable
      else if (parentContainer.is('.expandable-area')) {
        iconContainer = $('.expandable-header[aria-controls="'+ iconTarget +'"] .title', parentContainer);
      }

      //No action
      else {
        return;
      }

      //if Dropdown Tabs set each menu item to check
      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', '#'+ dropdown).each (function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }
      menuitem = $('a[href="#'+ parent.attr('id') +'"]', '#'+ iconTarget);

      //Add Error icon
      if ((!!parent && $('.error', parent).length) ||
          (!!dropdownParent && $('.error', dropdownParent).length)) {

        //if Dropdown Tabs and current menu item has no error remove icon
        if (!$('.error', parent).length) {
          menuitem.removeClass('is-error');
          $('.icon-error', menuitem).remove();
        }

        //if Dropdown Tabs and current menu item has error add icon
        if ($('.error', parent).length &&
            $('.error', dropdownParent).length &&
            !$('.icon-error', menuitem).length) {
            menuitem.addClass('is-error').append(errorIcon);
        }

        //Add icon to main tab area
        if (!($('.icon-error', iconContainer).length)) {
          iconContainer.addClass('is-error').append(errorIcon);
        }
      }

      //Remove Error icon
      else {
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass('is-error');
        $('.icon-error', iconContainer).remove();
      }
    },

    /**
     *
     * @private
     * @param {jQuery[]} field
     * @param {boolean} showTooltip
     * @param {jQuery.Event} e
     */
    validate: function (field, showTooltip, e) {
      //call the validation function inline on the element
      var self = this,
        types = self.getTypes(field, e) || [],
        rule, dfd,
        dfds = [],
        errors = [],
        i, l,
        value = self.value(field),
        placeholder = field.attr('placeholder'),

        manageResult = function (result, showTooltip) {
          // Only remove if "false", not any other value ie.. undefined
          if (rule.positive === false) {
            self.removePositive(field);
          }

          if (!result) {
            if (!self.isPlaceholderSupport && (value === placeholder) &&
               (rule.message !== Locale.translate('Required'))) {
              return;
            }

            self.addError(field, rule.message, field.attr('data-error-type') === 'tooltip' ? false: true, showTooltip);
            errors.push(rule.msg);
            dfd.reject();
          }
          else if (errors.length === 0) {
            self.removeError(field);
            dfd.resolve();

            if (rule.positive) {
              // FIX: In Contextual Action Panel control not sure why but need to add error,
              // otherwise "icon-confirm" get misaligned,
              // so for this fix adding and then removing error here
              self.addError(field, rule.message, rule.inline, showTooltip);
              self.removeError(field);
              dfd.resolve();

              self.addPositive(field);
            }
          }
          self.setErrorOnParent(field);
        };

      self.removeError(field);
      field.removeData('data-errormessage');

      for (i = 0, l = types.length; i < l; i++) {
        rule = $.fn.validation.rules[types[i]];
        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if ($('#calendar-popup').is(':visible')) {
          continue; //dont show validation message while selecting
        }

        if (rule.async) {
          rule.check(value, field, manageResult);
        } else {
          manageResult(rule.check(value, field), showTooltip);
        }
        dfds.push(dfd);
      }

      return dfds;
    },

    /**
     * Retrive the actionble element that should have an error class/icon appended to it.
     * @private
     * @param {jQuery[]} field
     * @returns {jQuery[]}
     */
    getField: function(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }
      return field;
    },

    /**
     * Returns true if the given object has an error
     *
     * @param {jQuery[]} field
     * @returns {boolean}
     */
    hasError: function(field) {
      return this.getField(field).hasClass('error');
    },

    /**
     * Adds an error message/icon to a form field.
     *
     * @param {jQuery[]} field
     * @param {String} message
     * @param {boolean} inline
     * @param {boolean} showTooltip
     */
    addError: function(field, message, inline, showTooltip) {
      var loc = this.getField(field).addClass('error'),
         dataMsg = loc.data('data-errormessage'),
         appendedMsg = message;

      if (dataMsg) {
        appendedMsg = (/^\u2022/.test(dataMsg)) ? '' : '\u2022 ';
        appendedMsg += dataMsg + '<br>\u2022 ' + message;
      }

      loc.data('data-errormessage', appendedMsg);

      //Add Aria Alert
      if ($.fn.toast !== undefined) {
        $('body').toast({title: Locale.translate('Error'), audibleOnly: true, message: appendedMsg});
      }

      if (!inline) {
        this.showTooltipError(field, appendedMsg, showTooltip);
        return;
      }

      // Disable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, false);
      }

      this.showInlineError(loc, message);
    },

    /**
     * Shows an error icon
     *
     * @private
     * @param {jQuery[]} field
     * @returns {jQuery[]}
     */
    showErrorIcon: function(field) {
      var loc = this.getField(field).addClass('error'),
        svg = $.createIconElement({ classes: ['icon-error'], icon: 'error' });

      if (loc.parent('.field, .field-short').find('svg.icon-error').length === 0) {

        if (field.parent().is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length ===1) {
          field.parent().find('.btn-actions').before(svg);
        } else if (field.parent().find('.data-description').length ===1) {
          field.parent().find('.data-description').before(svg);
        } else if (field.parent().find('.field-info').length ===1) {
          field.parent().find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          field.parent().find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          field.parent().append(svg);
        } else if (field.is('.lookup')) {
          field.parent().append(svg);
        } else {
          field.parent().append(svg);
        }

        $('.icon-confirm', loc.parent('.field, .field-short')).remove();
      } else {
        svg = loc.parent('.field, .field-short').find('svg.icon-error');
      }

      return svg;
    },

    /**
     * Shows an tooltip error
     *
     * @private
     * @param {jQuery[]} field
     * @param {string} message
     * @param {boolean} showTooltip
     */
    showTooltipError: function(field, message, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showErrorIcon(field);
      var representationField = field;

      //Add error classes to pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass('error');
      }

      var tooltipAPI = icon.data('tooltip');

      // Error tooltips should be positioned on the 'x' so that they sit directly underneath the fields
      // that they are indicating.
      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect(),
          elRect = tooltipAPI.tooltip[0].getBoundingClientRect(),
          rtl = $('html').is('[dir="rtl"]'),
          currX = placementObj.x,
          xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += (fieldRect.left - elRect.left);
          }
        } else {
          if (elRect.right > fieldRect.right) {
            xAdjustment += (elRect.right - fieldRect.right) * -1;
          }
        }

        placementObj.setCoordinate('x', currX + xAdjustment);
        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }
        placementObj.nudges.x = xAdjustment;

        return placementObj;
      }

      // Build Tooltip
      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.show();
      }).on('blur.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.hide();
      });

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },

    /**
     * Shows an tooltip error
     *
     * @private
     * @param {jQuery[]} field
     * @param {string} message
     * @param {HTMLElement} markup
     * @param {boolean} isShow
     */
    toggleRadioError:  function (field, message, markup, isShow) {
      var all, loc,
        name = field.attr('name');

      if (name && name.length) {
        all = $(':radio[name="'+ name +'"], :radio[name="'+ name +'"] + label');
        loc = field.parent().is('.inline') ?
          $(':radio[name="'+ name +'"]:last').parent() :
          $(':radio[name="'+ name +'"]:last + label');

        if (isShow) {
          all.addClass('error');
          $(markup).addClass('radio-group-error').insertAfter(loc);
        }
        else {
          all.removeClass('error');
          loc.next('.radio-group-error').remove();
        }
      }
    },

    /**
     * Shows an inline error message on a field
     * @private
     *
     * @param {jQuery[]} field
     * @param {string} message
     */
    showInlineError: function (field, message) {
      var loc = this.getField(field).addClass('error'),
        markup = '<div class="error-message">' +
          $.createIcon({ classes: ['icon-error'], icon: 'error' }) +
          '<pre class="audible">'+ Locale.translate('Error') +'</pre>' +
          '<p class="message-text">' + message +'</p>' +
          '</div>';


      if (field.is(':radio')) { // Radio button handler
        this.toggleRadioError(field, message, markup, true);
      } else { // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass('error');
        loc.closest('.field, .field-short').append(markup);
      }

      //Remove positive errors
      field.parent().find('.icon-confirm').remove();
    },

    /**
     * Shows an inline error message on a field
     *
     * @private
     * @param {jQuery[]} field
     */
    addPositive: function(field) {
      var svg = $.createIcon({ icon: 'confirm', classes: 'icon-confirm'});

      if (!$('.icon-confirm', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },

    /**
     * Shows an inline error message on a field
     *
     * @private
     * @param {jQuery[]} field
     */
    removeError: function(field) {
      var loc = this.getField(field),
        isRadio = field.is(':radio'),
        hasTooltip = field.attr('data-error-type');

      this.inputs.filter('input, textarea').off('focus.validate');
      field.removeClass('error');
      field.removeData('data-errormessage');

      if (hasTooltip) {
        var tooltipAPI = field.find('.icon.error').data('tooltip');

        if (tooltipAPI) {
          tooltipAPI.destroy();
        }
        if (field.attr('aria-describedby') === 'validation-tooltip') {
          field.removeAttr('aria-describedby');
          $('#validation-tooltip').remove();
        }
      }

      if (isRadio) {
        this.toggleRadioError(field);
      }
      else {
        field.next('.icon-error').off('click.validate').remove();
      }

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass('error'); // #shdo
        field.next().find('div.dropdown').removeClass('error').removeData('data-errormessage');
        field.parent().find('.dropdown-wrapper > .icon-error').off('click.validate').remove(); // SVG Error Icon
      }

      if (!isRadio) {
        field.next().next('.icon-error').remove();
        field.next('.inforCheckboxLabel').next('.icon-error').remove();
        field.parent('.field, .field-short').find('span.error').remove();
        field.parent().find('.icon-error').remove();
        field.off('focus.validate focus.tooltip');
      }

      if (loc.attr('data-placeholder')) {
        loc.attr('placeholder',loc.attr('data-placeholder'));
        loc.removeAttr('data-placeholder');
      }

      //Remove error classes from pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect')) {
        field.data('dropdown').pseudoElem.removeClass('error').removeAttr('placeholder');
      }

      if (field.parent().is('.editor-container')) {
        field.parent().removeClass('is-error');
      }

      // Enable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, true);
      }

      //Stuff for the inline error
      field.closest('.field, .field-short').find('.error-message').remove();
      field.parent('.field, .field-short').find('.formatter-toolbar').removeClass('error');
    },

    /**
     * Shows an inline error message on a field
     *
     * @private
     * @param {jQuery[]} field
     */
    removePositive: function(field) {
      $('.icon-confirm', field.parent('.field, .field-short')).remove();
    }
  };

  //Add a Message to a Field
  $.fn.addError = function(options) {
    var defaults = {message: '', showTooltip: false, inline: true},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.addError($(this), settings.message, settings.inline, settings.showTooltip);
    });
  };

  //Remove a Message from a Field
  $.fn.removeError = function(options) {
    var defaults = {message: ''},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.removeError($(this));
    });
  };

  $.fn.validate = function(options, args) {
    // Settings and Options
    var pluginName = 'validate',
      defaults = {
        inline: true
      },
      settings = $.extend({}, defaults, options);

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Validator(this, settings));
        instance.attachEvents();
      }
    });
  };

  //The validation rules object
  var Validation = function () {
    var self = this;
    this.rules = {
      required: {
        isNotEmpty: function(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field &&
              (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));
            if ($.trim(value).length === 0) {
              return false;
            }
            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }
            return true;
          }

          return (value ? true : false);
        },

        // Check if at least one radio button checked in group
        isRadioChecked: function (field) {
          var name = field.attr('name');
          return (name && name.length && $('input[name="'+ name +'"]:radio:checked').length);
        },

        check: function (value, field) {
          var self = this;

          //Check all required fields filled on modal

          var allFilled = true;
          field.closest('.modal').find('input.required, textarea.required, select.required').not(':hidden').each(function () {
            if (!self.isNotEmpty($(this).val())) {
              allFilled = false;
            }
          });

          if (allFilled) {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').removeAttr('disabled');
          } else {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').attr('disabled', 'disabled');
          }

          this.message = Locale.translate('Required');
          return field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
        },
        message: 'Required'
      },

      //date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function (value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = (value.indexOf(':') > -1) ? Locale.calendar().dateFormat.datetime: Locale.calendar().dateFormat.short;

          if (field && field.data('datepicker')) {
            dateFormat = field.data('datepicker').pattern;
          }

          var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy'),
            parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return ((parsedDate === undefined) && value !== '') ? false : true;
        },
        message: 'Invalid Date'
      },

      //Validate date, disable dates
      availableDate: {
        check: function (value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          if(value !== '' && self.rules.date.check(value)) { //if valid date
            var d, i, l, min, max,
              d2 = new Date(value),
              options = field.data('datepicker').settings;

            if (options) {

              min = (new Date(options.disable.minDate)).setHours(0,0,0,0);
              max = (new Date(options.disable.maxDate)).setHours(0,0,0,0);

              //dayOfWeek
              if(options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
                check = false;
              }

              d2 = d2.setHours(0,0,0,0);

              //min and max
              if((d2 <= min) || (d2 >= max)) {
                check = false;
              }

              //dates
              if (options.disable.dates.length && typeof options.disable.dates === 'string') {
                options.disable.dates = [options.disable.dates];
              }
              for (i=0, l=options.disable.dates.length; i<l; i++) {
                d = new Date(options.disable.dates[i]);
                if(d2 === d.setHours(0,0,0,0)) {
                  check = false;
                  break;
                }
              }
            }
            check = ((check && !options.disable.isEnable) || (!check && options.disable.isEnable)) ? true : false;
          }

          return check;
        },
        message: 'Unavailable Date'
      },

      email: {
        check: function (value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;

          return (value.length) ? regex.test(value) : true;
        },
        message: 'EmailValidation'
      },

      enableSubmit: {
        check: function (value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]'),
            ok = ((value.length) && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field)));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }
          return true;
        },
        message: ''
      },

      emailPositive: {
        check: function (value, field) {
          if($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');

            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          } else {
            self.rules.emailPositive.positive = false;
            return true;
          }
        },
        message: 'EmailValidation'
      },

      passwordReq: {
        check: function (value) {
         this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */
          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return (value.length) ? value.match(regex) : true;
        },
        message: 'PasswordValidation'
      },

      passwordConfirm: {
        check: function (value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $('input[type="password"]:not('+ field.attr('id') +')', field.closest('.signin')).eq(0).val(),
            check = ((value === passwordValue) && (self.rules.passwordReq.check(passwordValue)));
          return (value.length) ? check : true;
        },
        message: 'PasswordConfirmValidation'
      },

      time: {
        check: function(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepickerSettings = field && field.data('timepicker') ? field.data('timepicker').settings : {},
            pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat,
            is24Hour = (pattern.match('HH') || []).length > 0,
            maxHours = is24Hour ? 24 : 12,
            colon = value.indexOf(Locale.calendar().dateFormat.timeSeparator),
            valueHours = 0,
            valueMins,
            valueM;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, colon));
          valueMins = parseInt(value.substring(colon + 1, colon + 3));

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours) < 0 || parseInt(valueHours) > maxHours) {
            return false;
          }
          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins) < 0 || parseInt(valueMins) > 59) {
            return false;
          }

          // AM/PM
          if (!is24Hour) {
            if (parseInt(valueHours) < 1) {
              return false;
            }
            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i'),
              period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');

            valueM = value.match(period0) || value.match(period1) || [];
            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },
        message: 'Invalid Time'
      },

      //Test validation function, always returns false
      test: {

        check: function(value) {
          return value === '1' ? true : false;
        },

        message: 'Value is not valid (test).'
      }
    };
  };

  $.fn.validation = new Validation();

  $.fn.isValid = function() {
    return ($(this).data('isValid') ? true : false);
  };

 //Check validation manually
  $.fn.checkValidation = function() {
    var field = $(this),
      api = field.data('validate'),
      doAction = function(isValid) {
        field.data('isValid', isValid);
      };

    if (api && api.validate) {
      var fx = api.validate(field, false, 0);
      $.when.apply($, fx).always(function() {
        // [fail] returns the first fail, so we have to loop deferred objects
        $.each(fx, function() {
          this.done(function() {
            doAction(true);
          }).fail(function() {
            doAction(false);
          });
        });
      });
    }
  };

  //Clear out the stuff on the Form
  $.fn.resetForm = function() {
    var formFields = $(this).find('input, select, textarea');

    //Clear Errors
    formFields.removeClass('error');
    $(this).find('.error').removeClass('error');
    $(this).find('.icon-error').remove();
    $(this).find('.icon-confirm').remove();
    $(this).find('.error-message').remove();

    setTimeout(function () {
      $('#validation-errors').addClass('is-hidden');
    }, 300);

    //Remove Dirty
    formFields.data('isDirty', false).removeClass('isDirty');
    $(this).find('.isDirty').removeClass('isDirty');

    //reset form data
    if ($(this).is('form')) {
      $(this)[0].reset();
    }
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.wizard = function(options) {
    'use strict';

    /**
    * The Autocomplete control provides an easier means of searching through a large amount of data by filtering down the results based on keyboard input from the user.
    *
    * @class Wizard
    *
    * @param {jQuery[]} ticks  &nbsp;-&nbsp; Defines the data to use, must be specified.
    *
    */

    // Settings and Options
    var pluginName = 'wizard',
        defaults = {
          ticks: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Wizard(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Wizard.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        this
          .build()
          .handleEvents();
      },

      /**
       * @private
       * @returns {this}
       */
      build: function() {
        this.header = this.element.find('.wizard-header');
        if (!this.header.length) {
          this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
        }

        this.bar = this.element.find('.bar');
        if (!this.bar.length) {
          this.bar = $('<div class="bar"></div>').appendTo(this.header);
        }

        this.completedRange = this.element.find('.completed-range');
        if (!this.completedRange.length) {
          this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
        }

        this
          .buildTicks()
          .updateRange();

        return this;
      },

      buildTicks: function() {
        var settingTicks = this.settings.ticks,
          self = this;

        this.ticks = this.bar.children('.tick');

        if (!this.ticks.length && settingTicks) {

          for (var i = 0; i < settingTicks.length; i++) {
            var link = $('<a ng-click="handleClick()" class="tick ' + (settingTicks[i].state ? settingTicks[i].state : '') + '" href="'+ (settingTicks[i].href ? settingTicks[i].href : '#') +'"><span class="label">' + settingTicks[i].label + '</span></a>');

            if (settingTicks[i].ngClick) {
              link.attr('ng-click', settingTicks[i].ngClick);
            }

            self.bar.append(link);
          }
          this.ticks = this.bar.children('.tick');
        }
        this.positionTicks();

        $('.tick', self.element).each(function() {
          var tick = $(this);
          if (tick.hasClass('is-disabled')) {
            tick.removeAttr('onclick ng-click');
          }
        });

        this.element.find('.wizard-header')[0].style.opacity = '1';
        return this;
      },

      positionTicks: function() {
        var l = this.ticks.length,
          delta = 100 / (l - 1),
          tickPos = [];

        function getPoint(i) {
          if (i === 0) {
            return 0;
          }
          if (i === l - 1) {
            return 100;
          } else {
            return delta * i;
          }
        }

        for (var i = 0; i < l; i++) {
          tickPos.push(getPoint(i));
        }

        this.ticks.each(function(i) {
          var tick = $(this),
            label = tick.children('.label'),
            left = Locale.isRTL() ? (100-tickPos[i]) : tickPos[i];

          this.style.left = left + '%';

          for (var i2 = 0, l2 = label.length; i2 < l2; i2++) {
            label[i2].style.left = '-' + (label.outerWidth()/2 - tick.outerWidth()/2) + 'px';
          }

          if (tick.is('.is-disabled')) {
            tick.attr('tabindex', '-1');
          }
        });
      },

      updateRange: function() {
        var currentTick = this.ticks.filter('.current').last(),
          widthPercentage = 0;

        if (currentTick.length) {
          widthPercentage = (100 * parseFloat(window.getComputedStyle(currentTick[0]).left) / parseFloat(window.getComputedStyle(currentTick.parent()[0]).width));
          widthPercentage = Locale.isRTL() ? (100-widthPercentage) : widthPercentage;
        }

        this.completedRange[0].style.width = widthPercentage + '%';
        return this;
      },

      updated: function() {
        this
          .buildTicks()
          .updateRange();

        return this;
      },

      teardown: function() {
        this.ticks.offTouchClick('wizard').off('click.wizard');
        this.element.off('updated.wizard');

        this.ticks.remove();
        return this;
      },

      // Deprecating the "select()" method in favor of "activate()" to match the API of our other controls
      // Temporarily adding functionality that reroutes this method to the new "activate" method.
      select: function(e, tick) {
        return this.activate(e, tick);
      },

      // Activates one of the Wizard's ticks.
      // Tick can either be a number (representing the tick's index) or a jQuery element reference to a tick
      activate: function(e, tick) {
        if (e === undefined && !tick) {
          return this;
        }

        var self = this;

        function getTick() {
          var target;

          // Use the first variable as the tick definition or index if "e" is null, undefined, or not an event object.
          // This is for backwards compatibility with this control's old select() method, which took an index as an argument.
          if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
            tick = e;
          }

          if (tick === undefined) {
            target = $(e.target);
            return target.is('.label') ? target.parent() : target;
          }

          if (typeof tick === 'number') {
            return self.ticks.eq(tick);
          }

          return tick;
        }

        tick = getTick();

        if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
          e.preventDefault();
          e.stopPropagation();
          return this;
        }

        // Cancel selection by returning a 'beforeactivate' handler as 'false'
        var canNav = this.element.triggerHandler('beforeactivate', [tick]);
        if (canNav === false) {
          return this;
        }

        var trueIndex = this.ticks.index(tick);
        this.ticks.removeClass('complete current')
          .eq(trueIndex).addClass('current')
          .prevAll('.tick').addClass('complete');

        this.updateRange();
        this.element.trigger('activated', [tick]);

        // Timeout allows animation to finish
        setTimeout(function () {
          self.element.trigger('afteractivated', [tick]);
        }, 300);

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * This component listens to the following events:
       * @param module:Wizard~event:updated
       * @param module:Wizard~event:click
       */
      handleEvents: function() {
        var self = this;

        this.element.on('updated', function() {
          self.updated();
        });

        this.ticks.onTouchClick('wizard').on('click.wizard', function(e) {
          self.activate(e, $(this));
        });

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Wizard(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.zoom = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'zoom',
        settings = $.extend({}, options);

    /**
     * @constructor
     * @param {Object} element
     * @param {Object} settings
     */
    function Zoom(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Zoom.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        // get references to elements
        this.viewport = this.element.find('meta[name=viewport]');
        this.body = $('body');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        // Allow the head to listen to events to globally deal with the zoom problem on
        // a per-control basis (for example, Dropdown/Multiselect need to handle this issue manually).
        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('enable-zoom', function() {
          self.enableZoom();
        }).on('disable-zoom', function() {
          self.disableZoom();
        });

        // Don't continue setting this up on each element if
        if (Soho.env.os.name !== 'ios') {
          return this;
        }

        // Setup conditional events for all elements that need it.
        this.body.on('touchstart.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            return;
          }

          self.disableZoom();
        }).on('touchend.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            clearTimeout(self.noZoomTimeout);
            self.noZoomTimeout = null;
          }
          self.noZoomTimeout = setTimeout(function() {
            self.noZoomTimeout = null;
            self.enableZoom();
          }, 600);
        });

        return this;
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      enableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=1');
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      disableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName + ' enable-zoom disable-zoom');
        this.body.off('touchstart.zoomdisabler touchend.zoomdisabler');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Zoom(this, settings));
      }
    });
  };


}));
//# sourceURL=sohoxi.js